{
  "_content": {
    "Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "Add a new background job and start it in a separate thread."
                }
              }
            ]
          }
        }
      ]
    },
    "Extended Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "There are two types of jobs which can be created:"
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "1. Jobs based on expressions which can be passed to an eval() call. The expression must be given as a string.  For example:"
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "  job_manager.new('myfunc(x,y,z=1)'[,glob[,loc]])"
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "The given expression is passed to eval(), along with the optional global/local dicts provided.  If no dicts are given, they are extracted automatically from the caller's frame."
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "A Python statement is NOT a valid eval() expression.  Basically, you can only use as an eval() argument something which can go on the right of an '=' sign and be assigned to a variable."
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "For example,\"print 'hello'\" is not valid, but '2+3' is."
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "2. Jobs given a function object, optionally passing additional positional arguments:"
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "  job_manager.new(myfunc, x, y)"
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "The function is called with the given arguments."
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "If you need to pass keyword arguments to your function, you must supply them as a dict named kw:"
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "  job_manager.new(myfunc, x, y, kw=dict(z=1))"
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "The reason for this assymmetry is that the new() method needs to maintain access to its own keywords, and this prevents name collisions between arguments to new() and arguments to your own functions."
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "In both cases, the result is stored in the job.result field of the background job object."
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "You can set "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "daemon"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " attribute of the thread by giving the keyword argument "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "daemon"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "."
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "Notes and caveats:"
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "1. All threads running share the same standard output.  Thus, if your background jobs generate output, it will come out on top of whatever you are currently writing.  For this reason, background jobs are best used with silent functions which simply return their output."
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "2. Threads also all work within the same global namespace, and this system does not lock interactive variables.  So if you send job to the background which operates on a mutable object for a long time, and start modifying that same mutable object interactively (or in another backgrounded job), all sorts of bizarre behaviour will occur."
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "3. If a background job is spending a lot of time inside a C extension module which does not release the Python Global Interpreter Lock (GIL), this will block the IPython prompt.  This is simply because the Python interpreter can only switch between threads at Python bytecodes.  While the execution is inside C code, the interpreter must simply wait unless the extension module releases the GIL."
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "4. There is no way, due to limitations in the Python threads library, to kill a thread once it has started."
                }
              }
            ]
          }
        }
      ]
    },
    "Parameters": {
      "children": []
    },
    "Returns": {
      "children": []
    },
    "Yields": {
      "children": []
    },
    "Receives": {
      "children": []
    },
    "Raises": {
      "children": []
    },
    "Warns": {
      "children": []
    },
    "Other Parameters": {
      "children": []
    },
    "Attributes": {
      "children": []
    },
    "Methods": {
      "children": []
    },
    "Notes": {
      "children": []
    },
    "Warnings": {
      "children": []
    }
  },
  "refs": [],
  "ordered_sections": [
    "Summary",
    "Extended Summary"
  ],
  "item_file": "/Users/bussonniermatthias/dev/ipython/IPython/lib/backgroundjobs.py",
  "item_line": 106,
  "item_type": "<class 'function'>",
  "aliases": [
    "IPython.lib.backgroundjobs.BackgroundJobManager.new"
  ],
  "example_section_data": {
    "children": []
  },
  "see_also": [],
  "references": null,
  "signature": "new(self, func_or_exp, *args, **kwargs)"
}