{
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "There are two main ways to define your own magic functions: from standalone functions and by inheriting from a base class provided by IPython: "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "IPython.core.magic.Magics"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ". Below we show code you can place in a file that you load from your configuration, such as any file in the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "startup"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " subdirectory of your default IPython profile."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "First, let us see the simplest case. The following shows how to create a line magic, a cell one and one that works in both modes, using just plain functions:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "python",
            "content": "from IPython.core.magic import (register_line_magic, register_cell_magic,\n                                register_line_cell_magic)\n\n@register_line_magic\ndef lmagic(line):\n    \"my line magic\"\n    return line\n\n@register_cell_magic\ndef cmagic(line, cell):\n    \"my cell magic\"\n    return line, cell\n\n@register_line_cell_magic\ndef lcmagic(line, cell=None):\n    \"Magic that works both as %lcmagic and as %%lcmagic\"\n    if cell is None:\n        print(\"Called as line magic\")\n        return line\n    else:\n        print(\"Called as cell magic\")\n        return line, cell\n\n# In an interactive session, we need to delete these to avoid\n# name conflicts for automagic to work on line magics.\ndel lmagic, lcmagic",
            "name": "sourcecode",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "You can also create magics of all three kinds by inheriting from the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "IPython.core.magic.Magics"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " class.  This lets you create magics that can potentially hold state in between calls, and that have full access to the main IPython object:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "python",
            "content": "# This code can be put in any Python module, it does not require IPython\n# itself to be running already.  It only creates the magics subclass but\n# doesn't instantiate it yet.\nfrom __future__ import print_function\nfrom IPython.core.magic import (Magics, magics_class, line_magic,\n                                cell_magic, line_cell_magic)\n\n# The class MUST call this class decorator at creation time\n@magics_class\nclass MyMagics(Magics):\n\n    @line_magic\n    def lmagic(self, line):\n        \"my line magic\"\n        print(\"Full access to the main IPython object:\", self.shell)\n        print(\"Variables in the user namespace:\", list(self.shell.user_ns.keys()))\n        return line\n\n    @cell_magic\n    def cmagic(self, line, cell):\n        \"my cell magic\"\n        return line, cell\n\n    @line_cell_magic\n    def lcmagic(self, line, cell=None):\n        \"Magic that works both as %lcmagic and as %%lcmagic\"\n        if cell is None:\n            print(\"Called as line magic\")\n            return line\n        else:\n            print(\"Called as cell magic\")\n            return line, cell\n\n\n# In order to actually use these magics, you must register them with a\n# running IPython.\n\ndef load_ipython_extension(ipython):\n    \"\"\"\n    Any module file that define a function named `load_ipython_extension`\n    can be loaded via `%load_ext module.path` or be configured to be\n    autoloaded by IPython at startup time.\n    \"\"\"\n    # You can register the class itself without instantiating it.  IPython will\n    # call the default constructor on it.\n    ipython.register_magics(MyMagics)",
            "name": "sourcecode",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "If you want to create a class with a different constructor that holds additional state, then you should always call the parent constructor and instantiate the class yourself before registration:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "python",
            "content": "@magics_class\nclass StatefulMagics(Magics):\n    \"Magics that hold additional state\"\n\n    def __init__(self, shell, data):\n        # You must call the parent constructor\n        super(StatefulMagics, self).__init__(shell)\n        self.data = data\n\n    # etc...\n\ndef load_ipython_extension(ipython):\n    \"\"\"\n    Any module file that define a function named `load_ipython_extension`\n    can be loaded via `%load_ext module.path` or be configured to be\n    autoloaded by IPython at startup time.\n    \"\"\"\n    # This class must then be registered with a manually created instance,\n    # since its constructor has different arguments from the default:\n    magics = StatefulMagics(ipython, some_data)\n    ipython.register_magics(magics)",
            "name": "sourcecode",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "In early IPython versions 0.12 and before the line magics were created using a "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": "func",
                        "value": "define_magic"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " API function.  This API has been replaced with the above in IPython 0.13 and then completely removed in IPython 5.  Maintainers of IPython extensions that still use the "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": "func",
                        "value": "define_magic"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " function are advised to adjust their code for the current API."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        }
      ],
      "level": 0,
      "target": "defining_magics",
      "title": "Defining custom magics"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "When creating line magics, you may need to access surrounding scope  to get user variables (e.g when called inside functions). IPython provide the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "@needs_local_scope"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " decorator that can be imported from "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "IPython.core.magics"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ". When decorated with "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "@needs_local_scope"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " a magic will be passed "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "local_ns"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " as an argument. As a convenience "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "@needs_local_scope"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " can also be applied to cell magics even if cell magics cannot appear at local scope context."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": "Accessing user namespace and local scope"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Here is a full example of a magic package. You can distribute magics using setuptools, distutils, or any other distribution tools like "
                },
                "type": "Words"
              },
              {
                "data": {
                  "target": "https://flit.readthedocs.io",
                  "value": "flit"
                },
                "type": "ExternalLink"
              },
              {
                "data": {
                  "value": " for pure Python packages."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "When distributing magics as part of a package, recommended best practice is to execute the registration inside the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "load_ipython_extension"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " as demonstrated in the example below, instead of directly in the module (as in the initial example with the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "@register_*"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " decorators). This means a user will need to explicitly choose to load your magic with "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "%load_ext"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ". instead implicitly getting it when importing the module. This is particularly relevant if loading your magic has  side effects, if it is slow to load, or if it might override another magic with the same name."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "bash",
            "content": ".\n\u251c\u2500\u2500 example_magic\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 abracadabra.py\n\u2514\u2500\u2500 setup.py",
            "name": "sourcecode",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "bash",
            "content": "$ cat example_magic/__init__.py\n\"\"\"An example magic\"\"\"\n__version__ = '0.0.1'\n\nfrom .abracadabra import Abracadabra\n\ndef load_ipython_extension(ipython):\n    ipython.register_magics(Abracadabra)",
            "name": "sourcecode",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "bash",
            "content": "$ cat example_magic/abracadabra.py\nfrom IPython.core.magic import (Magics, magics_class, line_magic, cell_magic)\n\n@magics_class\nclass Abracadabra(Magics):\n\n    @line_magic\n    def abra(self, line):\n        return line\n\n    @cell_magic\n    def cadabra(self, line, cell):\n        return line, cell",
            "name": "sourcecode",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "level": 0,
      "target": null,
      "title": "Complete Example"
    }
  ],
  "content": {},
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "see_also": [],
  "signature": {
    "value": null
  }
}