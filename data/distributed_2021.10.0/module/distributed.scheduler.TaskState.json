{
  "_content": {
    "Attributes": {
      "children": [],
      "title": null
    },
    "Extended Summary": {
      "children": [
        {
          "data": {
            "argument": "key: str",
            "content": "The key is the unique identifier of a task, generally formed\nfrom the name of the function, followed by a hash of the function\nand arguments, like ``'inc-ab31c010444977004d656610d2d421ec'``.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "prefix: TaskPrefix",
            "content": "The broad class of tasks to which this task belongs like \"inc\" or\n\"read_csv\"",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "run_spec: object",
            "content": "A specification of how to run the task.  The type and meaning of this\nvalue is opaque to the scheduler, as it is only interpreted by the\nworker to which the task is sent for executing.\n\nAs a special case, this attribute may also be ``None``, in which case\nthe task is \"pure data\" (such as, for example, a piece of data loaded\nin the scheduler using :meth:`Client.scatter`).  A \"pure data\" task\ncannot be computed again if its value is lost.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "priority: tuple",
            "content": "The priority provides each task with a relative ranking which is used\nto break ties when many tasks are being considered for execution.\n\nThis ranking is generally a 2-item tuple.  The first (and dominant)\nitem corresponds to when it was submitted.  Generally, earlier tasks\ntake precedence.  The second item is determined by the client, and is\na way to prioritize tasks within a large graph that may be important,\nsuch as if they are on the critical path, or good to run in order to\nrelease many dependencies.  This is explained further in\n:doc:`Scheduling Policy <scheduling-policies>`.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "state: str",
            "content": "This task's current state.  Valid states include ``released``,\n``waiting``, ``no-worker``, ``processing``, ``memory``, ``erred``\nand ``forgotten``.  If it is ``forgotten``, the task isn't stored\nin the ``tasks`` dictionary anymore and will probably disappear\nsoon from memory.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "dependencies: {TaskState}",
            "content": "The set of tasks this task depends on for proper execution.  Only\ntasks still alive are listed in this set.  If, for whatever reason,\nthis task also depends on a forgotten task, the\n:attr:`has_lost_dependencies` flag is set.\n\nA task can only be executed once all its dependencies have already\nbeen successfully executed and have their result stored on at least\none worker.  This is tracked by progressively draining the\n:attr:`waiting_on` set.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "dependents: {TaskState}",
            "content": "The set of tasks which depend on this task.  Only tasks still alive\nare listed in this set.\n\nThis is the reverse mapping of :attr:`dependencies`.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "has_lost_dependencies: bool",
            "content": "Whether any of the dependencies of this task has been forgotten.\nFor memory consumption reasons, forgotten tasks are not kept in\nmemory even though they may have dependent tasks.  When a task is\nforgotten, therefore, each of its dependents has their\n:attr:`has_lost_dependencies` attribute set to ``True``.\n\nIf :attr:`has_lost_dependencies` is true, this task cannot go\ninto the \"processing\" state anymore.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "waiting_on: {TaskState}",
            "content": "The set of tasks this task is waiting on *before* it can be executed.\nThis is always a subset of :attr:`dependencies`.  Each time one of the\ndependencies has finished processing, it is removed from the\n:attr:`waiting_on` set.\n\nOnce :attr:`waiting_on` becomes empty, this task can move from the\n\"waiting\" state to the \"processing\" state (unless one of the\ndependencies errored out, in which case this task is instead\nmarked \"erred\").",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "waiters: {TaskState}",
            "content": "The set of tasks which need this task to remain alive.  This is always\na subset of :attr:`dependents`.  Each time one of the dependents\nhas finished processing, it is removed from the :attr:`waiters`\nset.\n\nOnce both :attr:`waiters` and :attr:`who_wants` become empty, this\ntask can be released (if it has a non-empty :attr:`run_spec`) or\nforgotten (otherwise) by the scheduler, and by any workers\nin :attr:`who_has`.\n\n.. note:: Counter-intuitively, :attr:`waiting_on` and\n   :attr:`waiters` are not reverse mappings of each other.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "who_wants: {ClientState}",
            "content": "The set of clients who want this task's result to remain alive.\nThis is the reverse mapping of :attr:`ClientState.wants_what`.\n\nWhen a client submits a graph to the scheduler it also specifies\nwhich output tasks it desires, such that their results are not released\nfrom memory.\n\nOnce a task has finished executing (i.e. moves into the \"memory\"\nor \"erred\" state), the clients in :attr:`who_wants` are notified.\n\nOnce both :attr:`waiters` and :attr:`who_wants` become empty, this\ntask can be released (if it has a non-empty :attr:`run_spec`) or\nforgotten (otherwise) by the scheduler, and by any workers\nin :attr:`who_has`.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "who_has: {WorkerState}",
            "content": "The set of workers who have this task's result in memory.\nIt is non-empty iff the task is in the \"memory\" state.  There can be\nmore than one worker in this set if, for example, :meth:`Client.scatter`\nor :meth:`Client.replicate` was used.\n\nThis is the reverse mapping of :attr:`WorkerState.has_what`.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "processing_on: WorkerState (or None)",
            "content": "If this task is in the \"processing\" state, which worker is currently\nprocessing it.  Otherwise this is ``None``.\n\nThis attribute is kept in sync with :attr:`WorkerState.processing`.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "retries: int",
            "content": "The number of times this task can automatically be retried in case\nof failure.  If a task fails executing (the worker returns with\nan error), its :attr:`retries` attribute is checked.  If it is\nequal to 0, the task is marked \"erred\".  If it is greater than 0,\nthe :attr:`retries` attribute is decremented and execution is\nattempted again.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "nbytes: int (or None)",
            "content": "The number of bytes, as determined by ``sizeof``, of the result\nof a finished task.  This number is used for diagnostics and to\nhelp prioritize work.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "type: str",
            "content": "The type of the object as a string.  Only present for tasks that have\nbeen computed.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "exception: object",
            "content": "If this task failed executing, the exception object is stored here.\nOtherwise this is ``None``.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "traceback: object",
            "content": "If this task failed executing, the traceback object is stored here.\nOtherwise this is ``None``.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "exception_blame: TaskState (or None)",
            "content": "If this task or one of its dependencies failed executing, the\nfailed task is stored here (possibly itself).  Otherwise this\nis ``None``.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "erred_on: set(str)",
            "content": "Worker addresses on which errors appeared causing this task to be in an error state.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "suspicious: int",
            "content": "The number of times this task has been involved in a worker death.\n\nSome tasks may cause workers to die (such as calling ``os._exit(0)``).\nWhen a worker dies, all of the tasks on that worker are reassigned\nto others.  This combination of behaviors can cause a bad task to\ncatastrophically destroy all workers on the cluster, one after\nanother.  Whenever a worker dies, we mark each task currently\nprocessing on that worker (as recorded by\n:attr:`WorkerState.processing`) as suspicious.\n\nIf a task is involved in three deaths (or some other fixed constant)\nthen we mark the task as ``erred``.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "host_restrictions: {hostnames}",
            "content": "A set of hostnames where this task can be run (or ``None`` if empty).\nUsually this is empty unless the task has been specifically restricted\nto only run on certain hosts.  A hostname may correspond to one or\nseveral connected workers.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "worker_restrictions: {worker addresses}",
            "content": "A set of complete worker addresses where this can be run (or ``None``\nif empty).  Usually this is empty unless the task has been specifically\nrestricted to only run on certain workers.\n\nNote this is tracking worker addresses, not worker states, since\nthe specific workers may not be connected at this time.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "resource_restrictions: {resource: quantity}",
            "content": "Resources required by this task, such as ``{'gpu': 1}`` or\n``{'memory': 1e9}`` (or ``None`` if empty).  These are user-defined\nnames and are matched against the contents of each\n:attr:`WorkerState.resources` dictionary.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "loose_restrictions: bool",
            "content": "If ``False``, each of :attr:`host_restrictions`,\n:attr:`worker_restrictions` and :attr:`resource_restrictions` is\na hard constraint: if no worker is available satisfying those\nrestrictions, the task cannot go into the \"processing\" state and\nwill instead go into the \"no-worker\" state.\n\nIf ``True``, the above restrictions are mere preferences: if no worker\nis available satisfying those restrictions, the task can still go\ninto the \"processing\" state and be sent for execution to another\nconnected worker.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "metadata: dict",
            "content": "Metadata related to task.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "actor: bool",
            "content": "Whether or not this task is an Actor.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "group: TaskGroup",
            "content": "The group of tasks to which this one belongs.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "annotations: dict",
            "content": "Task annotations",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": null
    },
    "Methods": {
      "children": [],
      "title": null
    },
    "Notes": {
      "children": [],
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "title": null
    },
    "Parameters": {
      "children": [],
      "title": null
    },
    "Raises": {
      "children": [],
      "title": null
    },
    "Receives": {
      "children": [],
      "title": null
    },
    "Returns": {
      "children": [],
      "title": null
    },
    "Summary": {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "A simple object holding information about a task."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "title": null
    },
    "Warnings": {
      "children": [],
      "title": null
    },
    "Warns": {
      "children": [],
      "title": null
    },
    "Yields": {
      "children": [],
      "title": null
    }
  },
  "aliases": [
    "distributed.scheduler.TaskState"
  ],
  "arbitrary": [],
  "example_section_data": {
    "children": [],
    "title": null
  },
  "item_file": "/distributed/scheduler.py",
  "item_line": 1142,
  "item_type": "<class 'type'>",
  "ordered_sections": [
    "Summary",
    "Extended Summary"
  ],
  "references": null,
  "refs": [],
  "see_also": [],
  "signature": {
    "value": null
  }
}