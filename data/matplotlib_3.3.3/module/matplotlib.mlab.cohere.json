{
  "_content": {
    "Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "The coherence between *x* and *y*.  Coherence is the normalized cross spectral density:"
                }
              }
            ]
          }
        }
      ]
    },
    "Extended Summary": {
      "children": [
        {
          "type": "BlockDirective",
          "data": {
            "lines": {
              "_lines": [
                {
                  "_line": ".. math::",
                  "_number": 0,
                  "_offset": 0
                }
              ]
            },
            "wh": {
              "_lines": [
                {
                  "_line": "",
                  "_number": 1,
                  "_offset": 0
                }
              ]
            },
            "ind": {
              "_lines": [
                {
                  "_line": "    C_{xy} = \\frac{|P_{xy}|^2}{P_{xx}P_{yy}}",
                  "_number": 2,
                  "_offset": 0
                }
              ]
            },
            "directive_name": "math",
            "args0": [
              ""
            ],
            "inner": {
              "children": [
                {
                  "type": "Words",
                  "data": {
                    "value": "C_{xy} = \\frac{|P_{xy}|^2}{P_{xx}P_{yy}}"
                  }
                }
              ]
            }
          }
        }
      ]
    },
    "Parameters": {
      "children": [
        {
          "type": "Param",
          "data": {
            "param": "x, y",
            "type_": "",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Array or sequence containing the data"
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "Fs",
            "type_": "float, default: 2",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The sampling frequency (samples per time unit).  It is used to calculate the Fourier frequencies, *freqs*, in cycles per time unit."
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "window",
            "type_": "callable or ndarray, default: `.window_hanning`",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "A function or a vector of length *NFFT*.  To create window vectors see "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".window",
                          "_",
                          "hanning"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".window",
                          "_",
                          "none"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "numpy.blackman"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "numpy.hamming"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "numpy.bartlett"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "scipy.signal"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "scipy.signal.get",
                          "_",
                          "window"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", etc.  If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment."
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "sides",
            "type_": "{'default', 'onesided', 'twosided'}, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Which sides of the spectrum to return. 'default' is one-sided for real data and two-sided for complex data. 'onesided' forces the return of a one-sided spectrum, while 'twosided' forces two-sided."
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "pad_to",
            "type_": "int, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The number of points to which the data segment is padded when performing the FFT.  This can be different from *NFFT*, which specifies the number of data points used.  While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the *n* parameter in the call to fft(). The default is None, which sets *pad_to* equal to *NFFT*"
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "NFFT",
            "type_": "int, default: 256",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The number of data points used in each block for the FFT.  A power 2 is most efficient.  This should *NOT* be used to get zero padding, or the scaling of the result will be incorrect; use *pad_to* for this instead."
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "detrend",
            "type_": "{'none', 'mean', 'linear'} or callable, default 'none'",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The function applied to each segment before fft-ing, designed to remove the mean or linear trend.  Unlike in MATLAB, where the *detrend* parameter is a vector, in Matplotlib is it a function.  The "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "~matplotlib.mlab"
                        ],
                        "domain": null,
                        "role": "mod"
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " module defines "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".detrend",
                          "_",
                          "none"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".detrend",
                          "_",
                          "mean"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", and "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".detrend",
                          "_",
                          "linear"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", but you can use a custom function as well.  You can also use a string to choose one of the functions: 'none' calls "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".detrend",
                          "_",
                          "none"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". 'mean' calls "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".detrend",
                          "_",
                          "mean"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". 'linear' calls "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".detrend",
                          "_",
                          "linear"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "."
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "scale_by_freq",
            "type_": "bool, default: True",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Whether the resulting density values should be scaled by the scaling frequency, which gives density in units of Hz^-1.  This allows for integration over the returned frequency values.  The default is True for MATLAB compatibility."
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "noverlap",
            "type_": "int",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The number of points of overlap between blocks.  The default value is 0 (no overlap)."
                      }
                    }
                  ]
                }
              }
            ]
          }
        }
      ]
    },
    "Returns": {
      "children": [
        {
          "type": "Param",
          "data": {
            "param": "",
            "type_": "The return value is the tuple (*Cxy*, *f*), where *f* are the",
            "desc": []
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "",
            "type_": "frequencies of the coherence vector. For cohere, scaling the",
            "desc": []
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "",
            "type_": "individual densities by the sampling frequency has no effect,",
            "desc": []
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "",
            "type_": "since the factors cancel out.",
            "desc": []
          }
        }
      ]
    },
    "Yields": {
      "children": []
    },
    "Receives": {
      "children": []
    },
    "Raises": {
      "children": []
    },
    "Warns": {
      "children": []
    },
    "Other Parameters": {
      "children": []
    },
    "Attributes": {
      "children": []
    },
    "Methods": {
      "children": []
    },
    "Notes": {
      "children": []
    },
    "Warnings": {
      "children": []
    }
  },
  "refs": [
    "csd",
    "psd"
  ],
  "ordered_sections": [
    "Summary",
    "Extended Summary",
    "Parameters",
    "Returns",
    "See Also"
  ],
  "item_file": "/Users/bussonniermatthias/miniconda3/lib/python3.8/site-packages/matplotlib/mlab.py",
  "item_line": 911,
  "item_type": "<class 'function'>",
  "aliases": [
    "matplotlib.mlab.cohere"
  ],
  "example_section_data": {
    "children": []
  },
  "see_also": [
    {
      "name": {
        "name": "psd",
        "ref": null,
        "exists": null
      },
      "descriptions": [
        {
          "children": [
            {
              "type": "Words",
              "data": {
                "value": "For information about the methods used to compute "
              }
            },
            {
              "type": "Math",
              "data": {
                "value": [
                  "P",
                  "_",
                  "{xy}"
                ]
              }
            },
            {
              "type": "Words",
              "data": {
                "value": ", "
              }
            },
            {
              "type": "Math",
              "data": {
                "value": [
                  "P",
                  "_",
                  "{xx}"
                ]
              }
            },
            {
              "type": "Words",
              "data": {
                "value": " and "
              }
            },
            {
              "type": "Math",
              "data": {
                "value": [
                  "P",
                  "_",
                  "{yy}"
                ]
              }
            },
            {
              "type": "Words",
              "data": {
                "value": "."
              }
            }
          ]
        }
      ],
      "type": "func"
    },
    {
      "name": {
        "name": "csd",
        "ref": null,
        "exists": null
      },
      "descriptions": [
        {
          "children": [
            {
              "type": "Words",
              "data": {
                "value": "For information about the methods used to compute "
              }
            },
            {
              "type": "Math",
              "data": {
                "value": [
                  "P",
                  "_",
                  "{xy}"
                ]
              }
            },
            {
              "type": "Words",
              "data": {
                "value": ", "
              }
            },
            {
              "type": "Math",
              "data": {
                "value": [
                  "P",
                  "_",
                  "{xx}"
                ]
              }
            },
            {
              "type": "Words",
              "data": {
                "value": " and "
              }
            },
            {
              "type": "Math",
              "data": {
                "value": [
                  "P",
                  "_",
                  "{yy}"
                ]
              }
            },
            {
              "type": "Words",
              "data": {
                "value": "."
              }
            }
          ]
        }
      ],
      "type": "func"
    }
  ],
  "references": null,
  "signature": "cohere(x, y, NFFT=256, Fs=2, detrend=<function detrend_none at 0x13b85a160>, window=<function window_hanning at 0x13b851dc0>, noverlap=0, pad_to=None, sides='default', scale_by_freq=None)"
}