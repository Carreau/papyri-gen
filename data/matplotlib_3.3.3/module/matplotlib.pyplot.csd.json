{
  "_content": {
    "Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "Plot the cross-spectral density."
                }
              }
            ]
          }
        }
      ]
    },
    "Extended Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "The cross spectral density "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "P",
                    "_",
                    "{xy}"
                  ],
                  "domain": null,
                  "role": "math"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " by Welch's average periodogram method.  The vectors *x* and *y* are divided into *NFFT* length segments.  Each segment is detrended by function *detrend* and windowed by function *window*.  *noverlap* gives the length of the overlap between segments.  The product of the direct FFTs of *x* and *y* are averaged over each segment to compute "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "P",
                    "_",
                    "{xy}"
                  ],
                  "domain": null,
                  "role": "math"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ", with a scaling to correct for power loss due to windowing."
                }
              }
            ]
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "If len(*x*) < *NFFT* or len(*y*) < *NFFT*, they will be zero padded to *NFFT*."
                }
              }
            ]
          }
        }
      ]
    },
    "Parameters": {
      "children": [
        {
          "type": "Param",
          "data": {
            "param": "x, y",
            "type_": "1-D arrays or sequences",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Arrays or sequences containing the data."
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "Fs",
            "type_": "float, default: 2",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The sampling frequency (samples per time unit).  It is used to calculate the Fourier frequencies, *freqs*, in cycles per time unit."
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "window",
            "type_": "callable or ndarray, default: `.window_hanning`",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "A function or a vector of length *NFFT*.  To create window vectors see "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".window",
                          "_",
                          "hanning"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".window",
                          "_",
                          "none"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "numpy.blackman"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "numpy.hamming"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "numpy.bartlett"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "scipy.signal"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "scipy.signal.get",
                          "_",
                          "window"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", etc.  If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment."
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "sides",
            "type_": "{'default', 'onesided', 'twosided'}, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Which sides of the spectrum to return. 'default' is one-sided for real data and two-sided for complex data. 'onesided' forces the return of a one-sided spectrum, while 'twosided' forces two-sided."
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "pad_to",
            "type_": "int, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The number of points to which the data segment is padded when performing the FFT.  This can be different from *NFFT*, which specifies the number of data points used.  While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the *n* parameter in the call to fft(). The default is None, which sets *pad_to* equal to *NFFT*"
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "NFFT",
            "type_": "int, default: 256",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The number of data points used in each block for the FFT.  A power 2 is most efficient.  This should *NOT* be used to get zero padding, or the scaling of the result will be incorrect; use *pad_to* for this instead."
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "detrend",
            "type_": "{'none', 'mean', 'linear'} or callable, default 'none'",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The function applied to each segment before fft-ing, designed to remove the mean or linear trend.  Unlike in MATLAB, where the *detrend* parameter is a vector, in Matplotlib is it a function.  The "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "~matplotlib.mlab"
                        ],
                        "domain": null,
                        "role": "mod"
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " module defines "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".detrend",
                          "_",
                          "none"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".detrend",
                          "_",
                          "mean"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", and "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".detrend",
                          "_",
                          "linear"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", but you can use a custom function as well.  You can also use a string to choose one of the functions: 'none' calls "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".detrend",
                          "_",
                          "none"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". 'mean' calls "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".detrend",
                          "_",
                          "mean"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". 'linear' calls "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".detrend",
                          "_",
                          "linear"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "."
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "scale_by_freq",
            "type_": "bool, default: True",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Whether the resulting density values should be scaled by the scaling frequency, which gives density in units of Hz^-1.  This allows for integration over the returned frequency values.  The default is True for MATLAB compatibility."
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "noverlap",
            "type_": "int, default: 0 (no overlap)",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The number of points of overlap between segments."
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "Fc",
            "type_": "int, default: 0",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The center frequency of *x*, which offsets the x extents of the plot to reflect the frequency range used when a signal is acquired and then filtered and downsampled to baseband."
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "return_line",
            "type_": "bool, default: False",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Whether to include the line object plotted in the returned values."
                      }
                    }
                  ]
                }
              }
            ]
          }
        }
      ]
    },
    "Returns": {
      "children": [
        {
          "type": "Param",
          "data": {
            "param": "Pxy",
            "type_": "1-D array",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The values for the cross spectrum "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "P",
                          "_",
                          "{xy}"
                        ],
                        "domain": null,
                        "role": "math"
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " before scaling (complex valued)."
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "freqs",
            "type_": "1-D array",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The frequencies corresponding to the elements in *Pxy*."
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "line",
            "type_": "`~matplotlib.lines.Line2D`",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The line created by this function. Only returned if *return_line* is True."
                      }
                    }
                  ]
                }
              }
            ]
          }
        }
      ]
    },
    "Yields": {
      "children": []
    },
    "Receives": {
      "children": []
    },
    "Raises": {
      "children": []
    },
    "Warns": {
      "children": []
    },
    "Other Parameters": {
      "children": [
        {
          "type": "Param",
          "data": {
            "param": "**kwargs",
            "type_": "",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Keyword arguments control the "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".Line2D"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " properties:"
                      }
                    }
                  ]
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "children": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Properties: agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha: float or None animated: bool antialiased or aa: bool clip_box: "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".Bbox"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " clip_on: bool clip_path: Patch or (Path, Transform) or None color or c: color contains: unknown dash_capstyle: {'butt', 'round', 'projecting'} dash_joinstyle: {'miter', 'round', 'bevel'} dashes: sequence of floats (on/off ink in points) or (None, None) data: (2, N) array or two 1D arrays drawstyle or ds: {'default', 'steps', 'steps-pre', 'steps-mid', 'steps-post'}, default: 'default' figure: "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".Figure"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " fillstyle: {'full', 'left', 'right', 'bottom', 'top', 'none'} gid: str in_layout: bool label: object linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} linewidth or lw: float marker: marker style string, "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "~.path.Path"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " or "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "~.markers.MarkerStyle"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " markeredgecolor or mec: color markeredgewidth or mew: float markerfacecolor or mfc: color markerfacecoloralt or mfcalt: color markersize or ms: float markevery: None or int or (int, int) or slice or List[int] or float or (float, float) or List[bool] path_effects: "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".AbstractPathEffect"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " picker: unknown pickradius: float rasterized: bool or None sketch_params: (scale: float, length: float, randomness: float) snap: bool or None solid_capstyle: {'butt', 'round', 'projecting'} solid_joinstyle: {'miter', 'round', 'bevel'} transform: "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "matplotlib.transforms.Transform"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " url: str visible: bool xdata: 1D array ydata: 1D array zorder: float"
                      }
                    }
                  ]
                }
              }
            ]
          }
        }
      ]
    },
    "Attributes": {
      "children": []
    },
    "Methods": {
      "children": []
    },
    "Notes": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "children": [
              {
                "type": "Words",
                "data": {
                  "value": "For plotting, the power is plotted as "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "10",
                    " ",
                    "\\log",
                    "_",
                    "{10}(P",
                    "_",
                    "{xy})"
                  ],
                  "domain": null,
                  "role": "math"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " for decibels, though "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "P",
                    "_",
                    "{xy}"
                  ],
                  "domain": null,
                  "role": "math"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " itself is returned."
                }
              }
            ]
          }
        }
      ]
    },
    "Warnings": {
      "children": []
    }
  },
  "refs": [
    "psd"
  ],
  "ordered_sections": [
    "Summary",
    "Extended Summary",
    "Parameters",
    "Returns",
    "Other Parameters",
    "See Also",
    "Notes",
    "References"
  ],
  "item_file": "/Users/bussonniermatthias/miniconda3/lib/python3.8/site-packages/matplotlib/pyplot.py",
  "item_line": 2585,
  "item_type": "<class 'function'>",
  "aliases": [
    "matplotlib.pyplot.csd"
  ],
  "example_section_data": {
    "children": []
  },
  "see_also": [
    {
      "name": {
        "name": "psd",
        "ref": null,
        "exists": null
      },
      "descriptions": [
        {
          "children": [
            {
              "type": "Words",
              "data": {
                "value": "is equivalent to setting "
              }
            },
            {
              "type": "Verbatim",
              "data": {
                "value": [
                  "y",
                  " ",
                  "=",
                  " ",
                  "x"
                ]
              }
            },
            {
              "type": "Words",
              "data": {
                "value": "."
              }
            }
          ]
        }
      ],
      "type": null
    }
  ],
  "references": [
    "Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,",
    "John Wiley & Sons (1986)",
    "",
    ".. note::",
    "    In addition to the above described arguments, this function can take",
    "    a *data* keyword argument. If such a *data* argument is given,",
    "    the following arguments can also be string ``s``, which is",
    "    interpreted as ``data[s]`` (unless this raises an exception):",
    "    *x*, *y*.",
    "",
    "    Objects passed as **data** must support item access (``data[s]``) and",
    "    membership test (``s in data``)."
  ],
  "signature": "csd(x, y, NFFT=None, Fs=None, Fc=None, detrend=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None, return_line=None, *, data=None, **kwargs)"
}