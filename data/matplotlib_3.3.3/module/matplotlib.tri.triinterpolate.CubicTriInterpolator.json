{
  "_content": {
    "Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Cubic interpolator on a triangular grid."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Extended Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "In one-dimension - on a segment - a cubic interpolating function is defined by the values of the function and its derivative at both ends. This is almost the same in 2-d inside a triangle, except that the values of the function and its 2 derivatives have to be defined at each triangle node."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The CubicTriInterpolator takes the value of the function at each node - provided by the user - and internally computes the value of the derivatives, resulting in a smooth interpolation. (As a special feature, the user can also impose the value of the derivatives at each node, but this is not supposed to be the common usage.)"
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Parameters": {
      "children": [
        {
          "type": "Param",
          "data": {
            "param": "triangulation",
            "type_": "`~matplotlib.tri.Triangulation`",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The triangulation to interpolate over."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "z",
            "type_": "array-like of shape (npoints,)",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Array of values, defined at grid points, to interpolate between."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "kind",
            "type_": "{'min_E', 'geom', 'user'}, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Choice of the smoothing algorithm, in order to compute the interpolant derivatives (defaults to 'min_E'):"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "DefList",
                "data": {
                  "children": [
                    {
                      "lines": {
                        "_lines": [
                          {
                            "_line": "- if 'min_E': (default) The derivatives at each node is computed",
                            "_number": 3,
                            "_offset": 0
                          }
                        ]
                      },
                      "wh": {
                        "_lines": []
                      },
                      "ind": {
                        "_lines": [
                          {
                            "_line": "  to minimize a bending energy.",
                            "_number": 4,
                            "_offset": 2
                          }
                        ]
                      },
                      "dt": {
                        "inline": [
                          {
                            "type": "Words",
                            "data": {
                              "value": "- if 'min_E': (default) The derivatives at each node is computed"
                            }
                          }
                        ],
                        "inner": []
                      },
                      "dd": [
                        {
                          "type": "Paragraph",
                          "data": {
                            "inline": [
                              {
                                "type": "Words",
                                "data": {
                                  "value": "to minimize a bending energy."
                                }
                              }
                            ],
                            "inner": []
                          }
                        }
                      ]
                    },
                    {
                      "lines": {
                        "_lines": [
                          {
                            "_line": "- if 'geom': The derivatives at each node is computed as a",
                            "_number": 5,
                            "_offset": 0
                          }
                        ]
                      },
                      "wh": {
                        "_lines": []
                      },
                      "ind": {
                        "_lines": [
                          {
                            "_line": "  weighted average of relevant triangle normals. To be used for",
                            "_number": 6,
                            "_offset": 2
                          },
                          {
                            "_line": "  speed optimization (large grids).",
                            "_number": 7,
                            "_offset": 2
                          }
                        ]
                      },
                      "dt": {
                        "inline": [
                          {
                            "type": "Words",
                            "data": {
                              "value": "- if 'geom': The derivatives at each node is computed as a"
                            }
                          }
                        ],
                        "inner": []
                      },
                      "dd": [
                        {
                          "type": "Paragraph",
                          "data": {
                            "inline": [
                              {
                                "type": "Words",
                                "data": {
                                  "value": "weighted average of relevant triangle normals. To be used for speed optimization (large grids)."
                                }
                              }
                            ],
                            "inner": []
                          }
                        }
                      ]
                    },
                    {
                      "lines": {
                        "_lines": [
                          {
                            "_line": "- if 'user': The user provides the argument *dz*, no computation",
                            "_number": 8,
                            "_offset": 0
                          }
                        ]
                      },
                      "wh": {
                        "_lines": []
                      },
                      "ind": {
                        "_lines": [
                          {
                            "_line": "  is hence needed.",
                            "_number": 9,
                            "_offset": 2
                          }
                        ]
                      },
                      "dt": {
                        "inline": [
                          {
                            "type": "Words",
                            "data": {
                              "value": "- if 'user': The user provides the argument *dz*, no computation"
                            }
                          }
                        ],
                        "inner": []
                      },
                      "dd": [
                        {
                          "type": "Paragraph",
                          "data": {
                            "inline": [
                              {
                                "type": "Words",
                                "data": {
                                  "value": "is hence needed."
                                }
                              }
                            ],
                            "inner": []
                          }
                        }
                      ]
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "trifinder",
            "type_": "`~matplotlib.tri.TriFinder`, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "If not specified, the Triangulation's default TriFinder will be used by calling "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          ".Triangulation.get",
                          "_",
                          "trifinder"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "dz",
            "type_": "tuple of array-likes (dzdx, dzdy), optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Used only if  *kind* ='user'. In this case *dz* must be provided as (dzdx, dzdy) where dzdx, dzdy are arrays of the same shape as *z* and are the interpolant first derivatives at the *triangulation* points."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        }
      ],
      "title": null
    },
    "Returns": {
      "children": [],
      "title": null
    },
    "Yields": {
      "children": [],
      "title": null
    },
    "Receives": {
      "children": [],
      "title": null
    },
    "Raises": {
      "children": [],
      "title": null
    },
    "Warns": {
      "children": [],
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "title": null
    },
    "Attributes": {
      "children": [],
      "title": null
    },
    "Methods": {
      "children": [
        {
          "type": "Param",
          "data": {
            "param": "`__call__` (x, y)",
            "type_": "Returns interpolated values at (x, y) points.",
            "desc": []
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "`gradient` (x, y)",
            "type_": "Returns interpolated derivatives at (x, y) points.",
            "desc": []
          }
        }
      ],
      "title": null
    },
    "Notes": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "This note is a bit technical and details how the cubic interpolation is computed."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The interpolation is based on a Clough-Tocher subdivision scheme of the *triangulation* mesh (to make it clearer, each triangle of the grid will be divided in 3 child-triangles, and on each child triangle the interpolated function is a cubic polynomial of the 2 coordinates). This technique originates from FEM (Finite Element Method) analysis; the element used is a reduced Hsieh-Clough-Tocher (HCT) element. Its shape functions are described in [1]_. The assembled function is guaranteed to be C1-smooth, i.e. it is continuous and its first derivatives are also continuous (this is easy to show inside the triangles but is also true when crossing the edges)."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "In the default case (*kind* ='min_E'), the interpolant minimizes a curvature energy on the functional space generated by the HCT element shape functions - with imposed values but arbitrary derivatives at each node. The minimized functional is the integral of the so-called total curvature (implementation based on an algorithm from [2]_ - PCG sparse solver):"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "    .. math::"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "lines": {
              "_lines": [
                {
                  "_line": "        E(z) = \\frac{1}{2} \\int_{\\Omega} \\left(",
                  "_number": 24,
                  "_offset": 8
                },
                {
                  "_line": "            \\left( \\frac{\\partial^2{z}}{\\partial{x}^2} \\right)^2 +",
                  "_number": 25,
                  "_offset": 8
                },
                {
                  "_line": "            \\left( \\frac{\\partial^2{z}}{\\partial{y}^2} \\right)^2 +",
                  "_number": 26,
                  "_offset": 8
                },
                {
                  "_line": "            2\\left( \\frac{\\partial^2{z}}{\\partial{y}\\partial{x}} \\right)^2",
                  "_number": 27,
                  "_offset": 8
                },
                {
                  "_line": "        \\right) dx\\,dy",
                  "_number": 28,
                  "_offset": 8
                },
                {
                  "_line": "",
                  "_number": 29,
                  "_offset": 8
                }
              ]
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "If the case *kind* ='geom' is chosen by the user, a simple geometric approximation is used (weighted average of the triangle normal vectors), which could improve speed on very large grids."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Warnings": {
      "children": [],
      "title": null
    }
  },
  "refs": [],
  "ordered_sections": [
    "Summary",
    "Extended Summary",
    "Parameters",
    "Methods",
    "Notes",
    "References"
  ],
  "item_file": "/Users/bussonniermatthias/miniconda3/lib/python3.8/site-packages/matplotlib/tri/triinterpolate.py",
  "item_line": 287,
  "item_type": "<class 'type'>",
  "aliases": [
    "matplotlib.tri.CubicTriInterpolator"
  ],
  "example_section_data": {
    "children": [],
    "title": null
  },
  "see_also": [],
  "signature": "CubicTriInterpolator(triangulation, z, kind='min_E', trifinder=None, dz=None)",
  "references": [
    ".. [1] Michel Bernadou, Kamal Hassan, \"Basis functions for general",
    "    Hsieh-Clough-Tocher triangles, complete or reduced.\",",
    "    International Journal for Numerical Methods in Engineering,",
    "    17(5):784 - 789. 2.01.",
    ".. [2] C.T. Kelley, \"Iterative Methods for Optimization\"."
  ],
  "arbitrary": []
}