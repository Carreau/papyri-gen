{
  "aliases": [
    "matplotlib.tri.CubicTriInterpolator"
  ],
  "arbitrary": [],
  "content": {
    "Attributes": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Extended Summary": {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "In one-dimension - on a segment - a cubic interpolating function is defined by the values of the function and its derivative at both ends. This is almost the same in 2D inside a triangle, except that the values of the function and its 2 derivatives have to be defined at each triangle node."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The CubicTriInterpolator takes the value of the function at each node - provided by the user - and internally computes the value of the derivatives, resulting in a smooth interpolation. (As a special feature, the user can also impose the value of the derivatives at each node, but this is not supposed to be the common usage.)"
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Methods": {
      "children": [
        {
          "children": [
            {
              "desc": [],
              "param": "`__call__` (x, y)",
              "type": "Param",
              "type_": "Returns interpolated values at (x, y) points."
            },
            {
              "desc": [],
              "param": "`gradient` (x, y)",
              "type": "Param",
              "type_": "Returns interpolated derivatives at (x, y) points."
            }
          ],
          "type": "Parameters"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Notes": {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "This note is a bit technical and details how the cubic interpolation is computed."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The interpolation is based on a Clough-Tocher subdivision scheme of the "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "triangulation"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " mesh (to make it clearer, each triangle of the grid will be divided in 3 child-triangles, and on each child triangle the interpolated function is a cubic polynomial of the 2 coordinates). This technique originates from FEM (Finite Element Method) analysis; the element used is a reduced Hsieh-Clough-Tocher (HCT) element. Its shape functions are described in . The assembled function is guaranteed to be C1-smooth, i.e. it is continuous and its first derivatives are also continuous (this is easy to show inside the triangles but is also true when crossing the edges)."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In the default case ("
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "kind"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " ='min_E'), the interpolant minimizes a curvature energy on the functional space generated by the HCT element shape functions - with imposed values but arbitrary derivatives at each node. The minimized functional is the integral of the so-called total curvature (implementation based on an algorithm from  - PCG sparse solver):"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "math",
              "value": "E(z) = \\frac{1}{2} \\int_{\\Omega} \\left(\n        \\left( \\frac{\\partial^2{z}}{\\partial{x}^2} \\right)^2 +\n        \\left( \\frac{\\partial^2{z}}{\\partial{y}^2} \\right)^2 +\n        2\\left( \\frac{\\partial^2{z}}{\\partial{y}\\partial{x}} \\right)^2\n    \\right) dx\\,dy"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "If the case "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "kind"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " ='geom' is chosen by the user, a simple geometric approximation is used (weighted average of the triangle normal vectors), which could improve speed on very large grids."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Other Parameters": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Parameters": {
      "children": [
        {
          "children": [
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The triangulation to interpolate over."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "triangulation",
              "type": "Param",
              "type_": "`~matplotlib.tri.Triangulation`"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Array of values, defined at grid points, to interpolate between."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "z",
              "type": "Param",
              "type_": "(npoints,) array-like"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Choice of the smoothing algorithm, in order to compute the interpolant derivatives (defaults to 'min_E'):"
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "children": [
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "text",
                              "value": "if 'min_E': (default) The derivatives at each node is computed   to minimize a bending energy."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "text",
                              "value": "if 'geom': The derivatives at each node is computed as a   weighted average of relevant triangle normals. To be used for   speed optimization (large grids)."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "text",
                              "value": "if 'user': The user provides the argument "
                            },
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "dz"
                                }
                              ],
                              "type": "emphasis"
                            },
                            {
                              "type": "text",
                              "value": ", no computation   is hence needed."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    }
                  ],
                  "ordered": false,
                  "spread": false,
                  "start": 1,
                  "type": "list"
                }
              ],
              "param": "kind",
              "type": "Param",
              "type_": "{'min_E', 'geom', 'user'}, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "If not specified, the Triangulation's default TriFinder will be used by calling "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": ".Triangulation.get_trifinder"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "trifinder",
              "type": "Param",
              "type_": "`~matplotlib.tri.TriFinder`, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Used only if  "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "kind"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " ='user'. In this case "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "dz"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " must be provided as (dzdx, dzdy) where dzdx, dzdy are arrays of the same shape as "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "z"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " and are the interpolant first derivatives at the "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "triangulation"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " points."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "dz",
              "type": "Param",
              "type_": "tuple of array-likes (dzdx, dzdy), optional"
            }
          ],
          "type": "Parameters"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Raises": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Receives": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Returns": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Summary": {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Cubic interpolator on a triangular grid."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Warnings": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Warns": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Yields": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    }
  },
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null,
    "type": "Section"
  },
  "item_file": "/matplotlib/tri/triinterpolate.py",
  "item_line": 286,
  "item_type": "<class 'type'>",
  "ordered_sections": [
    "Summary",
    "Extended Summary",
    "Parameters",
    "Methods",
    "Notes",
    "References"
  ],
  "references": null,
  "see_also": [],
  "signature": {
    "type": "Signature",
    "value": null
  },
  "type": "DocBlob"
}