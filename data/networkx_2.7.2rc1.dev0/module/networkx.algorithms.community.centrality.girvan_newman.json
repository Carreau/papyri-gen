{
  "_content": {
    "Attributes": {
      "children": [],
      "title": null
    },
    "Extended Summary": {
      "children": [],
      "title": null
    },
    "Methods": {
      "children": [],
      "title": null
    },
    "Notes": {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The Girvan\u2013Newman algorithm detects communities by progressively removing edges from the original graph. The algorithm removes the \"most valuable\" edge, traditionally the edge with the highest betweenness centrality, at each step. As the graph breaks down into pieces, the tightly knit community structure is exposed and the result can be depicted as a dendrogram."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "title": null
    },
    "Parameters": {
      "children": [
        {
          "data": {
            "children": [
              {
                "desc": [],
                "param": "G",
                "type_": "NetworkX graph"
              },
              {
                "desc": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "Function that takes a graph as input and outputs an edge. The edge returned by this function will be recomputed and removed at each iteration of the algorithm."
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  },
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "If not specified, the edge with the highest "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": [
                              "networkx.edge_betweenness_centrality"
                            ]
                          },
                          "type": "Verbatim"
                        },
                        {
                          "data": {
                            "value": " will be used."
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ],
                "param": "most_valuable_edge",
                "type_": "function"
              }
            ]
          },
          "type": "Parameters"
        }
      ],
      "title": null
    },
    "Raises": {
      "children": [],
      "title": null
    },
    "Receives": {
      "children": [],
      "title": null
    },
    "Returns": {
      "children": [
        {
          "data": {
            "children": [
              {
                "desc": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "Iterator over tuples of sets of nodes in "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "exists": true,
                            "kind": "local",
                            "reference": {
                              "kind": "local",
                              "module": null,
                              "path": "G",
                              "version": null
                            },
                            "value": "G"
                          },
                          "type": "Link"
                        },
                        {
                          "data": {
                            "value": ". Each set of node is a community, each tuple is a sequence of communities at a particular level of the algorithm."
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ],
                "param": "",
                "type_": "iterator"
              }
            ]
          },
          "type": "Parameters"
        }
      ],
      "title": null
    },
    "Summary": {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Finds communities in a graph using the Girvan\u2013Newman method."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "title": null
    },
    "Warnings": {
      "children": [],
      "title": null
    },
    "Warns": {
      "children": [],
      "title": null
    },
    "Yields": {
      "children": [],
      "title": null
    }
  },
  "aliases": [
    "networkx.community.girvan_newman"
  ],
  "arbitrary": [],
  "example_section_data": {
    "children": [
      {
        "data": {
          "children": [
            {
              "data": {
                "value": ">>> G = nx.path_graph(10)\n>>> comp = girvan_newman(G)\n>>> tuple(sorted(c) for c in next(comp))\n([0, 1, 2, 3, 4], [5, 6, 7, 8, 9])"
              },
              "type": "BlockVerbatim"
            }
          ]
        },
        "type": "BlockQuote"
      },
      {
        "data": {
          "children": [
            {
              "data": {
                "value": ">>> import itertools\n>>> G = nx.path_graph(8)\n>>> k = 2\n>>> comp = girvan_newman(G)\n>>> for communities in itertools.islice(comp, k):\n...     print(tuple(sorted(c) for c in communities))\n...\n([0, 1, 2, 3], [4, 5, 6, 7])\n([0, 1], [2, 3], [4, 5, 6, 7])"
              },
              "type": "BlockVerbatim"
            }
          ]
        },
        "type": "BlockQuote"
      },
      {
        "data": {
          "children": [
            {
              "data": {
                "value": ">>> import itertools\n>>> G = nx.path_graph(8)\n>>> k = 4\n>>> comp = girvan_newman(G)\n>>> limited = itertools.takewhile(lambda c: len(c) <= k, comp)\n>>> for communities in limited:\n...     print(tuple(sorted(c) for c in communities))\n...\n([0, 1, 2, 3], [4, 5, 6, 7])\n([0, 1], [2, 3], [4, 5, 6, 7])\n([0, 1], [2, 3], [4, 5], [6, 7])"
              },
              "type": "BlockVerbatim"
            }
          ]
        },
        "type": "BlockQuote"
      },
      {
        "data": {
          "children": [
            {
              "data": {
                "value": ">>> from operator import itemgetter\n>>> G = nx.path_graph(10)\n>>> edges = G.edges()\n>>> nx.set_edge_attributes(G, {(u, v): v for u, v in edges}, \"weight\")\n>>> def heaviest(G):\n...     u, v, w = max(G.edges(data=\"weight\"), key=itemgetter(2))\n...     return (u, v)\n...\n>>> comp = girvan_newman(G, most_valuable_edge=heaviest)\n>>> tuple(sorted(c) for c in next(comp))\n([0, 1, 2, 3, 4, 5, 6, 7, 8], [9])"
              },
              "type": "BlockVerbatim"
            }
          ]
        },
        "type": "BlockQuote"
      },
      {
        "data": {
          "children": [
            {
              "data": {
                "value": ">>> from networkx import edge_betweenness_centrality as betweenness\n>>> def most_central_edge(G):\n...     centrality = betweenness(G, weight=\"weight\")\n...     return max(centrality, key=centrality.get)\n...\n>>> G = nx.path_graph(10)\n>>> comp = girvan_newman(G, most_valuable_edge=most_central_edge)\n>>> tuple(sorted(c) for c in next(comp))\n([0, 1, 2, 3, 4], [5, 6, 7, 8, 9])"
              },
              "type": "BlockVerbatim"
            }
          ]
        },
        "type": "BlockQuote"
      },
      {
        "data": {
          "children": [
            {
              "data": {
                "value": ">>> from networkx import edge_betweenness_centrality\n>>> from random import random\n>>> def most_central_edge(G):\n...     centrality = edge_betweenness_centrality(G)\n...     max_cent = max(centrality.values())\n...     # Scale the centrality values so they are between 0 and 1,\n...     # and add some random noise.\n...     centrality = {e: c / max_cent for e, c in centrality.items()}\n...     # Add some random noise.\n...     centrality = {e: c + random() for e, c in centrality.items()}\n...     return max(centrality, key=centrality.get)\n...\n>>> G = nx.path_graph(10)\n>>> comp = girvan_newman(G, most_valuable_edge=most_central_edge)"
              },
              "type": "BlockVerbatim"
            }
          ]
        },
        "type": "BlockQuote"
      }
    ],
    "title": null
  },
  "item_file": "networkx/algorithms/community/centrality.py",
  "item_line": 8,
  "item_type": "<class 'function'>",
  "ordered_sections": [
    "Summary",
    "Parameters",
    "Returns",
    "Examples",
    "Notes"
  ],
  "references": null,
  "see_also": [],
  "signature": {
    "value": "girvan_newman(G, most_valuable_edge=None)"
  }
}