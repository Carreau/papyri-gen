{
  "aliases": [
    "networkx.all_simple_paths"
  ],
  "arbitrary": [],
  "content": {
    "Attributes": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Extended Summary": {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "A simple path is a path with no repeated nodes."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Methods": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Notes": {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "This algorithm uses a modified depth-first search to generate the paths .  A single path can be found in $O(V+E)$ time but the number of simple paths in a graph can be very large, e.g. $O(n!)$ in the complete graph of order $n$."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This function does not check that a path exists between "
            },
            {
              "anchor": null,
              "exists": true,
              "kind": "local",
              "reference": {
                "kind": "local",
                "module": null,
                "path": "source",
                "type": "RefInfo",
                "version": null
              },
              "type": "Link",
              "value": "source"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "anchor": null,
              "exists": true,
              "kind": "local",
              "reference": {
                "kind": "local",
                "module": null,
                "path": "target",
                "type": "RefInfo",
                "version": null
              },
              "type": "Link",
              "value": "target"
            },
            {
              "type": "text",
              "value": ". For large graphs, this may result in very long runtimes. Consider using "
            },
            {
              "anchor": null,
              "exists": true,
              "kind": "module",
              "reference": {
                "kind": "module",
                "module": "networkx",
                "path": "networkx.algorithms.shortest_paths.generic:has_path",
                "type": "RefInfo",
                "version": "3.1"
              },
              "type": "Link",
              "value": "has_path"
            },
            {
              "type": "text",
              "value": " to check that a path exists between "
            },
            {
              "anchor": null,
              "exists": true,
              "kind": "local",
              "reference": {
                "kind": "local",
                "module": null,
                "path": "source",
                "type": "RefInfo",
                "version": null
              },
              "type": "Link",
              "value": "source"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "anchor": null,
              "exists": true,
              "kind": "local",
              "reference": {
                "kind": "local",
                "module": null,
                "path": "target",
                "type": "RefInfo",
                "version": null
              },
              "type": "Link",
              "value": "target"
            },
            {
              "type": "text",
              "value": " before calling this function on large graphs."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Other Parameters": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Parameters": {
      "children": [
        {
          "children": [
            {
              "desc": [],
              "param": "G",
              "type": "Param",
              "type_": "NetworkX graph"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Starting node for path"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "source",
              "type": "Param",
              "type_": "node"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Single node or iterable of nodes at which to end path"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "target",
              "type": "Param",
              "type_": "nodes"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Depth to stop the search. Only paths of length <= cutoff are returned."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "cutoff",
              "type": "Param",
              "type_": "integer, optional"
            }
          ],
          "type": "Parameters"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Raises": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Receives": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Returns": {
      "children": [
        {
          "children": [
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "A generator that produces lists of simple paths.  If there are no paths between the source and target within the given cutoff the generator produces no output. If it is possible to traverse the same sequence of nodes in multiple ways, namely through parallel edges, then it will be returned multiple times (once for each viable edge combination)."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "",
              "type": "Param",
              "type_": "path_generator: generator"
            }
          ],
          "type": "Parameters"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Summary": {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Generate all simple paths in the graph G from source to target."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Warnings": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Warns": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Yields": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    }
  },
  "example_section_data": {
    "children": [
      {
        "type": "text",
        "value": "This iterator generates lists of nodes::"
      },
      {
        "type": "text",
        "value": "    >>> G = nx.complete_graph(4)\n    >>> for path in nx.all_simple_paths(G, source=0, target=3):\n    ...     print(path)\n    ...\n    [0, 1, 2, 3]\n    [0, 1, 3]\n    [0, 2, 1, 3]\n    [0, 2, 3]\n    [0, 3]"
      },
      {
        "type": "text",
        "value": "You can generate only those paths that are shorter than a certain\nlength by using the `cutoff` keyword argument::"
      },
      {
        "type": "text",
        "value": "    >>> paths = nx.all_simple_paths(G, source=0, target=3, cutoff=2)\n    >>> print(list(paths))\n    [[0, 1, 3], [0, 2, 3], [0, 3]]"
      },
      {
        "type": "text",
        "value": "To get each path as the corresponding list of edges, you can use the\n:func:`networkx.utils.pairwise` helper function::"
      },
      {
        "type": "text",
        "value": "    >>> paths = nx.all_simple_paths(G, source=0, target=3)\n    >>> for path in map(nx.utils.pairwise, paths):\n    ...     print(list(path))\n    [(0, 1), (1, 2), (2, 3)]\n    [(0, 1), (1, 3)]\n    [(0, 2), (2, 1), (1, 3)]\n    [(0, 2), (2, 3)]\n    [(0, 3)]"
      },
      {
        "type": "text",
        "value": "Pass an iterable of nodes as target to generate all paths ending in any of several nodes::"
      },
      {
        "type": "text",
        "value": "    >>> G = nx.complete_graph(4)\n    >>> for path in nx.all_simple_paths(G, source=0, target=[3, 2]):\n    ...     print(path)\n    ...\n    [0, 1, 2]\n    [0, 1, 2, 3]\n    [0, 1, 3]\n    [0, 1, 3, 2]\n    [0, 2]\n    [0, 2, 1, 3]\n    [0, 2, 3]\n    [0, 3]\n    [0, 3, 1, 2]\n    [0, 3, 2]"
      },
      {
        "type": "text",
        "value": "Iterate over each path from the root nodes to the leaf nodes in a\ndirected acyclic graph using a functional programming approach::"
      },
      {
        "type": "text",
        "value": "    >>> from itertools import chain\n    >>> from itertools import product\n    >>> from itertools import starmap\n    >>> from functools import partial\n    >>>\n    >>> chaini = chain.from_iterable\n    >>>\n    >>> G = nx.DiGraph([(0, 1), (1, 2), (0, 3), (3, 2)])\n    >>> roots = (v for v, d in G.in_degree() if d == 0)\n    >>> leaves = (v for v, d in G.out_degree() if d == 0)\n    >>> all_paths = partial(nx.all_simple_paths, G)\n    >>> list(chaini(starmap(all_paths, product(roots, leaves))))\n    [[0, 1, 2], [0, 3, 2]]"
      },
      {
        "type": "text",
        "value": "The same list computed using an iterative approach::"
      },
      {
        "type": "text",
        "value": "    >>> G = nx.DiGraph([(0, 1), (1, 2), (0, 3), (3, 2)])\n    >>> roots = (v for v, d in G.in_degree() if d == 0)\n    >>> leaves = (v for v, d in G.out_degree() if d == 0)\n    >>> all_paths = []\n    >>> for root in roots:\n    ...     for leaf in leaves:\n    ...         paths = nx.all_simple_paths(G, root, leaf)\n    ...         all_paths.extend(paths)\n    >>> all_paths\n    [[0, 1, 2], [0, 3, 2]]"
      },
      {
        "type": "text",
        "value": "Iterate over each path from the root nodes to the leaf nodes in a\ndirected acyclic graph passing all leaves together to avoid unnecessary\ncompute::"
      },
      {
        "type": "text",
        "value": "    >>> G = nx.DiGraph([(0, 1), (2, 1), (1, 3), (1, 4)])\n    >>> roots = (v for v, d in G.in_degree() if d == 0)\n    >>> leaves = [v for v, d in G.out_degree() if d == 0]\n    >>> all_paths = []\n    >>> for root in roots:\n    ...     paths = nx.all_simple_paths(G, root, leaves)\n    ...     all_paths.extend(paths)\n    >>> all_paths\n    [[0, 1, 3], [0, 1, 4], [2, 1, 3], [2, 1, 4]]"
      },
      {
        "type": "text",
        "value": "If parallel edges offer multiple ways to traverse a given sequence of\nnodes, this sequence of nodes will be returned multiple times:"
      },
      {
        "type": "text",
        "value": "    >>> G = nx.MultiDiGraph([(0, 1), (0, 1), (1, 2)])\n    >>> list(nx.all_simple_paths(G, 0, 2))\n    [[0, 1, 2], [0, 1, 2]]"
      }
    ],
    "level": 0,
    "target": null,
    "title": null,
    "type": "Section"
  },
  "item_file": "/networkx/algorithms/simple_paths.py",
  "item_line": 94,
  "item_type": "<class 'function'>",
  "ordered_sections": [
    "Summary",
    "Extended Summary",
    "Parameters",
    "Returns",
    "Examples",
    "Notes",
    "References",
    "See Also"
  ],
  "references": null,
  "see_also": [
    {
      "descriptions": [],
      "name": {
        "anchor": null,
        "exists": true,
        "kind": "module",
        "reference": {
          "kind": "module",
          "module": "networkx",
          "path": "networkx.algorithms.shortest_paths.generic:all_shortest_paths",
          "type": "RefInfo",
          "version": "3.1"
        },
        "type": "Link",
        "value": "all_shortest_paths"
      },
      "type": null
    },
    {
      "descriptions": [],
      "name": {
        "anchor": null,
        "exists": true,
        "kind": "module",
        "reference": {
          "kind": "to-resolve",
          "module": "current-module",
          "path": "shortest_path",
          "type": "RefInfo",
          "version": "current-version"
        },
        "type": "Link",
        "value": "shortest_path"
      },
      "type": null
    },
    {
      "descriptions": [],
      "name": {
        "anchor": null,
        "exists": true,
        "kind": "module",
        "reference": {
          "kind": "module",
          "module": "networkx",
          "path": "networkx.algorithms.shortest_paths.generic:has_path",
          "type": "RefInfo",
          "version": "3.1"
        },
        "type": "Link",
        "value": "has_path"
      },
      "type": null
    }
  ],
  "signature": {
    "type": "Signature",
    "value": "(G, source, target, cutoff=None)"
  },
  "type": "DocBlob"
}