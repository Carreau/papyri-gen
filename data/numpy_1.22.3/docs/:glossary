{
  "_content": {},
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "data": {
            "argument": "",
            "content": "(`n`,)\n    A parenthesized number followed by a comma denotes a tuple with one\n    element. The trailing comma distinguishes a one-element tuple from a\n    parenthesized ``n``.\n\n\n-1\n    - **In a dimension entry**, instructs NumPy to choose the length\n      that will keep the total number of array elements the same.\n\n        >>> np.arange(12).reshape(4, -1).shape\n        (4, 3)\n\n    - **In an index**, any negative value\n      `denotes <https://docs.python.org/dev/faq/programming.html#what-s-a-negative-index>`_\n      indexing from the right.\n\n. . .\n    An :py:data:`Ellipsis`.\n\n    - **When indexing an array**, shorthand that the missing axes, if they\n      exist, are full slices.\n\n        >>> a = np.arange(24).reshape(2,3,4)\n\n        >>> a[...].shape\n        (2, 3, 4)\n\n        >>> a[...,0].shape\n        (2, 3)\n\n        >>> a[0,...].shape\n        (3, 4)\n\n        >>> a[0,...,0].shape\n        (3,)\n\n      It can be used at most once; ``a[...,0,...]`` raises an :exc:`IndexError`.\n\n    - **In printouts**, NumPy substitutes ``...`` for the middle elements of\n      large arrays. To see the entire array, use `numpy.printoptions`\n\n\n:\n    The Python :term:`python:slice`\n    operator. In ndarrays, slicing can be applied to every\n    axis:\n\n        >>> a = np.arange(24).reshape(2,3,4)\n        >>> a\n        array([[[ 0,  1,  2,  3],\n                [ 4,  5,  6,  7],\n                [ 8,  9, 10, 11]],\n        <BLANKLINE>\n               [[12, 13, 14, 15],\n                [16, 17, 18, 19],\n                [20, 21, 22, 23]]])\n        <BLANKLINE>\n        >>> a[1:,-2:,:-1]\n        array([[[16, 17, 18],\n                [20, 21, 22]]])\n\n    Trailing slices can be omitted: ::\n\n        >>> a[1] == a[1,:,:]\n        array([[ True,  True,  True,  True],\n               [ True,  True,  True,  True],\n               [ True,  True,  True,  True]])\n\n    In contrast to Python, where slicing creates a copy, in NumPy slicing\n    creates a :term:`view`.\n\n    For details, see :ref:`combining-advanced-and-basic-indexing`.\n\n\n<\n    In a dtype declaration, indicates that the data is\n    :term:`little-endian` (the bracket is big on the right). ::\n\n        >>> dt = np.dtype('<f')  # little-endian single-precision float\n\n\n>\n    In a dtype declaration, indicates that the data is\n    :term:`big-endian` (the bracket is big on the left). ::\n\n        >>> dt = np.dtype('>H')  # big-endian unsigned short\n\n\nadvanced indexing\n    Rather than using a :doc:`scalar <reference/arrays.scalars>` or slice as\n    an index, an axis can be indexed with an array, providing fine-grained\n    selection. This is known as :ref:`advanced indexing<advanced-indexing>`\n    or \"fancy indexing\".\n\n\nalong an axis\n    An operation `along axis n` of array ``a`` behaves as if its argument\n    were an array of slices of ``a`` where each slice has a successive\n    index of axis `n`.\n\n    For example, if ``a`` is a 3 x `N` array, an operation along axis 0\n    behaves as if its argument were an array containing slices of each row:\n\n        >>> np.array((a[0,:], a[1,:], a[2,:])) #doctest: +SKIP\n\n    To make it concrete, we can pick the operation to be the array-reversal\n    function :func:`numpy.flip`, which accepts an ``axis`` argument. We\n    construct a 3 x 4 array ``a``:\n\n        >>> a = np.arange(12).reshape(3,4)\n        >>> a\n        array([[ 0,  1,  2,  3],\n               [ 4,  5,  6,  7],\n               [ 8,  9, 10, 11]])\n\n    Reversing along axis 0 (the row axis) yields\n\n        >>> np.flip(a,axis=0)\n        array([[ 8,  9, 10, 11],\n               [ 4,  5,  6,  7],\n               [ 0,  1,  2,  3]])\n\n    Recalling the definition of `along an axis`,  ``flip`` along axis 0 is\n    treating its argument as if it were\n\n        >>> np.array((a[0,:], a[1,:], a[2,:]))\n        array([[ 0,  1,  2,  3],\n               [ 4,  5,  6,  7],\n               [ 8,  9, 10, 11]])\n\n    and the result of ``np.flip(a,axis=0)`` is to reverse the slices:\n\n        >>> np.array((a[2,:],a[1,:],a[0,:]))\n        array([[ 8,  9, 10, 11],\n               [ 4,  5,  6,  7],\n               [ 0,  1,  2,  3]])\n\n\narray\n    Used synonymously in the NumPy docs with :term:`ndarray`.\n\n\narray_like\n    Any :doc:`scalar <reference/arrays.scalars>` or\n    :term:`python:sequence`\n    that can be interpreted as an ndarray.  In addition to ndarrays\n    and scalars this category includes lists (possibly nested and with\n    different element types) and tuples. Any argument accepted by\n    :doc:`numpy.array <reference/generated/numpy.array>`\n    is array_like. ::\n\n        >>> a = np.array([[1, 2.0], [0, 0], (1+1j, 3.)])\n\n        >>> a\n        array([[1.+0.j, 2.+0.j],\n               [0.+0.j, 0.+0.j],\n               [1.+1.j, 3.+0.j]])\n\n\narray scalar\n    An :doc:`array scalar <reference/arrays.scalars>` is an instance of the types/classes float32, float64, \n    etc.. For uniformity in handling operands, NumPy treats a scalar as \n    an array of zero dimension. In contrast, a 0-dimensional array is an :doc:`ndarray <reference/arrays.ndarray>` instance \n    containing precisely one value. \n\n\naxis\n    Another term for an array dimension. Axes are numbered left to right;\n    axis 0 is the first element in the shape tuple.\n\n    In a two-dimensional vector, the elements of axis 0 are rows and the\n    elements of axis 1 are columns.\n\n    In higher dimensions, the picture changes. NumPy prints\n    higher-dimensional vectors as replications of row-by-column building\n    blocks, as in this three-dimensional vector:\n\n        >>> a = np.arange(12).reshape(2,2,3)\n        >>> a\n        array([[[ 0,  1,  2],\n                [ 3,  4,  5]],\n               [[ 6,  7,  8],\n                [ 9, 10, 11]]])\n\n    ``a`` is depicted as a two-element array whose elements are 2x3 vectors.\n    From this point of view, rows and columns are the final two axes,\n    respectively, in any shape.\n\n    This rule helps you anticipate how a vector will be printed, and\n    conversely how to find the index of any of the printed elements. For\n    instance, in the example, the last two values of 8's index must be 0 and\n    2. Since 8 appears in the second of the two 2x3's, the first index must\n    be 1:\n\n        >>> a[1,0,2]\n        8\n\n    A convenient way to count dimensions in a printed vector is to\n    count ``[`` symbols after the open-parenthesis. This is\n    useful in distinguishing, say, a (1,2,3) shape from a (2,3) shape:\n\n        >>> a = np.arange(6).reshape(2,3)\n        >>> a.ndim\n        2\n        >>> a\n        array([[0, 1, 2],\n               [3, 4, 5]])\n\n        >>> a = np.arange(6).reshape(1,2,3)\n        >>> a.ndim\n        3\n        >>> a\n        array([[[0, 1, 2],\n                [3, 4, 5]]])\n\n\n.base\n\n    If an array does not own its memory, then its\n    :doc:`base <reference/generated/numpy.ndarray.base>` attribute returns\n    the object whose memory the array is referencing. That object may be\n    referencing the memory from still another object, so the owning object\n    may be ``a.base.base.base...``. Some writers erroneously claim that\n    testing ``base`` determines if arrays are :term:`view`\\ s. For the\n    correct way, see :func:`numpy.shares_memory`.\n\n\nbig-endian\n    See `Endianness <https://en.wikipedia.org/wiki/Endianness>`_.\n\n\nBLAS\n    `Basic Linear Algebra Subprograms <https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms>`_\n\n\nbroadcast\n    *broadcasting* is NumPy's ability to process ndarrays of\n    different sizes as if all were the same size.\n\n    It permits an elegant do-what-I-mean behavior where, for instance,\n    adding a scalar to a vector adds the scalar value to every element.\n\n        >>> a = np.arange(3)\n        >>> a\n        array([0, 1, 2])\n\n        >>> a + [3, 3, 3]\n        array([3, 4, 5])\n\n        >>> a + 3\n        array([3, 4, 5])\n\n    Ordinarly, vector operands must all be the same size, because NumPy\n    works element by element -- for instance, ``c = a * b`` is ::\n\n        c[0,0,0] = a[0,0,0] * b[0,0,0]\n        c[0,0,1] = a[0,0,1] * b[0,0,1]\n       ...\n\n    But in certain useful cases, NumPy can duplicate data along \"missing\"\n    axes or \"too-short\" dimensions so shapes will match. The duplication\n    costs no memory or time. For details, see\n    :doc:`Broadcasting. <user/basics.broadcasting>`\n\n\nC order\n    Same as :term:`row-major`.\n\n\ncolumn-major\n    See `Row- and column-major order <https://en.wikipedia.org/wiki/Row-_and_column-major_order>`_.\n\n\ncontiguous\n\n    An array is contiguous if:\n\n    - it occupies an unbroken block of memory, and\n    - array elements with higher indexes occupy higher addresses (that\n      is, no :term:`stride` is negative).\n\n    There are two types of proper-contiguous NumPy arrays:\n\n    - Fortran-contiguous arrays refer to data that is stored column-wise,\n      i.e. the indexing of data as stored in memory starts from the\n      lowest dimension;\n    - C-contiguous, or simply contiguous arrays, refer to data that is\n      stored row-wise, i.e. the indexing of data as stored in memory\n      starts from the highest dimension.\n\n    For one-dimensional arrays these notions coincide. \n\n    For example, a 2x2 array ``A`` is Fortran-contiguous if its elements are\n    stored in memory in the following order::\n\n        A[0,0] A[1,0] A[0,1] A[1,1]\n\n    and C-contiguous if the order is as follows::\n\n        A[0,0] A[0,1] A[1,0] A[1,1]\n\n    To test whether an array is C-contiguous, use the ``.flags.c_contiguous``\n    attribute of NumPy arrays.  To test for Fortran contiguity, use the\n    ``.flags.f_contiguous`` attribute.\n\n\ncopy\n    See :term:`view`.\n\n\ndimension\n    See :term:`axis`.\n\n\ndtype\n    The datatype describing the (identically typed) elements in an ndarray.\n    It can be changed to reinterpret the array contents. For details, see\n    :doc:`Data type objects (dtype). <reference/arrays.dtypes>`\n\n\nfancy indexing\n    Another term for :term:`advanced indexing`.\n\n\nfield\n    In a :term:`structured data type`, each subtype is called a `field`.\n    The `field` has a name (a string), a type (any valid dtype), and\n    an optional `title`. See :ref:`arrays.dtypes`.\n\n\nFortran order\n    Same as :term:`column-major`.\n\n\nflattened\n    See :term:`ravel`.\n\n\nhomogeneous\n    All elements of a homogeneous array have the same type. ndarrays, in\n    contrast to Python lists, are homogeneous. The type can be complicated,\n    as in a :term:`structured array`, but all elements have that type.\n\n    NumPy `object arrays <#term-object-array>`_, which contain references to\n    Python objects, fill the role of heterogeneous arrays.\n\n\nitemsize\n    The size of the dtype element in bytes.\n\n\nlittle-endian\n    See `Endianness <https://en.wikipedia.org/wiki/Endianness>`_.\n\n\nmask\n    A boolean array used to select only certain elements for an operation:\n\n        >>> x = np.arange(5)\n        >>> x\n        array([0, 1, 2, 3, 4])\n\n        >>> mask = (x > 2)\n        >>> mask\n        array([False, False, False, True,  True])\n\n        >>> x[mask] = -1\n        >>> x\n        array([ 0,  1,  2,  -1, -1])\n\n\nmasked array\n    Bad or missing data can be cleanly ignored by putting it in a masked\n    array, which has an internal boolean array indicating invalid\n    entries. Operations with masked arrays ignore these entries. ::\n\n      >>> a = np.ma.masked_array([np.nan, 2, np.nan], [True, False, True])\n      >>> a\n      masked_array(data=[--, 2.0, --],\n                   mask=[ True, False,  True],\n             fill_value=1e+20)\n\n      >>> a + [1, 2, 3]\n      masked_array(data=[--, 4.0, --],\n                   mask=[ True, False,  True],\n             fill_value=1e+20)\n\n    For details, see :doc:`Masked arrays. <reference/maskedarray>`\n\n\nmatrix\n    NumPy's two-dimensional\n    :doc:`matrix class <reference/generated/numpy.matrix>`\n    should no longer be used; use regular ndarrays.\n\n\nndarray\n   :doc:`NumPy's basic structure <reference/arrays>`.\n\n\nobject array\n    An array whose dtype is ``object``; that is, it contains references to\n    Python objects. Indexing the array dereferences the Python objects, so\n    unlike other ndarrays, an object array has the ability to hold\n    heterogeneous objects.\n\n\nravel\n    :doc:`numpy.ravel \\\n    <reference/generated/numpy.ravel>`\n    and :doc:`numpy.flatten \\\n    <reference/generated/numpy.ndarray.flatten>`\n    both flatten an ndarray. ``ravel`` will return a view if possible;\n    ``flatten`` always returns a copy.\n\n    Flattening collapses a multimdimensional array to a single dimension;\n    details of how this is done (for instance, whether ``a[n+1]`` should be\n    the next row or next column) are parameters.\n\n\nrecord array\n    A :term:`structured array` with allowing access in an attribute style\n    (``a.field``) in addition to ``a['field']``. For details, see\n    :doc:`numpy.recarray. <reference/generated/numpy.recarray>`\n\n\nrow-major\n    See `Row- and column-major order <https://en.wikipedia.org/wiki/Row-_and_column-major_order>`_.\n    NumPy creates arrays in row-major order by default.\n\n\nscalar\n    In NumPy, usually a synonym for :term:`array scalar`.\n\n\nshape\n    A tuple showing the length of each dimension of an ndarray. The\n    length of the tuple itself is the number of dimensions\n    (:doc:`numpy.ndim <reference/generated/numpy.ndarray.ndim>`).\n    The product of the tuple elements is the number of elements in the\n    array. For details, see\n    :doc:`numpy.ndarray.shape <reference/generated/numpy.ndarray.shape>`.\n\n\nstride\n    Physical memory is one-dimensional;  strides provide a mechanism to map\n    a given index to an address in memory. For an N-dimensional array, its\n    ``strides`` attribute is an N-element tuple; advancing from index\n    ``i`` to index ``i+1`` on axis ``n`` means adding ``a.strides[n]`` bytes\n    to the address.\n\n    Strides are computed automatically from an array's dtype and\n    shape, but can be directly specified using\n    :doc:`as_strided. <reference/generated/numpy.lib.stride_tricks.as_strided>`\n\n    For details, see\n    :doc:`numpy.ndarray.strides <reference/generated/numpy.ndarray.strides>`.\n\n    To see how striding underlies the power of NumPy views, see\n    `The NumPy array: a structure for efficient numerical computation. \\\n    <https://arxiv.org/pdf/1102.1523.pdf>`_\n\n\nstructured array\n    Array whose :term:`dtype` is a :term:`structured data type`.\n\n\nstructured data type\n    Users can create arbitrarily complex :term:`dtypes <dtype>`\n    that can include other arrays and dtypes. These composite dtypes are called\n    :doc:`structured data types. <user/basics.rec>`\n\n\nsubarray\n   An array nested in a :term:`structured data type`, as ``b`` is here:\n\n     >>> dt = np.dtype([('a', np.int32), ('b', np.float32, (3,))])\n     >>> np.zeros(3, dtype=dt)\n     array([(0, [0., 0., 0.]), (0, [0., 0., 0.]), (0, [0., 0., 0.])],\n           dtype=[('a', '<i4'), ('b', '<f4', (3,))])\n\n\nsubarray data type\n    An element of a structured datatype that behaves like an ndarray.\n\n\ntitle\n    An alias for a field name in a structured datatype.\n\n\ntype\n    In NumPy, usually a synonym for :term:`dtype`. For the more general\n    Python meaning, :term:`see here. <python:type>`\n\n\nufunc\n    NumPy's fast element-by-element computation (:term:`vectorization`)\n    gives a choice which function gets applied. The general term for the\n    function is ``ufunc``, short for ``universal function``. NumPy routines\n    have built-in ufuncs, but users can also\n    :doc:`write their own. <reference/ufuncs>`\n\n\nvectorization\n    NumPy hands off array processing to C, where looping and computation are\n    much faster than in Python. To exploit this, programmers using NumPy\n    eliminate Python loops in favor of array-to-array operations.\n    :term:`vectorization` can refer both to the C offloading and to\n    structuring NumPy code to leverage it.\n\nview\n    Without touching underlying data, NumPy can make one array appear\n    to change its datatype and shape.\n\n    An array created this way is a `view`, and NumPy often exploits the\n    performance gain of using a view versus making a new array.\n\n    A potential drawback is that writing to a view can alter the original\n    as well. If this is a problem, NumPy instead needs to create a\n    physically distinct array -- a `copy`.\n\n    Some NumPy routines always return views, some always return copies, some\n    may return one or the other, and for some the choice can be specified.\n    Responsibility for managing views and copies falls to the programmer.\n    :func:`numpy.shares_memory` will check whether ``b`` is a view of\n    ``a``, but an exact answer isn't always feasible, as the documentation\n    page explains.\n\n      >>> x = np.arange(5)\n      >>> x\n      array([0, 1, 2, 3, 4])\n\n      >>> y = x[::2]\n      >>> y\n      array([0, 2, 4])\n\n      >>> x[0] = 3 # changing x changes y as well, since y is a view on x\n      >>> y\n      array([3, 2, 4])",
            "name": "glossary",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Glossary"
    }
  ],
  "example_section_data": {
    "children": [],
    "title": null
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "refs": [],
  "see_also": [],
  "signature": {
    "value": null
  }
}