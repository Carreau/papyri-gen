{
  "_content": {},
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "data": {
            "placeholder": "target",
            "value": ".. _f2py-examples:"
          },
          "type": "Unimplemented"
        }
      ],
      "title": null
    },
    {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Below are some examples of F2PY usage. This list is not comprehensive, but can be used as a starting point when wrapping your own code."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        }
      ],
      "title": "F2PY examples"
    },
    {
      "children": [],
      "title": "F2PY walkthrough: a basic extension module"
    },
    {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Consider the following subroutine, contained in a file named "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "add.f"
                  ]
                },
                "type": "Verbatim"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "./code/add.f"
            ],
            "directive_name": "literalinclude",
            "inner": {
              "inline": [],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "This routine simply adds the elements in two contiguous arrays and places the result in a third. The memory for all three arrays must be provided by the calling routine. A very basic interface to this routine can be automatically generated by f2py::      "
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": "python -m numpy.f2py -m add add.f"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "This command will produce an extension module named "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "addmodule.c"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " in the current directory. This extension module can now be compiled and used from Python just like any other extension module."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        }
      ],
      "title": "Creating source for a basic extension module"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "inline": [
                  {
                    "data": {
                      "value": "This usage depends heavily on ``numpy.distutils``, see : ref : `f2py - bldsys` for more details. "
                    },
                    "type": "Words"
                  }
                ],
                "inner": []
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "You can also get f2py to both compile "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "add.f"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " along with the produced extension module leaving only a shared-library extension file that can be imported from Python::      "
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": "python -m numpy.f2py -c -m add add.f"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "This command produces a Python extension module compatible with your platform. This module may then be imported from Python. It will contain a method for each subroutine in "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "add"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ". The docstring of each method contains information about how the module method may be called:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "python"
            ],
            "directive_name": "code-block",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": ">>> import add >>> print ( add.zadd.__doc__) zadd ( a,b,c,n) Wrapper for ``zadd``. Parameters - - - - - - - - - - a : input rank - 1 array ( ' D ' ) with bounds ( *) b : input rank - 1 array ( ' D ' ) with bounds ( *) c : input rank - 1 array ( ' D ' ) with bounds ( *) n : input int "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Creating a compiled extension module"
    },
    {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "The default interface is a very literal translation of the Fortran code into Python. The Fortran array arguments are converted to NumPy arrays and the integer argument should be mapped to a "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "C"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " integer. The interface will attempt to convert all arguments to their required types (and shapes) and issue an error if unsuccessful. However, because "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "f2py"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " knows nothing about the semantics of the arguments (such that "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "C"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is an output and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "n"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " should really match the array sizes), it is possible to abuse this function in ways that can cause Python to crash. For example:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "python"
            ],
            "directive_name": "code-block",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": ">>> add.zadd ( [ 1, 2, 3], [ 1, 2], [ 3, 4], 1000) "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "will cause a program crash on most systems. Under the hood, the lists are being converted to arrays but then the underlying "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "add"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " function is told to cycle way beyond the borders of the allocated memory."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "In order to improve the interface, "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "f2py"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " supports directives. This is accomplished by constructing a signature file. It is usually best to start from the interfaces that "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "f2py"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " produces in that file, which correspond to the default behavior. To get "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "f2py"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " to generate the interface file use the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "-h"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " option::      "
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": "python -m numpy.f2py -h add.pyf -m add add.f"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "This command creates the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "add.pyf"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " file in the current directory. The section of this file corresponding to "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "zadd"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "./code/add.pyf"
            ],
            "directive_name": "literalinclude",
            "inner": {
              "inline": [],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "By placing intent directives and checking code, the interface can be cleaned up quite a bit so the Python module method is both easier to use and more robust to malformed inputs."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "./code/add-edited.pyf"
            ],
            "directive_name": "literalinclude",
            "inner": {
              "inline": [],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "The intent directive, intent(out) is used to tell f2py that "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "c"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is an output variable and should be created by the interface before being passed to the underlying code. The intent(hide) directive tells f2py to not allow the user to specify the variable, "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "n"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", but instead to get it from the size of "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "a"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ". The depend( "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "a"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ) directive is necessary to tell f2py that the value of n depends on the input a (so that it won't try to create the variable n until the variable a is created)."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "After modifying "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "add.pyf"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", the new Python module file can be generated by compiling both "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "add.f"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "add.pyf"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "      "
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": "python -m numpy.f2py -c add.pyf add.f"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "The new interface's docstring is:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "python"
            ],
            "directive_name": "code-block",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": ">>> import add >>> print ( add.zadd.__doc__) c = zadd ( a,b) Wrapper for ``zadd``. Parameters - - - - - - - - - - a : input rank - 1 array ( ' D ' ) with bounds ( n) b : input rank - 1 array ( ' D ' ) with bounds ( n) Returns - - - - - - - c : rank - 1 array ( ' D ' ) with bounds ( n) "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Now, the function can be called in a much more robust way:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [],
            "directive_name": "code-block",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": ">>> add.zadd ( [ 1, 2, 3], [ 4, 5, 6]) array ( [ 5.+0.j, 7.+0.j, 9.+0.j]) "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Notice the automatic conversion to the correct format that occurred."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        }
      ],
      "title": "Improving the basic interface"
    },
    {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "The robust interface of the previous section can also be generated automatically by placing the variable directives as special comments in the original Fortran code."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "inline": [
                  {
                    "data": {
                      "value": "For projects where the Fortran code is being actively developed, this may be preferred. "
                    },
                    "type": "Words"
                  }
                ],
                "inner": []
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Thus, if the source code is modified to contain:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "./code/add-improved.f"
            ],
            "directive_name": "literalinclude",
            "inner": {
              "inline": [],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Then, one can compile the extension module using::      "
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": "python -m numpy.f2py -c -m add add.f"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "The resulting signature for the function add.zadd is exactly the same one that was created previously. If the original source code had contained "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "A(N)"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " instead of "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "A(*)"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " and so forth with "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "B"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "C"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", then nearly the same interface can be obtained by placing the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "INTENT(OUT) :: C"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " comment line in the source code. The only difference is that "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "N"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " would be an optional input that would default to the length of "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "A"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        }
      ],
      "title": "Inserting directives in Fortran source"
    },
    {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "This example shows a function that filters a two-dimensional array of double precision floating-point numbers using a fixed averaging filter. The advantage of using Fortran to index into multi-dimensional arrays should be clear from this example."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "./code/filter.f"
            ],
            "directive_name": "literalinclude",
            "inner": {
              "inline": [],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "This code can be compiled and linked into an extension module named filter using::      "
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": "python -m numpy.f2py -c -m filter filter.f"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "This will produce an extension module in the current directory with a method named "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "dfilter2d"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " that returns a filtered version of the input."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        }
      ],
      "title": "A filtering example"
    },
    {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Consider the following code, saved in the file "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "myroutine.f90"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ":"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "./code/myroutine.f90"
            ],
            "directive_name": "literalinclude",
            "inner": {
              "inline": [],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Wrapping this with "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "python -m numpy.f2py -c myroutine.f90 -m myroutine"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", we can do the following in Python::   "
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> import numpy as np\n>>> import myroutine\n>>> x = myroutine.s(2, 3, np.array([5, 6, 7]))\n>>> x\narray([[5., 0., 0.],\n          [0., 0., 0.]])"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Now, instead of generating the extension module directly, we will create a signature file for this subroutine first. This is a common pattern for multi-step extension module generation. In this case, after running"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "python"
            ],
            "directive_name": "code-block",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "python - m numpy.f2py myroutine.f90 - h myroutine.pyf "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "the following signature file is generated:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "./code/myroutine.pyf"
            ],
            "directive_name": "literalinclude",
            "inner": {
              "inline": [],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Now, if we run "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "python -m numpy.f2py -c myroutine.pyf myroutine.f90"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " we see an error; note that the signature file included a "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "depend(m,n)"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " statement for "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "x"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " which is not necessary. Indeed, editing the file above to read"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "./code/myroutine-edited.pyf"
            ],
            "directive_name": "literalinclude",
            "inner": {
              "inline": [],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "and running "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "f2py -c myroutine.pyf myroutine.f90"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " yields correct results."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        }
      ],
      "title": "``depends`` keyword example"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "value": [
                  {
                    "data": {
                      "inline": [
                        {
                          "data": {
                            "target": "https://scipy.github.io/old-wiki/pages/Cookbook/f2py_and_NumPy.html",
                            "value": "Wrapping C codes using f2py"
                          },
                          "type": "ExternalLink"
                        }
                      ],
                      "inner": []
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "value": [
                  {
                    "data": {
                      "inline": [
                        {
                          "data": {
                            "target": "https://scipy-cookbook.readthedocs.io/items/F2Py.html",
                            "value": "F2py section on the SciPy Cookbook"
                          },
                          "type": "ExternalLink"
                        }
                      ],
                      "inner": []
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "value": [
                  {
                    "data": {
                      "inline": [
                        {
                          "data": {
                            "target": "http://websrv.cs.umt.edu/isis/index.php/F2py_example",
                            "value": "F2py example: Interactive System for Ice sheet Simulation"
                          },
                          "type": "ExternalLink"
                        }
                      ],
                      "inner": []
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "value": [
                  {
                    "data": {
                      "inline": [
                        {
                          "data": {
                            "target": "https://scipy-cookbook.readthedocs.io/items/idx_interfacing_with_other_languages.html",
                            "value": "\"Interfacing With Other Languages\" section on the SciPy Cookbook."
                          },
                          "type": "ExternalLink"
                        }
                      ],
                      "inner": []
                    },
                    "type": "Paragraph"
                  }
                ]
              }
            ]
          },
          "type": "BulletList"
        }
      ],
      "title": "Read more"
    }
  ],
  "example_section_data": {
    "children": [],
    "title": null
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "refs": [],
  "see_also": [],
  "signature": {
    "value": null
  }
}