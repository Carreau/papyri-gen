{
  "_content": {},
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "data": {
            "args0": [],
            "directive_name": "currentmodule",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "numpy "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "placeholder": "target",
            "value": ".. _arrays.ndarray:"
          },
          "type": "Unimplemented"
        }
      ],
      "title": null
    },
    {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "An "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ndarray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is a (usually fixed-size) multidimensional container of items of the same type and size. The number of dimensions and items in an array is defined by its "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "shape <ndarray.shape>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", which is a "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "tuple"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " of "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "N"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " non-negative integers that specify the sizes of each dimension. The type of items in the array is specified by a separate "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "data-type object (dtype) <arrays.dtypes>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", one of which is associated with each ndarray."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "As with other container objects in Python, the contents of an "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ndarray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " can be accessed and modified by "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "indexing or\nslicing <arrays.indexing>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " the array (using, for example, "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "N"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " integers), and via the methods and attributes of the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ndarray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [],
            "directive_name": "index",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "view, base "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Different "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ndarrays <ndarray>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " can share the same data, so that changes made in one "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ndarray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " may be visible in another. That is, an ndarray can be a "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "\"view\""
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " to another ndarray, and the data it is referring to is taken care of by the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "\"base\""
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " ndarray. ndarrays can also be views to memory owned by Python "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "strings <str>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " or objects implementing the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "buffer"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " or "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "array\n<arrays.interface>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " interfaces."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "Example"
            ],
            "directive_name": "admonition",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "A 2 - dimensional array of size 2 x 3, composed of 4 - byte integer elements : >>> x = np.array ( [ [ 1, 2, 3], [ 4, 5, 6]], np.int32) >>> type ( x) < class ' numpy.ndarray ' > >>> x.shape ( 2, 3) >>> x.dtype dtype ( ' int32 ' ) The array can be indexed using Python container - like syntax : >>> # The element of x in the *second* row, *third* column, namely, 6. >>> x [ 1, 2] 6 For example : ref : `slicing < arrays.indexing>` can produce views of the array : >>> y = x [ : ,1] >>> y array ( [ 2, 5], dtype=int32) >>> y [ 0] = 9 # this also changes the corresponding element in x >>> y array ( [ 9, 5], dtype=int32) >>> x array ( [ [ 1, 9, 3], [ 4, 5, 6]], dtype=int32) "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        }
      ],
      "title": "The N-dimensional array (:class:`ndarray`)"
    },
    {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "New arrays can be constructed using the routines detailed in "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "routines.array-creation"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", and also by using the low-level "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ndarray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " constructor:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "placeholder": "target",
            "value": ".. _arrays.ndarray.indexing:"
          },
          "type": "Unimplemented"
        }
      ],
      "title": "Constructing arrays"
    },
    {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Arrays can be indexed using an extended Python slicing syntax, "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "array[selection]"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ".  Similar syntax is also used for accessing fields in a "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "structured data type"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [],
            "directive_name": "seealso",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": ": ref : `Array Indexing < arrays.indexing>`. "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "placeholder": "target",
            "value": ".. _memory-layout:"
          },
          "type": "Unimplemented"
        }
      ],
      "title": "Indexing arrays"
    },
    {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "An instance of class "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ndarray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " consists of a contiguous one-dimensional segment of computer memory (owned by the array, or by some other object), combined with an indexing scheme that maps "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "N"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " integers into the location of an item in the block.  The ranges in which the indices can vary is specified by the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "shape\n<ndarray.shape>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " of the array. How many bytes each item takes and how the bytes are interpreted is defined by the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "data-type object\n<arrays.dtypes>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " associated with the array."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "C-order, Fortran-order, row-major, column-major, stride,"
            ],
            "directive_name": "index",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "offset "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "A segment of memory is inherently 1-dimensional, and there are many different schemes for arranging the items of an "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "N"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": "-dimensional array in a 1-dimensional block. NumPy is flexible, and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ndarray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " objects can accommodate any "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "strided indexing scheme"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": ". In a strided scheme, the N-dimensional index "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "(n_0, n_1, ..., n_{N-1})"
                  ]
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": " corresponds to the offset (in bytes):"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": "n_ { \\mathrm { offset}} = \\sum_ { k=0}^ { N - 1} s_k n_k "
          },
          "type": "BlockMath"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "from the beginning of the memory block associated with the array. Here, "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "s_k"
                  ]
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": " are integers which specify the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "strides\n<ndarray.strides>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " of the array. The "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "column-major"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " order (used, for example, in the Fortran language and in "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "Matlab"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": ") and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "row-major"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " order (used in C) schemes are just specific kinds of strided scheme, and correspond to memory that can be "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "addressed"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " by the strides:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": "s_k^ { \\mathrm { column}} = \\mathrm { itemsize} \\prod_ { j=0}^ { k - 1} d_j , \\quad s_k^ { \\mathrm { row}} = \\mathrm { itemsize} \\prod_ { j=k+1}^ { N - 1} d_j . "
          },
          "type": "BlockMath"
        },
        {
          "data": {
            "args0": [],
            "directive_name": "index",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "single - segment, contiguous, non - contiguous "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "where "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "d_j"
                  ]
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": " "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "= self.shape[j]"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Both the C and Fortran orders are "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "contiguous"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "i.e.,"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " single-segment, memory layouts, in which every part of the memory block can be accessed by some combination of the indices."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "inline": [
                  {
                    "data": {
                      "value": "`Contiguous arrays` and `single - segment arrays` are synonymous and are used interchangeably throughout the documentation. "
                    },
                    "type": "Words"
                  }
                ],
                "inner": []
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "While a C-style and Fortran-style contiguous array, which has the corresponding flags set, can be addressed with the above strides, the actual strides may be different. This can happen in two cases:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": [
              "1. If ``self.shape[k] == 1`` then for any legal index ``index[k] == 0``.",
              "   This means that in the formula for the offset :math:`n_k = 0` and thus",
              "   :math:`s_k n_k = 0` and the value of :math:`s_k` `= self.strides[k]` is",
              "   arbitrary.",
              "2. If an array has no elements (``self.size == 0``) there is no legal",
              "   index and the strides are never used. Any array with no elements may be",
              "   considered C-style and Fortran-style contiguous."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Point 1. means that "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "self"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "self.squeeze()"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " always have the same contiguity and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "aligned"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " flags value. This also means that even a high dimensional array could be C-style and Fortran-style contiguous at the same time."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [],
            "directive_name": "index",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "aligned "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "An array is considered aligned if the memory offsets for all elements and the base offset itself is a multiple of "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "self.itemsize"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": ". Understanding "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "memory-alignment"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " leads to better performance on most hardware."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "inline": [
                  {
                    "data": {
                      "value": "It does *not* generally hold that ``self.strides [ - 1] == self.itemsize`` for C - style contiguous arrays or ``self.strides [ 0] == self.itemsize`` for Fortran - style contiguous arrays is true. ``NPY_RELAXED_STRIDES_DEBUG=1`` can be used to help find errors when incorrectly relying on the strides in C - extension code ( see below warning). "
                    },
                    "type": "Words"
                  }
                ],
                "inner": []
              }
            ],
            "kind": "warning",
            "title": ""
          },
          "type": "Admonition"
        }
      ],
      "title": "Internal memory layout of an ndarray"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "value": [
                  {
                    "data": {
                      "inline": [
                        {
                          "data": {
                            "value": "order, unless otherwise specified, but, for example,  array slicing <arrays.indexing>` often produces "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": [
                              "views <view>"
                            ]
                          },
                          "type": "Verbatim"
                        }
                      ],
                      "inner": []
                    },
                    "type": "Paragraph"
                  }
                ]
              }
            ]
          },
          "type": "EnumeratedList"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "in a different scheme."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ".. seealso: :ref:`Indexing <arrays.ndarray.indexing>`_"
          },
          "type": "Comment"
        },
        {
          "data": {
            "children": [
              {
                "inline": [
                  {
                    "data": {
                      "value": "Several algorithms in NumPy work on arbitrarily strided arrays. However, some algorithms require single - segment arrays. When an irregularly strided array is passed in to such algorithms, a copy is automatically made. "
                    },
                    "type": "Words"
                  }
                ],
                "inner": []
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "placeholder": "target",
            "value": ".. _arrays.ndarray.attributes:"
          },
          "type": "Unimplemented"
        }
      ],
      "title": "Data in new :class:`ndarrays <ndarray>` is in the :term:`row-major`"
    },
    {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Array attributes reflect information that is intrinsic to the array itself. Generally, accessing an array through its attributes allows you to get and sometimes set intrinsic properties of the array without creating a new array. The exposed attributes are the core parts of an array and only some of them can be reset meaningfully without creating a new array. Information on each attribute is given below."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        }
      ],
      "title": "Array attributes"
    },
    {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "The following attributes contain information about the memory layout of the array:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray.flags ndarray.shape ndarray.strides ndarray.ndim ndarray.data ndarray.size ndarray.itemsize ndarray.nbytes ndarray.base "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Memory layout"
    },
    {
      "children": [
        {
          "data": {
            "args0": [],
            "directive_name": "seealso",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": ": ref : `Data type objects < arrays.dtypes>` "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "The data type object associated with the array can be found in the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "dtype <ndarray.dtype>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " attribute:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray.dtype "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Data type"
    },
    {
      "children": [
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray.T ndarray.real ndarray.imag ndarray.flat "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "placeholder": "target",
            "value": ".. _arrays.ndarray.array-interface:"
          },
          "type": "Unimplemented"
        }
      ],
      "title": "Other attributes"
    },
    {
      "children": [
        {
          "data": {
            "args0": [],
            "directive_name": "seealso",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": ": ref : `arrays.interface`. "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "==================================  =================================== "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "~object.__array_interface__"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "  Python-side of the array interface "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "~object.__array_struct__"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "     C-side of the array interface ==================================  ==================================="
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        }
      ],
      "title": "Array interface"
    },
    {
      "children": [
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray.ctypes "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "placeholder": "target",
            "value": ".. _array.ndarray.methods:"
          },
          "type": "Unimplemented"
        }
      ],
      "title": ":mod:`ctypes` foreign function interface"
    },
    {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "An "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ndarray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " object has many methods which operate on or with the array in some fashion, typically returning an array result. These methods are briefly explained below. (Each method's docstring has a more complete description.)"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "For the following methods there are also corresponding functions in "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "numpy"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ": "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "all"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "any"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "argmax"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "argmin"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "argpartition"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "argsort"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "choose"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "clip"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "compress"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "copy"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "cumprod"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "cumsum"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "diagonal"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "imag"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "max <amax>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "mean"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "min <amin>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "nonzero"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "partition"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "prod"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ptp"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "put"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ravel"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "real"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "repeat"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "reshape"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "round <around>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "searchsorted"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "sort"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "squeeze"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "std"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "sum"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "swapaxes"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "take"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "trace"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "transpose"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "var"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        }
      ],
      "title": "Array methods"
    },
    {
      "children": [
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray.item ndarray.tolist ndarray.itemset ndarray.tostring ndarray.tobytes ndarray.tofile ndarray.dump ndarray.dumps ndarray.astype ndarray.byteswap ndarray.copy ndarray.view ndarray.getfield ndarray.setflags ndarray.fill "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Array conversion"
    },
    {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "For reshape, resize, and transpose, the single tuple argument may be replaced with "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "n"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " integers which will be interpreted as an n-tuple."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray.reshape ndarray.resize ndarray.transpose ndarray.swapaxes ndarray.flatten ndarray.ravel ndarray.squeeze "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Shape manipulation"
    },
    {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "For array methods that take an "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "axis"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " keyword, it defaults to "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "None"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": ". If axis is "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "None"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": ", then the array is treated as a 1-D array. Any other value for "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "axis"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " represents the dimension along which the operation should proceed."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray.take ndarray.put ndarray.repeat ndarray.choose ndarray.sort ndarray.argsort ndarray.partition ndarray.argpartition ndarray.searchsorted ndarray.nonzero ndarray.compress ndarray.diagonal "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Item selection and manipulation"
    },
    {
      "children": [
        {
          "data": {
            "args0": [],
            "directive_name": "index",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "axis "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Many of these methods take an argument named "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "axis"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": ". In such cases,"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "value": [
                  {
                    "data": {
                      "inline": [
                        {
                          "data": {
                            "value": "If "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": {
                              "value": "axis"
                            }
                          },
                          "type": "Emph"
                        },
                        {
                          "data": {
                            "value": " is "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": {
                              "value": "None"
                            }
                          },
                          "type": "Emph"
                        },
                        {
                          "data": {
                            "value": " (the default), the array is treated as a 1-D   array and the operation is performed over the entire array. This   behavior is also the default if self is a 0-dimensional array or   array scalar. (An array scalar is an instance of the types/classes   float32, float64, etc., whereas a 0-dimensional array is an ndarray   instance containing precisely one array scalar.)"
                          },
                          "type": "Words"
                        }
                      ],
                      "inner": []
                    },
                    "type": "Paragraph"
                  }
                ]
              }
            ]
          },
          "type": "BulletList"
        },
        {
          "data": {
            "children": [
              {
                "value": [
                  {
                    "data": {
                      "inline": [
                        {
                          "data": {
                            "value": "If "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": {
                              "value": "axis"
                            }
                          },
                          "type": "Emph"
                        },
                        {
                          "data": {
                            "value": " is an integer, then the operation is done over the given   axis (for each 1-D subarray that can be created along the given axis)."
                          },
                          "type": "Words"
                        }
                      ],
                      "inner": []
                    },
                    "type": "Paragraph"
                  }
                ]
              }
            ]
          },
          "type": "BulletList"
        },
        {
          "data": {
            "args0": [
              "Example of the *axis* argument"
            ],
            "directive_name": "admonition",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "A 3 - dimensional array of size 3 x 3 x 3, summed over each of its three axes >>> x = np.arange ( 27).reshape ( ( 3,3,3)) >>> x array ( [ [ [ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8]], [ [ 9, 10, 11], [ 12, 13, 14], [ 15, 16, 17]], [ [ 18, 19, 20], [ 21, 22, 23], [ 24, 25, 26]]]) >>> x.sum ( axis=0) array ( [ [ 27, 30, 33], [ 36, 39, 42], [ 45, 48, 51]]) >>> # for sum, axis is the first keyword, so we may omit it, >>> # specifying only its value >>> x.sum ( 0), x.sum ( 1), x.sum ( 2) ( array ( [ [ 27, 30, 33], [ 36, 39, 42], [ 45, 48, 51]]), array ( [ [ 9, 12, 15], [ 36, 39, 42], [ 63, 66, 69]]), array ( [ [ 3, 12, 21], [ 30, 39, 48], [ 57, 66, 75]])) "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "The parameter "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "dtype"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " specifies the data type over which a reduction operation (like summing) should take place. The default reduce data type is the same as the data type of "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "self"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": ". To avoid overflow, it can be useful to perform the reduction using a larger data type."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "For several methods, an optional "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "out"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " argument can also be provided and the result will be placed into the output array given. The "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "out"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " argument must be an "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ndarray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " and have the same number of elements. It can have a different data type in which case casting will be performed."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray.max ndarray.argmax ndarray.min ndarray.argmin ndarray.ptp ndarray.clip ndarray.conj ndarray.round ndarray.trace ndarray.sum ndarray.cumsum ndarray.mean ndarray.var ndarray.std ndarray.prod ndarray.cumprod ndarray.all ndarray.any "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Calculation"
    },
    {
      "children": [
        {
          "data": {
            "args0": [],
            "directive_name": "index",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "comparison, arithmetic, matrix, operation, operator "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Arithmetic and comparison operations on "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ndarrays <ndarray>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " are defined as element-wise operations, and generally yield "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ndarray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " objects as results."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Each of the arithmetic operations ("
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "+"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "-"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "*"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "/"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "//"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "%"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "divmod()"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "**"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " or "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "pow()"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "<<"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    ">>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "&"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "^"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "|"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "~"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ") and the comparisons ("
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "=="
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "<"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    ">"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "<="
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    ">="
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "!="
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ") is equivalent to the corresponding universal function (or "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ufunc"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " for short) in NumPy.  For more information, see the section on "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "Universal Functions\n<ufuncs>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Comparison operators:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray.__lt__ ndarray.__le__ ndarray.__gt__ ndarray.__ge__ ndarray.__eq__ ndarray.__ne__ "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Truth value of an array ("
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "bool() <bool>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "):"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray.__bool__ "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "inline": [
                  {
                    "data": {
                      "value": "Truth - value testing of an array invokes : meth : `ndarray.__bool__`, which raises an error if the number of elements in the array is larger than 1, because the truth value of such arrays is ambiguous. Use : meth : `.any ( ) < ndarray.any>` and : meth : `.all ( ) < ndarray.all>` instead to be clear about what is meant in such cases. ( If the number of elements is 0, the array evaluates to ``False``.) "
                    },
                    "type": "Words"
                  }
                ],
                "inner": []
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Unary operations:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray.__neg__ ndarray.__pos__ ndarray.__abs__ ndarray.__invert__ "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Arithmetic:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray.__add__ ndarray.__sub__ ndarray.__mul__ ndarray.__truediv__ ndarray.__floordiv__ ndarray.__mod__ ndarray.__divmod__ ndarray.__pow__ ndarray.__lshift__ ndarray.__rshift__ ndarray.__and__ ndarray.__or__ ndarray.__xor__ "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "inline": [
                  {
                    "data": {
                      "value": "- Any third argument to : func : `pow ( )` is silently ignored, as the underlying : func : `ufunc < power>` takes only two arguments. - Because : class : `ndarray` is a built - in type ( written in C), the ``__r { op}__`` special methods are not directly defined. - The functions called to implement many arithmetic special methods for arrays can be modified using : class : `__array_ufunc__ < numpy.class.__array_ufunc__>`. "
                    },
                    "type": "Words"
                  }
                ],
                "inner": []
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Arithmetic, in-place:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray.__iadd__ ndarray.__isub__ ndarray.__imul__ ndarray.__itruediv__ ndarray.__ifloordiv__ ndarray.__imod__ ndarray.__ipow__ ndarray.__ilshift__ ndarray.__irshift__ ndarray.__iand__ ndarray.__ior__ ndarray.__ixor__ "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "inline": [
                  {
                    "data": {
                      "value": "In place operations will perform the calculation using the precision decided by the data type of the two operands, but will silently downcast the result ( if necessary) so it can fit back into the array. Therefore, for mixed precision calculations, ``A { op}= B`` can be different than ``A = A { op} B``. For example, suppose ``a = ones ( ( 3,3))``. Then, ``a += 3j`` is different than ``a = a + 3j`` : while they both perform the same computation, ``a += 3`` casts the result to fit back in ``a``, whereas ``a = a + 3j`` re - binds the name ``a`` to the result. "
                    },
                    "type": "Words"
                  }
                ],
                "inner": []
              }
            ],
            "kind": "warning",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Matrix Multiplication:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray.__matmul__ "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "inline": [
                  {
                    "data": {
                      "value": "Matrix operators ``@`` and ``@=`` were introduced in Python 3.5 following : pep : `465`, and the ``@`` operator has been introduced in NumPy 1.10.0. Further information can be found in the : func : `matmul` documentation. "
                    },
                    "type": "Words"
                  }
                ],
                "inner": []
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        }
      ],
      "title": "Arithmetic, matrix multiplication, and comparison operations"
    },
    {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "For standard library functions:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray.__copy__ ndarray.__deepcopy__ ndarray.__reduce__ ndarray.__setstate__ "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Basic customization:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray.__new__ ndarray.__array__ ndarray.__array_wrap__ "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Container customization: (see "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "Indexing <arrays.indexing>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ")"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray.__len__ ndarray.__getitem__ ndarray.__setitem__ ndarray.__contains__ "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Conversion; the operations "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "int() <int>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "float() <float>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "complex() <complex>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ". They work only on arrays that have one element in them and return the appropriate scalar."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray.__int__ ndarray.__float__ ndarray.__complex__ "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "String representations:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray.__str__ ndarray.__repr__ "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Utility method for typing:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "ndarray.__class_getitem__ "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Special methods"
    }
  ],
  "example_section_data": {
    "children": [],
    "title": null
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "refs": [],
  "see_also": [],
  "signature": {
    "value": null
  }
}