{
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "data": {
            "placeholder": "target",
            "value": ".. _arrays.scalars:"
          },
          "type": "Unimplemented"
        }
      ],
      "title": null
    },
    {
      "children": [
        {
          "data": {
            "argument": "numpy",
            "content": "",
            "name": "currentmodule",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Python defines only one type of a particular data class (there is only one integer type, one floating-point type, etc.). This can be convenient in applications that don't need to be concerned with all the ways data can be represented in a computer.  For scientific computing, however, more control is often needed."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "In NumPy, there are 24 new fundamental Python types to describe different types of scalars. These type descriptors are mostly based on the types available in the C language that CPython is written in, with several additional types compatible with Python's types."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Array scalars have the same attributes and methods as "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ndarrays\n<ndarray>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ".  This allows one to treat items of an array partly on the same footing as arrays, smoothing out rough edges that result when mixing scalar and array operations."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Array scalars live in a hierarchy (see the Figure below) of data types. They can be detected using the hierarchy: For example, "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "isinstance(val, np.generic)"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " will return "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "True"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " if "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "val"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " is an array scalar object. Alternatively, what kind of array scalar is present can be determined using other members of the data type hierarchy. Thus, for example "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "isinstance(val, np.complexfloating)"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " will return "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "True"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " if "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "val"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " is a complex valued type, while "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "isinstance(val, np.flexible)"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " will return true if "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "val"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " is one of the flexible itemsize array types ("
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "str_"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "bytes_"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "void"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ")."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "figures/dtype-hierarchy.png",
            "content": "**Figure:** Hierarchy of type objects representing the array data\ntypes. Not shown are the two integer types :class:`intp` and\n:class:`uintp` which just point to the integer type that holds a\npointer for the platform. All the number types can be obtained\nusing bit-width names as well.",
            "name": "figure",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": ".. TODO - use something like this instead of the diagram above, as it generates\n   links to the classes and is a vector graphic. Unfortunately it looks worse\n   and the html <map> element providing the linked regions is misaligned.\n\n   .. inheritance-diagram:: byte short intc int_ longlong ubyte ushort uintc uint ulonglong half single double longdouble csingle cdouble clongdouble bool_ datetime64 timedelta64 object_ bytes_ str_ void"
          },
          "type": "Comment"
        },
        {
          "data": {
            "placeholder": "footnote",
            "value": ".. [#] However, array scalars are immutable, so none of the array\n       scalar attributes are settable."
          },
          "type": "Unimplemented"
        },
        {
          "data": {
            "placeholder": "target",
            "value": ".. _arrays.scalars.character-codes:"
          },
          "type": "Unimplemented"
        },
        {
          "data": {
            "placeholder": "target",
            "value": ".. _arrays.scalars.built-in:"
          },
          "type": "Unimplemented"
        }
      ],
      "title": "Scalars"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The built-in scalar types are shown below. The C-like names are associated with character codes, which are shown in their descriptions. Use of the character codes, however, is discouraged."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Some of the scalar types are essentially equivalent to fundamental Python types and therefore inherit from them as well as from the generic array scalar type:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "====================  ===========================  ============= Array scalar type     Related Python type          Inherits? ====================  ===========================  ============= "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "int_"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "         "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "int"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "                 Python 2 only "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "float_"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "       "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "float"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "               yes "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "complex_"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "     "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "complex"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "             yes "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "bytes_"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "       "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "bytes"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "               yes "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "str_"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "         "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "str"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "                 yes "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "bool_"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "        "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "bool"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "                no "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "datetime64"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "   "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "datetime.datetime"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "   no "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "timedelta64"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "  "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "datetime.timedelta"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "  no ====================  ===========================  ============="
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "bool_"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " data type is very similar to the Python "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "bool"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " but does not inherit from it because Python's "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "bool"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " does not allow itself to be inherited from, and on the C-level the size of the actual bool data is not the same as a Python Boolean scalar."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "The "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": "class",
                        "value": "int_"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " type does "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "content": {
                          "value": "not"
                        }
                      },
                      "type": "Strong"
                    },
                    {
                      "data": {
                        "value": " inherit from the "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": "class",
                        "value": "int"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " built-in under Python 3, because type "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": "class",
                        "value": "int"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " is no longer a fixed-width integer type."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ],
            "kind": "warning",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "argument": "The default data type in NumPy is :class:`float_`.",
            "content": "",
            "name": "tip",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.generic",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.number",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Built-in scalar types"
    },
    {
      "children": [
        {
          "data": {
            "argument": "numpy.integer",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "The numpy integer types mirror the behavior of C integers, and can therefore be subject to "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": "ref",
                        "value": "overflow-errors"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": "."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        }
      ],
      "title": "Integer types"
    },
    {
      "children": [
        {
          "data": {
            "argument": "numpy.signedinteger",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.byte",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.short",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.intc",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.int_",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.longlong",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Signed integer types"
    },
    {
      "children": [
        {
          "data": {
            "argument": "numpy.unsignedinteger",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.ubyte",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.ushort",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.uintc",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.uint",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.ulonglong",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Unsigned integer types"
    },
    {
      "children": [
        {
          "data": {
            "argument": "numpy.inexact",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "Inexact scalars are printed using the fewest decimal digits needed to distinguish their value from other values of the same datatype, by judicious rounding. See the "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "unique"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " parameter of "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": null,
                        "value": "format_float_positional"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " and "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": null,
                        "value": "format_float_scientific"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": "."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "This means that variables with equal binary values but whose datatypes are of different precisions may display differently::      "
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "value": ">>> f16 = np.float16(\"0.1\")\n>>> f32 = np.float32(f16)\n>>> f64 = np.float64(f32)\n>>> f16 == f32 == f64\nTrue\n>>> f16, f32, f64\n(0.1, 0.099975586, 0.0999755859375)"
                },
                "type": "BlockVerbatim"
              },
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "Note that none of these floats hold the exact value "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": "math",
                        "value": "\\frac{1}{10}"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": "; "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "f16"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " prints as "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "0.1"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " because it is as close to that value as possible, whereas the other types do not as they have more precision and therefore have closer values."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "Conversely, floating-point scalars of different precisions which approximate the same decimal value may compare unequal despite printing identically:"
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": ">>> f16 = np.float16(\"0.1\")\n>>> f32 = np.float32(\"0.1\")\n>>> f64 = np.float64(\"0.1\")\n>>> f16 == f32 == f64\nFalse\n>>> f16, f32, f64\n(0.1, 0.1, 0.1)"
                      },
                      "type": "BlockVerbatim"
                    }
                  ]
                },
                "type": "BlockQuote"
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        }
      ],
      "title": "Inexact types"
    },
    {
      "children": [
        {
          "data": {
            "argument": "numpy.floating",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.half",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.single",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.double",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.longdouble",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Floating-point types"
    },
    {
      "children": [
        {
          "data": {
            "argument": "numpy.complexfloating",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.csingle",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.cdouble",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.clongdouble",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Complex floating-point types"
    },
    {
      "children": [
        {
          "data": {
            "argument": "numpy.bool_",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.datetime64",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.timedelta64",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.object_",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "The data actually stored in object arrays ("
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": {
                          "value": "i.e."
                        }
                      },
                      "type": "Emph"
                    },
                    {
                      "data": {
                        "value": ", arrays having dtype "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": "class",
                        "value": "object_"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": ") are references to Python objects, not the objects themselves. Hence, object arrays behave more like usual Python "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": "class",
                        "value": "lists <list>"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": ", in the sense that their contents need not be of the same Python type."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "The object type is also special because an array containing "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": "class",
                        "value": "object_"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " items does not return an "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": "class",
                        "value": "object_"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " object on item access, but instead returns the actual object that the array item refers to."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "argument": "flexible",
            "content": "",
            "name": "index",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The following data types are "
                },
                "type": "Words"
              },
              {
                "data": {
                  "content": {
                    "value": "flexible"
                  }
                },
                "type": "Strong"
              },
              {
                "data": {
                  "value": ": they have no predefined size and the data they describe can be of different length in different arrays. (In the character codes "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "#"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is an integer denoting how many elements the data type consists of.)"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "numpy.flexible",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.bytes_",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.str_",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.void",
            "content": "",
            "name": "autoclass",
            "options": [
              [
                "members",
                "__init__"
              ],
              [
                "exclude-members",
                "__init__"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "See "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": "ref",
                        "value": "Note on string types<string-dtype-note>"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": "."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "Numeric Compatibility: If you used old typecode characters in your Numeric code (which was never recommended), you will need to change some of them to the new characters. In particular, the needed changes are "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "c -> S1"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ", "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "b -> B"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ", "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "1 -> b"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ", "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "s -> h"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ", "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "w ->\nH"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ", and "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "u -> I"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ". These changes make the type character convention more consistent with other Python modules such as the "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": "mod",
                        "value": "struct"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " module."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ],
            "kind": "warning",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "placeholder": "target",
            "value": ".. _sized-aliases:"
          },
          "type": "Unimplemented"
        }
      ],
      "title": "Other types"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Along with their (mostly) C-derived names, the integer, float, and complex data-types are also available using a bit-width convention so that an array of the right size can always be ensured. Two aliases ("
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "numpy.intp"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "numpy.uintp"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ") pointing to the integer type that is sufficiently large to hold a C pointer are also provided."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ".. note that these are documented with ..attribute because that is what\n   autoclass does for aliases under the hood."
          },
          "type": "Comment"
        },
        {
          "data": {
            "argument": "numpy.bool8",
            "content": "",
            "name": "autoclass",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int8",
            "content": "int16\nint32\nint64",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "Aliases for the signed integer types (one of "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "module",
                        "reference": {
                          "kind": "api",
                          "module": "numpy",
                          "path": "numpy.int8",
                          "version": "*"
                        },
                        "value": "numpy.byte"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": ", "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "module",
                        "reference": {
                          "kind": "api",
                          "module": "numpy",
                          "path": "numpy.int16",
                          "version": "*"
                        },
                        "value": "numpy.short"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": ",    "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "module",
                        "reference": {
                          "kind": "api",
                          "module": "numpy",
                          "path": "numpy.int32",
                          "version": "*"
                        },
                        "value": "numpy.intc"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": ", "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "module",
                        "reference": {
                          "kind": "api",
                          "module": "numpy",
                          "path": "numpy.int64",
                          "version": "*"
                        },
                        "value": "numpy.int_"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " and "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "module",
                        "reference": {
                          "kind": "api",
                          "module": "numpy",
                          "path": "numpy.longlong",
                          "version": "*"
                        },
                        "value": "numpy.longlong"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": ") with the specified number    of bits."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "Compatible with the C99 "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "int8_t"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ", "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "int16_t"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ", "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "int32_t"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ", and    "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "int64_t"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ", respectively."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "uint8",
            "content": "uint16\nuint32\nuint64",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "Alias for the unsigned integer types (one of "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "module",
                        "reference": {
                          "kind": "api",
                          "module": "numpy",
                          "path": "numpy.uint8",
                          "version": "*"
                        },
                        "value": "numpy.ubyte"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": ", "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "module",
                        "reference": {
                          "kind": "api",
                          "module": "numpy",
                          "path": "numpy.uint16",
                          "version": "*"
                        },
                        "value": "numpy.ushort"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": ",    "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "module",
                        "reference": {
                          "kind": "api",
                          "module": "numpy",
                          "path": "numpy.uint32",
                          "version": "*"
                        },
                        "value": "numpy.uintc"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": ", "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "module",
                        "reference": {
                          "kind": "api",
                          "module": "numpy",
                          "path": "numpy.uint64",
                          "version": "*"
                        },
                        "value": "numpy.uint"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " and "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "module",
                        "reference": {
                          "kind": "api",
                          "module": "numpy",
                          "path": "numpy.ulonglong",
                          "version": "*"
                        },
                        "value": "numpy.ulonglong"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": ") with the specified number    of bits."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "Compatible with the C99 "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "uint8_t"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ", "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "uint16_t"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ", "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "uint32_t"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ", and    "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "uint64_t"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ", respectively."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "intp",
            "content": "Alias for the signed integer type (one of `numpy.byte`, `numpy.short`,\n`numpy.intc`, `numpy.int_` and `np.longlong`) that is the same size as a\npointer.\n\nCompatible with the C ``intptr_t``.\n\n:Character code: ``'p'``",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "uintp",
            "content": "Alias for the unsigned integer type (one of `numpy.ubyte`, `numpy.ushort`,\n`numpy.uintc`, `numpy.uint` and `np.ulonglong`) that is the same size as a\npointer.\n\nCompatible with the C ``uintptr_t``.\n\n:Character code: ``'P'``",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.float16",
            "content": "",
            "name": "autoclass",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.float32",
            "content": "",
            "name": "autoclass",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.float64",
            "content": "",
            "name": "autoclass",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "float96",
            "content": "float128",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "Alias for "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "module",
                        "reference": {
                          "kind": "api",
                          "module": "numpy",
                          "path": "numpy.longdouble",
                          "version": "*"
                        },
                        "value": "numpy.longdouble"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": ", named after its size in bits.    The existence of these aliases depends on the platform."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "numpy.complex64",
            "content": "",
            "name": "autoclass",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.complex128",
            "content": "",
            "name": "autoclass",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "complex192",
            "content": "complex256",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "Alias for "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "module",
                        "reference": {
                          "kind": "api",
                          "module": "numpy",
                          "path": "numpy.clongdouble",
                          "version": "*"
                        },
                        "value": "numpy.clongdouble"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": ", named after its size in bits.    The existence of these aliases depends on the platform."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ]
          },
          "type": "BlockQuote"
        }
      ],
      "title": "Sized aliases"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The first two of these are conveniences which resemble the names of the builtin types, in the same style as "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "bool_"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "int_"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "str_"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "bytes_"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": ", and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "object_"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": ":"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "numpy.float_",
            "content": "",
            "name": "autoclass",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.complex_",
            "content": "",
            "name": "autoclass",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Some more use alternate naming conventions for extended-precision floats and complex numbers:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "numpy.longfloat",
            "content": "",
            "name": "autoclass",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.singlecomplex",
            "content": "",
            "name": "autoclass",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.cfloat",
            "content": "",
            "name": "autoclass",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.longcomplex",
            "content": "",
            "name": "autoclass",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.clongfloat",
            "content": "",
            "name": "autoclass",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The following aliases originate from Python 2, and it is recommended that they not be used in new code."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "numpy.string_",
            "content": "",
            "name": "autoclass",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy.unicode_",
            "content": "",
            "name": "autoclass",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Other aliases"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The array scalar objects have an "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "array priority\n<class.__array_priority__>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " of "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NPY_SCALAR_PRIORITY"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " (-1,000,000.0). They also do not (yet) have a "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ctypes <ndarray.ctypes>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " attribute. Otherwise, they share the same attributes as arrays:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    generic.flags\n    generic.shape\n    generic.strides\n    generic.ndim\n    generic.data\n    generic.size\n    generic.itemsize\n    generic.base\n    generic.dtype\n    generic.real\n    generic.imag\n    generic.flat\n    generic.T\n    generic.__array_interface__\n    generic.__array_struct__\n    generic.__array_priority__\n    generic.__array_wrap__"
          },
          "type": "BlockVerbatim"
        }
      ],
      "title": "Attributes"
    },
    {
      "children": [
        {
          "data": {
            "argument": ":ref:`arrays.indexing`, :ref:`arrays.dtypes`",
            "content": "",
            "name": "seealso",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Array scalars can be indexed like 0-dimensional arrays: if "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "x"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " is an array scalar,"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": [
                              "x[()]"
                            ]
                          },
                          "type": "Verbatim"
                        },
                        {
                          "data": {
                            "value": " returns a copy of array scalar"
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": [
                              "x[...]"
                            ]
                          },
                          "type": "Verbatim"
                        },
                        {
                          "data": {
                            "value": " returns a 0-dimensional "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": [
                              "ndarray"
                            ]
                          },
                          "type": "Verbatim"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": [
                              "x['field-name']"
                            ]
                          },
                          "type": "Verbatim"
                        },
                        {
                          "data": {
                            "value": " returns the array scalar in the field "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": {
                              "value": "field-name"
                            }
                          },
                          "type": "Emph"
                        },
                        {
                          "data": {
                            "value": ".   ("
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": {
                              "value": "x"
                            }
                          },
                          "type": "Emph"
                        },
                        {
                          "data": {
                            "value": " can have fields, for example, when it corresponds to a structured data type.)"
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              }
            ]
          },
          "type": "BulletList"
        }
      ],
      "title": "Indexing"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Array scalars have exactly the same methods as arrays. The default behavior of these methods is to internally convert the scalar to an equivalent 0-dimensional array and to call the corresponding array method. In addition, math operations on array scalars are defined so that the same hardware flags are set and used to interpret the results as for "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ufunc <ufuncs>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", so that the error state used for ufuncs also carries over to the math on array scalars."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The exceptions to the above rules are given below:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    generic.__array__\n    generic.__array_wrap__\n    generic.squeeze\n    generic.byteswap\n    generic.__reduce__\n    generic.__setstate__\n    generic.setflags"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Utility method for typing:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    number.__class_getitem__"
          },
          "type": "BlockVerbatim"
        }
      ],
      "title": "Methods"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "There are two ways to effectively define a new array scalar type (apart from composing structured types "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "dtypes <arrays.dtypes>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " from the built-in scalar types): One way is to simply subclass the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ndarray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " and overwrite the methods of interest. This will work to a degree, but internally certain behaviors are fixed by the data type of the array.  To fully customize the data type of an array you need to define a new data-type, and register it with NumPy. Such new types can only be defined in C, using the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NumPy C-API <c-api>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "title": "Defining new types"
    }
  ],
  "content": {},
  "example_section_data": {
    "children": [],
    "title": null
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "see_also": [],
  "signature": {
    "value": null
  }
}