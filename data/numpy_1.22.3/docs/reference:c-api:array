{
  "_content": {},
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "data": {
            "argument": "Travis E. Oliphant",
            "content": "",
            "name": "sectionauthor",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "",
            "content": "pair: ndarray; C-API\npair: C-API; array",
            "name": "index",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Array API"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "These macros access the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArrayObject"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " structure members and are defined in "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ndarraytypes.h"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ". The input argument, "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "arr"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": ", can be any "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyObject *"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " that is directly interpretable as a "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArrayObject *"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " (any instance of the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_Type"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " and its sub-types)."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "int PyArray_NDIM(PyArrayObject *arr)",
            "content": "The number of dimensions in the array.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_FLAGS(PyArrayObject* arr)",
            "content": "Returns an integer representing the :ref:`array-flags<array-flags>`.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_TYPE(PyArrayObject* arr)",
            "content": "Return the (builtin) typenumber for the elements of this array.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_SETITEM( \\",
            "content": "PyArrayObject* arr, void* itemptr, PyObject* obj)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Convert obj and place it in the ndarray, *arr*, at the place",
              "pointed to by itemptr. Return -1 if an error occurs or 0 on",
              "success."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "void PyArray_ENABLEFLAGS(PyArrayObject* arr, int flags)",
            "content": ".. versionadded:: 1.7\n\nEnables the specified array flags. This function does no validation,\nand assumes that you know what you're doing.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void PyArray_CLEARFLAGS(PyArrayObject* arr, int flags)",
            "content": ".. versionadded:: 1.7\n\nClears the specified array flags. This function does no validation,\nand assumes that you know what you're doing.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void *PyArray_DATA(PyArrayObject *arr)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "char *PyArray_BYTES(PyArrayObject *arr)",
            "content": "These two macros are similar and obtain the pointer to the\ndata-buffer for the array. The first macro can (and should be)\nassigned to a particular pointer where the second is for generic\nprocessing. If you have not guaranteed a contiguous and/or aligned\narray then be sure you understand how to access the data in the\narray to avoid memory and/or alignment problems.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "npy_intp *PyArray_DIMS(PyArrayObject *arr)",
            "content": "Returns a pointer to the dimensions/shape of the array. The\nnumber of elements matches the number of dimensions\nof the array. Can return ``NULL`` for 0-dimensional arrays.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "npy_intp *PyArray_SHAPE(PyArrayObject *arr)",
            "content": ".. versionadded:: 1.7\n\nA synonym for :c:func:`PyArray_DIMS`, named to be consistent with the\n`shape <numpy.ndarray.shape>` usage within Python.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "npy_intp *PyArray_STRIDES(PyArrayObject* arr)",
            "content": "Returns a pointer to the strides of the array. The\nnumber of elements matches the number of dimensions\nof the array.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "npy_intp PyArray_DIM(PyArrayObject* arr, int n)",
            "content": "Return the shape in the *n* :math:`^{\\textrm{th}}` dimension.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "npy_intp PyArray_STRIDE(PyArrayObject* arr, int n)",
            "content": "Return the stride in the *n* :math:`^{\\textrm{th}}` dimension.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "npy_intp PyArray_ITEMSIZE(PyArrayObject* arr)",
            "content": "Return the itemsize for the elements of this array.\n\nNote that, in the old API that was deprecated in version 1.7, this function\nhad the return type ``int``.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "npy_intp PyArray_SIZE(PyArrayObject* arr)",
            "content": "Returns the total size (in number of elements) of the array.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "npy_intp PyArray_Size(PyArrayObject* obj)",
            "content": "Returns 0 if *obj* is not a sub-class of ndarray. Otherwise,\nreturns the total number of elements in the array. Safer version\nof :c:func:`PyArray_SIZE` (*obj*).",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "npy_intp PyArray_NBYTES(PyArrayObject* arr)",
            "content": "Returns the total number of bytes consumed by the array.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject *PyArray_BASE(PyArrayObject* arr)",
            "content": "This returns the base object of the array. In most cases, this\nmeans the object which owns the memory the array is pointing at.\n\nIf you are constructing an array using the C API, and specifying\nyour own memory, you should use the function :c:func:`PyArray_SetBaseObject`\nto set the base to an object which owns the memory.\n\nIf the :c:data:`NPY_ARRAY_WRITEBACKIFCOPY` flag is set, it has a different\nmeaning, namely base is the array into which the current array will\nbe copied upon copy resolution. This overloading of the base property\nfor two functions is likely to change in a future version of NumPy.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyArray_Descr *PyArray_DESCR(PyArrayObject* arr)",
            "content": "Returns a borrowed reference to the dtype property of the array.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyArray_Descr *PyArray_DTYPE(PyArrayObject* arr)",
            "content": ".. versionadded:: 1.7\n\nA synonym for PyArray_DESCR, named to be consistent with the\n'dtype' usage within Python.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject *PyArray_GETITEM(PyArrayObject* arr, void* itemptr)",
            "content": "Get a Python object of a builtin type from the ndarray, *arr*,\nat the location pointed to by itemptr. Return ``NULL`` on failure.\n\n`numpy.ndarray.item` is identical to PyArray_GETITEM.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_FinalizeFunc(PyArrayObject* arr, PyObject* obj)",
            "content": "The function pointed to by the CObject\n:obj:`~numpy.class.__array_finalize__`.\nThe first argument is the newly created sub-type. The second argument\n(if not NULL) is the \"parent\" array (if the array was created using\nslicing or some other operation where a clearly-distinguishable parent\nis present). This routine can do anything it wants to. It should\nreturn a -1 on error and 0 otherwise.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Array structure and data access"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "These functions and macros provide easy access to elements of the ndarray from C. These work for all arrays. You may need to take care when accessing the data in the array, however, if it is not in machine byte-order, misaligned, or not writeable. In other words, be sure to respect the state of the flags unless you know what you are doing, or have previously guaranteed an array that is writeable, aligned, and in machine byte-order using "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_FromAny"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ". If you wish to handle all types of arrays, the copyswap function for each type is useful for handling misbehaved arrays. Some platforms (e.g. Solaris) do not like misaligned data and will crash if you de-reference a misaligned pointer. Other platforms (e.g. x86 Linux) will just work more slowly with misaligned data."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "void* PyArray_GetPtr(PyArrayObject* aobj, npy_intp* ind)",
            "content": "Return a pointer to the data of the ndarray, *aobj*, at the\nN-dimensional index given by the c-array, *ind*, (which must be\nat least *aobj* ->nd in size). You may want to typecast the\nreturned pointer to the data type of the ndarray.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void* PyArray_GETPTR1(PyArrayObject* obj, npy_intp i)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void* PyArray_GETPTR2( \\",
            "content": "PyArrayObject* obj, npy_intp i, npy_intp j)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void* PyArray_GETPTR3( \\",
            "content": "PyArrayObject* obj, npy_intp i, npy_intp j, npy_intp k)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void* PyArray_GETPTR4( \\",
            "content": "PyArrayObject* obj, npy_intp i, npy_intp j, npy_intp k, npy_intp l)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Quick, inline access to the element at the given coordinates in",
              "the ndarray, *obj*, which must have respectively 1, 2, 3, or 4",
              "dimensions (this is not checked). The corresponding *i*, *j*,",
              "*k*, and *l* coordinates can be any integer but will be",
              "interpreted as ``npy_intp``. You may want to typecast the",
              "returned pointer to the data type of the ndarray."
            ]
          },
          "type": "BlockQuote"
        }
      ],
      "title": "Data access"
    },
    {
      "children": [],
      "title": "Creating arrays"
    },
    {
      "children": [
        {
          "data": {
            "argument": "PyObject* PyArray_NewFromDescr( \\",
            "content": "PyTypeObject* subtype, PyArray_Descr* descr, int nd, npy_intp const* dims, \\\nnpy_intp const* strides, void* data, int flags, PyObject* obj)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "This function steals a reference to *descr*. The easiest way to get one",
              "is using :c:func:`PyArray_DescrFromType`.",
              "",
              "This is the main array creation function. Most new arrays are",
              "created with this flexible function.",
              "",
              "The returned object is an object of Python-type *subtype*, which",
              "must be a subtype of :c:data:`PyArray_Type`.  The array has *nd*",
              "dimensions, described by *dims*. The data-type descriptor of the",
              "new array is *descr*.",
              "",
              "If *subtype* is of an array subclass instead of the base",
              ":c:data:`&PyArray_Type<PyArray_Type>`, then *obj* is the object to pass to",
              "the :obj:`~numpy.class.__array_finalize__` method of the subclass.",
              "",
              "If *data* is ``NULL``, then new unitinialized memory will be allocated and",
              "*flags* can be non-zero to indicate a Fortran-style contiguous array. Use",
              ":c:func:`PyArray_FILLWBYTE` to initialize the memory.",
              "",
              "If *data* is not ``NULL``, then it is assumed to point to the memory",
              "to be used for the array and the *flags* argument is used as the",
              "new flags for the array (except the state of :c:data:`NPY_ARRAY_OWNDATA`,",
              ":c:data:`NPY_ARRAY_WRITEBACKIFCOPY` flag of the new array will be reset).",
              "",
              "In addition, if *data* is non-NULL, then *strides* can",
              "also be provided. If *strides* is ``NULL``, then the array strides",
              "are computed as C-style contiguous (default) or Fortran-style",
              "contiguous (*flags* is nonzero for *data* = ``NULL`` or *flags* &",
              ":c:data:`NPY_ARRAY_F_CONTIGUOUS` is nonzero non-NULL *data*). Any",
              "provided *dims* and *strides* are copied into newly allocated",
              "dimension and strides arrays for the new array object.",
              "",
              ":c:func:`PyArray_CheckStrides` can help verify non- ``NULL`` stride",
              "information.",
              "",
              "If ``data`` is provided, it must stay alive for the life of the array. One",
              "way to manage this is through :c:func:`PyArray_SetBaseObject`"
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_NewLikeArray( \\",
            "content": "PyArrayObject* prototype, NPY_ORDER order, PyArray_Descr* descr, \\\nint subok)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              ".. versionadded:: 1.6",
              "",
              "This function steals a reference to *descr* if it is not NULL.",
              "This array creation routine allows for the convenient creation of",
              "a new array matching an existing array's shapes and memory layout,",
              "possibly changing the layout and/or data type.",
              "",
              "When *order* is :c:data:`NPY_ANYORDER`, the result order is",
              ":c:data:`NPY_FORTRANORDER` if *prototype* is a fortran array,",
              ":c:data:`NPY_CORDER` otherwise.  When *order* is",
              ":c:data:`NPY_KEEPORDER`, the result order matches that of *prototype*, even",
              "when the axes of *prototype* aren't in C or Fortran order.",
              "",
              "If *descr* is NULL, the data type of *prototype* is used.",
              "",
              "If *subok* is 1, the newly created array will use the sub-type of",
              "*prototype* to create the new array, otherwise it will create a",
              "base-class array."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_New( \\",
            "content": "PyTypeObject* subtype, int nd, npy_intp const* dims, int type_num, \\\nnpy_intp const* strides, void* data, int itemsize, int flags, \\\nPyObject* obj)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "This is similar to :c:func:`PyArray_NewFromDescr` (...) except you",
              "specify the data-type descriptor with *type_num* and *itemsize*,",
              "where *type_num* corresponds to a builtin (or user-defined)",
              "type. If the type always has the same number of bytes, then",
              "itemsize is ignored. Otherwise, itemsize specifies the particular",
              "size of this array."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "If data is passed to "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": "c",
                        "role": "func",
                        "value": "PyArray_NewFromDescr"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " or "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": "c",
                        "role": "func",
                        "value": "PyArray_New"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": ", this memory must not be deallocated until the new array is deleted.  If this data came from another Python object, this can be accomplished using "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": "c",
                        "role": "func",
                        "value": "Py_INCREF"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " on that object and setting the base member of the new array to point to that object. If strides are passed in they must be consistent with the dimensions, the itemsize, and the data of the array."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ],
            "kind": "warning",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_SimpleNew(int nd, npy_intp const* dims, int typenum)",
            "content": "Create a new uninitialized array of type, *typenum*, whose size in\neach of *nd* dimensions is given by the integer array, *dims*.The memory\nfor the array is uninitialized (unless typenum is :c:data:`NPY_OBJECT`\nin which case each element in the array is set to NULL). The\n*typenum* argument allows specification of any of the builtin\ndata-types such as :c:data:`NPY_FLOAT` or :c:data:`NPY_LONG`. The\nmemory for the array can be set to zero if desired using\n:c:func:`PyArray_FILLWBYTE` (return_object, 0).This function cannot be\nused to create a flexible-type array (no itemsize given).",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_SimpleNewFromData( \\",
            "content": "int nd, npy_intp const* dims, int typenum, void* data)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Create an array wrapper around *data* pointed to by the given",
              "pointer. The array flags will have a default that the data area is",
              "well-behaved and C-style contiguous. The shape of the array is",
              "given by the *dims* c-array of length *nd*. The data-type of the",
              "array is indicated by *typenum*. If data comes from another",
              "reference-counted Python object, the reference count on this object",
              "should be increased after the pointer is passed in, and the base member",
              "of the returned ndarray should point to the Python object that owns",
              "the data. This will ensure that the provided memory is not",
              "freed while the returned array is in existence."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_SimpleNewFromDescr( \\",
            "content": "int nd, npy_int const* dims, PyArray_Descr* descr)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "This function steals a reference to *descr*.",
              "",
              "Create a new array with the provided data-type descriptor, *descr*,",
              "of the shape determined by *nd* and *dims*."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "void PyArray_FILLWBYTE(PyObject* obj, int val)",
            "content": "Fill the array pointed to by *obj* ---which must be a (subclass\nof) ndarray---with the contents of *val* (evaluated as a byte).\nThis macro calls memset, so obj must be contiguous.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Zeros( \\",
            "content": "int nd, npy_intp const* dims, PyArray_Descr* dtype, int fortran)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Construct a new *nd* -dimensional array with shape given by *dims*",
              "and data type given by *dtype*. If *fortran* is non-zero, then a",
              "Fortran-order array is created, otherwise a C-order array is",
              "created. Fill the memory with zeros (or the 0 object if *dtype*",
              "corresponds to :c:type:`NPY_OBJECT` )."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_ZEROS( \\",
            "content": "int nd, npy_intp const* dims, int type_num, int fortran)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Macro form of :c:func:`PyArray_Zeros` which takes a type-number instead",
              "of a data-type object."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Empty( \\",
            "content": "int nd, npy_intp const* dims, PyArray_Descr* dtype, int fortran)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Construct a new *nd* -dimensional array with shape given by *dims*",
              "and data type given by *dtype*. If *fortran* is non-zero, then a",
              "Fortran-order array is created, otherwise a C-order array is",
              "created. The array is uninitialized unless the data type",
              "corresponds to :c:type:`NPY_OBJECT` in which case the array is",
              "filled with :c:data:`Py_None`."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_EMPTY( \\",
            "content": "int nd, npy_intp const* dims, int typenum, int fortran)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Macro form of :c:func:`PyArray_Empty` which takes a type-number,",
              "*typenum*, instead of a data-type object."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Arange( \\",
            "content": "double start, double stop, double step, int typenum)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Construct a new 1-dimensional array of data-type, *typenum*, that",
              "ranges from *start* to *stop* (exclusive) in increments of *step*",
              ". Equivalent to **arange** (*start*, *stop*, *step*, dtype)."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_ArangeObj( \\",
            "content": "PyObject* start, PyObject* stop, PyObject* step, PyArray_Descr* descr)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Construct a new 1-dimensional array of data-type determined by",
              "``descr``, that ranges from ``start`` to ``stop`` (exclusive) in",
              "increments of ``step``. Equivalent to arange( ``start``,",
              "``stop``, ``step``, ``typenum`` )."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArray_SetBaseObject(PyArrayObject* arr, PyObject* obj)",
            "content": ".. versionadded:: 1.7\n\nThis function **steals a reference** to ``obj`` and sets it as the\nbase property of ``arr``.\n\nIf you construct an array by passing in your own memory buffer as\na parameter, you need to set the array's `base` property to ensure\nthe lifetime of the memory buffer is appropriate.\n\nThe return value is 0 on success, -1 on failure.\n\nIf the object provided is an array, this function traverses the\nchain of `base` pointers so that each array points to the owner\nof the memory directly. Once the base is set, it may not be changed\nto another value.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "From scratch"
    },
    {
      "children": [
        {
          "data": {
            "argument": "PyObject* PyArray_FromAny( \\",
            "content": "PyObject* op, PyArray_Descr* dtype, int min_depth, int max_depth, \\\nint requirements, PyObject* context)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "This is the main function used to obtain an array from any nested",
              "sequence, or object that exposes the array interface, *op*. The",
              "parameters allow specification of the required *dtype*, the",
              "minimum (*min_depth*) and maximum (*max_depth*) number of",
              "dimensions acceptable, and other *requirements* for the array. This",
              "function **steals a reference** to the dtype argument, which needs",
              "to be a :c:type:`PyArray_Descr` structure",
              "indicating the desired data-type (including required",
              "byteorder). The *dtype* argument may be ``NULL``, indicating that any",
              "data-type (and byteorder) is acceptable. Unless",
              ":c:data:`NPY_ARRAY_FORCECAST` is present in ``flags``,",
              "this call will generate an error if the data",
              "type cannot be safely obtained from the object. If you want to use",
              "``NULL`` for the *dtype* and ensure the array is notswapped then",
              "use :c:func:`PyArray_CheckFromAny`. A value of 0 for either of the",
              "depth parameters causes the parameter to be ignored. Any of the",
              "following array flags can be added (*e.g.* using \\|) to get the",
              "*requirements* argument. If your code can handle general (*e.g.*",
              "strided, byte-swapped, or unaligned arrays) then *requirements*",
              "may be 0. Also, if *op* is not already an array (or does not",
              "expose the array interface), then a new array will be created (and",
              "filled from *op* using the sequence protocol). The new array will",
              "have :c:data:`NPY_ARRAY_DEFAULT` as its flags member. The *context*",
              "argument is unused.",
              "",
              ".. c:macro:: NPY_ARRAY_C_CONTIGUOUS",
              "",
              "    Make sure the returned array is C-style contiguous",
              "",
              ".. c:macro:: NPY_ARRAY_F_CONTIGUOUS",
              "",
              "    Make sure the returned array is Fortran-style contiguous.",
              "",
              ".. c:macro:: NPY_ARRAY_ALIGNED",
              "",
              "    Make sure the returned array is aligned on proper boundaries for its",
              "    data type. An aligned array has the data pointer and every strides",
              "    factor as a multiple of the alignment factor for the data-type-",
              "    descriptor.",
              "",
              ".. c:macro:: NPY_ARRAY_WRITEABLE",
              "",
              "    Make sure the returned array can be written to.",
              "",
              ".. c:macro:: NPY_ARRAY_ENSURECOPY",
              "",
              "    Make sure a copy is made of *op*. If this flag is not",
              "    present, data is not copied if it can be avoided.",
              "",
              ".. c:macro:: NPY_ARRAY_ENSUREARRAY",
              "",
              "    Make sure the result is a base-class ndarray. By",
              "    default, if *op* is an instance of a subclass of",
              "    ndarray, an instance of that same subclass is returned. If",
              "    this flag is set, an ndarray object will be returned instead.",
              "",
              ".. c:macro:: NPY_ARRAY_FORCECAST",
              "",
              "    Force a cast to the output type even if it cannot be done",
              "    safely.  Without this flag, a data cast will occur only if it",
              "    can be done safely, otherwise an error is raised.",
              "",
              ".. c:macro:: NPY_ARRAY_WRITEBACKIFCOPY",
              "",
              "    If *op* is already an array, but does not satisfy the",
              "    requirements, then a copy is made (which will satisfy the",
              "    requirements). If this flag is present and a copy (of an object",
              "    that is already an array) must be made, then the corresponding",
              "    :c:data:`NPY_ARRAY_WRITEBACKIFCOPY` flag is set in the returned",
              "    copy and *op* is made to be read-only. You must be sure to call",
              "    :c:func:`PyArray_ResolveWritebackIfCopy` to copy the contents",
              "    back into *op* and the *op* array",
              "    will be made writeable again. If *op* is not writeable to begin",
              "    with, or if it is not already an array, then an error is raised.",
              "",
              ".. c:macro:: NPY_ARRAY_BEHAVED",
              "",
              "    :c:data:`NPY_ARRAY_ALIGNED` \\| :c:data:`NPY_ARRAY_WRITEABLE`",
              "",
              ".. c:macro:: NPY_ARRAY_CARRAY",
              "",
              "    :c:data:`NPY_ARRAY_C_CONTIGUOUS` \\| :c:data:`NPY_ARRAY_BEHAVED`",
              "",
              ".. c:macro:: NPY_ARRAY_CARRAY_RO",
              "",
              "    :c:data:`NPY_ARRAY_C_CONTIGUOUS` \\| :c:data:`NPY_ARRAY_ALIGNED`",
              "",
              ".. c:macro:: NPY_ARRAY_FARRAY",
              "",
              "    :c:data:`NPY_ARRAY_F_CONTIGUOUS` \\| :c:data:`NPY_ARRAY_BEHAVED`",
              "",
              ".. c:macro:: NPY_ARRAY_FARRAY_RO",
              "",
              "    :c:data:`NPY_ARRAY_F_CONTIGUOUS` \\| :c:data:`NPY_ARRAY_ALIGNED`",
              "",
              ".. c:macro:: NPY_ARRAY_DEFAULT",
              "",
              "    :c:data:`NPY_ARRAY_CARRAY`"
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "value": "..\n  dedented to allow internal linking, pending a refactoring"
          },
          "type": "Comment"
        },
        {
          "data": {
            "argument": "NPY_ARRAY_IN_ARRAY",
            "content": ":c:data:`NPY_ARRAY_C_CONTIGUOUS` \\| :c:data:`NPY_ARRAY_ALIGNED`\n\n.. c:macro:: NPY_ARRAY_IN_FARRAY\n\n    :c:data:`NPY_ARRAY_F_CONTIGUOUS` \\| :c:data:`NPY_ARRAY_ALIGNED`",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_OUT_ARRAY",
            "content": ":c:data:`NPY_ARRAY_C_CONTIGUOUS` \\| :c:data:`NPY_ARRAY_WRITEABLE` \\|\n:c:data:`NPY_ARRAY_ALIGNED`",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_ARRAY_OUT_ARRAY",
            "content": ":c:data:`NPY_ARRAY_C_CONTIGUOUS` \\| :c:data:`NPY_ARRAY_ALIGNED` \\|\n:c:data:`NPY_ARRAY_WRITEABLE`\n\n.. c:macro:: NPY_ARRAY_OUT_FARRAY\n\n    :c:data:`NPY_ARRAY_F_CONTIGUOUS` \\| :c:data:`NPY_ARRAY_WRITEABLE` \\|\n    :c:data:`NPY_ARRAY_ALIGNED`",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": "..\n  dedented to allow internal linking, pending a refactoring"
          },
          "type": "Comment"
        },
        {
          "data": {
            "argument": "NPY_ARRAY_INOUT_ARRAY",
            "content": ":c:data:`NPY_ARRAY_C_CONTIGUOUS` \\| :c:data:`NPY_ARRAY_WRITEABLE` \\|\n:c:data:`NPY_ARRAY_ALIGNED` \\| :c:data:`NPY_ARRAY_WRITEBACKIFCOPY`\n\n.. c:macro:: NPY_ARRAY_INOUT_FARRAY\n\n    :c:data:`NPY_ARRAY_F_CONTIGUOUS` \\| :c:data:`NPY_ARRAY_WRITEABLE` \\|\n    :c:data:`NPY_ARRAY_ALIGNED` \\| :c:data:`NPY_ARRAY_WRITEBACKIFCOPY`",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_GetArrayParamsFromObject( \\",
            "content": "PyObject* op, PyArray_Descr* requested_dtype, npy_bool writeable, \\\nPyArray_Descr** out_dtype, int* out_ndim, npy_intp* out_dims, \\\nPyArrayObject** out_arr, PyObject* context)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              ".. deprecated:: NumPy 1.19",
              "",
              "    Unless NumPy is made aware of an issue with this, this function",
              "    is scheduled for rapid removal without replacement.",
              "",
              ".. versionchanged:: NumPy 1.19",
              "",
              "    `context` is never used. Its use results in an error.",
              "",
              ".. versionadded:: 1.6"
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_CheckFromAny( \\",
            "content": "PyObject* op, PyArray_Descr* dtype, int min_depth, int max_depth, \\\nint requirements, PyObject* context)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Nearly identical to :c:func:`PyArray_FromAny` (...) except",
              "*requirements* can contain :c:data:`NPY_ARRAY_NOTSWAPPED` (over-riding the",
              "specification in *dtype*) and :c:data:`NPY_ARRAY_ELEMENTSTRIDES` which",
              "indicates that the array should be aligned in the sense that the",
              "strides are multiples of the element size.",
              "",
              "In versions 1.6 and earlier of NumPy, the following flags",
              "did not have the _ARRAY_ macro namespace in them. That form",
              "of the constant names is deprecated in 1.7."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "value": "..\n  dedented to allow internal linking, pending a refactoring"
          },
          "type": "Comment"
        },
        {
          "data": {
            "argument": "NPY_ARRAY_NOTSWAPPED",
            "content": "Make sure the returned array has a data-type descriptor that is in\nmachine byte-order, over-riding any specification in the *dtype*\nargument. Normally, the byte-order requirement is determined by\nthe *dtype* argument. If this flag is set and the dtype argument\ndoes not indicate a machine byte-order descriptor (or is NULL and\nthe object is already an array with a data-type descriptor that is\nnot in machine byte- order), then a new data-type descriptor is\ncreated and used with its byte-order field set to native.\n\n.. c:macro:: NPY_ARRAY_BEHAVED_NS\n\n    :c:data:`NPY_ARRAY_ALIGNED` \\| :c:data:`NPY_ARRAY_WRITEABLE` \\|\n    :c:data:`NPY_ARRAY_NOTSWAPPED`",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": "..\n  dedented to allow internal linking, pending a refactoring"
          },
          "type": "Comment"
        },
        {
          "data": {
            "argument": "NPY_ARRAY_ELEMENTSTRIDES",
            "content": "Make sure the returned array has strides that are multiples of the\nelement size.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_FromArray( \\",
            "content": "PyArrayObject* op, PyArray_Descr* newtype, int requirements)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Special case of :c:func:`PyArray_FromAny` for when *op* is already an",
              "array but it needs to be of a specific *newtype* (including",
              "byte-order) or has certain *requirements*."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_FromStructInterface(PyObject* op)",
            "content": "Returns an ndarray object from a Python object that exposes the\n:obj:`~object.__array_struct__` attribute and follows the array interface\nprotocol. If the object does not contain this attribute then a\nborrowed reference to :c:data:`Py_NotImplemented` is returned.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_FromInterface(PyObject* op)",
            "content": "Returns an ndarray object from a Python object that exposes the\n:obj:`~object.__array_interface__` attribute following the array interface\nprotocol. If the object does not contain this attribute then a\nborrowed reference to :c:data:`Py_NotImplemented` is returned.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_FromArrayAttr( \\",
            "content": "PyObject* op, PyArray_Descr* dtype, PyObject* context)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Return an ndarray object from a Python object that exposes the",
              ":obj:`~numpy.class.__array__` method. The :obj:`~numpy.class.__array__`",
              "method can take 0, or 1 argument ``([dtype])``. ``context`` is unused."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_ContiguousFromAny( \\",
            "content": "PyObject* op, int typenum, int min_depth, int max_depth)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "This function returns a (C-style) contiguous and behaved function",
              "array from any nested sequence or array interface exporting",
              "object, *op*, of (non-flexible) type given by the enumerated",
              "*typenum*, of minimum depth *min_depth*, and of maximum depth",
              "*max_depth*. Equivalent to a call to :c:func:`PyArray_FromAny` with",
              "requirements set to :c:data:`NPY_ARRAY_DEFAULT` and the type_num member of the",
              "type argument set to *typenum*."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_ContiguousFromObject( \\",
            "content": "PyObject* op, int typenum, int min_depth, int max_depth)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "This function returns a well-behaved C-style contiguous array from any nested",
              "sequence or array-interface exporting object. The minimum number of dimensions",
              "the array can have is given by `min_depth` while the maximum is `max_depth`.",
              "This is equivalent to call :c:func:`PyArray_FromAny` with requirements",
              ":c:data:`NPY_ARRAY_DEFAULT` and :c:data:`NPY_ARRAY_ENSUREARRAY`."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_FromObject( \\",
            "content": "PyObject* op, int typenum, int min_depth, int max_depth)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Return an aligned and in native-byteorder array from any nested",
              "sequence or array-interface exporting object, op, of a type given by",
              "the enumerated typenum. The minimum number of dimensions the array can",
              "have is given by min_depth while the maximum is max_depth. This is",
              "equivalent to a call to :c:func:`PyArray_FromAny` with requirements set to",
              "BEHAVED."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_EnsureArray(PyObject* op)",
            "content": "This function **steals a reference** to ``op`` and makes sure that\n``op`` is a base-class ndarray. It special cases array scalars,\nbut otherwise calls :c:func:`PyArray_FromAny` ( ``op``, NULL, 0, 0,\n:c:data:`NPY_ARRAY_ENSUREARRAY`, NULL).",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_FromString( \\",
            "content": "char* string, npy_intp slen, PyArray_Descr* dtype, npy_intp num, \\\nchar* sep)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Construct a one-dimensional ndarray of a single type from a binary",
              "or (ASCII) text ``string`` of length ``slen``. The data-type of",
              "the array to-be-created is given by ``dtype``. If num is -1, then",
              "**copy** the entire string and return an appropriately sized",
              "array, otherwise, ``num`` is the number of items to **copy** from",
              "the string. If ``sep`` is NULL (or \"\"), then interpret the string",
              "as bytes of binary data, otherwise convert the sub-strings",
              "separated by ``sep`` to items of data-type ``dtype``. Some",
              "data-types may not be readable in text mode and an error will be",
              "raised if that occurs. All errors return NULL."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_FromFile( \\",
            "content": "FILE* fp, PyArray_Descr* dtype, npy_intp num, char* sep)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Construct a one-dimensional ndarray of a single type from a binary",
              "or text file. The open file pointer is ``fp``, the data-type of",
              "the array to be created is given by ``dtype``. This must match",
              "the data in the file. If ``num`` is -1, then read until the end of",
              "the file and return an appropriately sized array, otherwise,",
              "``num`` is the number of items to read. If ``sep`` is NULL (or",
              "\"\"), then read from the file in binary mode, otherwise read from",
              "the file in text mode with ``sep`` providing the item",
              "separator. Some array types cannot be read in text mode in which",
              "case an error is raised."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_FromBuffer( \\",
            "content": "PyObject* buf, PyArray_Descr* dtype, npy_intp count, npy_intp offset)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Construct a one-dimensional ndarray of a single type from an",
              "object, ``buf``, that exports the (single-segment) buffer protocol",
              "(or has an attribute __buffer\\__ that returns an object that",
              "exports the buffer protocol). A writeable buffer will be tried",
              "first followed by a read- only buffer. The :c:data:`NPY_ARRAY_WRITEABLE`",
              "flag of the returned array will reflect which one was",
              "successful. The data is assumed to start at ``offset`` bytes from",
              "the start of the memory location for the object. The type of the",
              "data in the buffer will be interpreted depending on the data- type",
              "descriptor, ``dtype.`` If ``count`` is negative then it will be",
              "determined from the size of the buffer and the requested itemsize,",
              "otherwise, ``count`` represents how many elements should be",
              "converted from the buffer."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArray_CopyInto(PyArrayObject* dest, PyArrayObject* src)",
            "content": "Copy from the source array, ``src``, into the destination array,\n``dest``, performing a data-type conversion if necessary. If an\nerror occurs return -1 (otherwise 0). The shape of ``src`` must be\nbroadcastable to the shape of ``dest``. The data areas of dest\nand src must not overlap.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_CopyObject(PyArrayObject* dest, PyObject* src)",
            "content": "Assign an object ``src`` to a NumPy array ``dest`` according to\narray-coercion rules. This is basically identical to\n:c:func:`PyArray_FromAny`, but assigns directly to the output array.\nReturns 0 on success and -1 on failures.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_MoveInto(PyArrayObject* dest, PyArrayObject* src)",
            "content": "Move data from the source array, ``src``, into the destination\narray, ``dest``, performing a data-type conversion if\nnecessary. If an error occurs return -1 (otherwise 0). The shape\nof ``src`` must be broadcastable to the shape of ``dest``. The\ndata areas of dest and src may overlap.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyArrayObject* PyArray_GETCONTIGUOUS(PyObject* op)",
            "content": "If ``op`` is already (C-style) contiguous and well-behaved then\njust return a reference, otherwise return a (contiguous and\nwell-behaved) copy of the array. The parameter op must be a\n(sub-class of an) ndarray and no checking for that is done.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_FROM_O(PyObject* obj)",
            "content": "Convert ``obj`` to an ndarray. The argument can be any nested\nsequence or object that exports the array interface. This is a\nmacro form of :c:func:`PyArray_FromAny` using ``NULL``, 0, 0, 0 for the\nother arguments. Your code must be able to handle any data-type\ndescriptor and any combination of data-flags to use this macro.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_FROM_OF(PyObject* obj, int requirements)",
            "content": "Similar to :c:func:`PyArray_FROM_O` except it can take an argument\nof *requirements* indicating properties the resulting array must\nhave. Available requirements that can be enforced are\n:c:data:`NPY_ARRAY_C_CONTIGUOUS`, :c:data:`NPY_ARRAY_F_CONTIGUOUS`,\n:c:data:`NPY_ARRAY_ALIGNED`, :c:data:`NPY_ARRAY_WRITEABLE`,\n:c:data:`NPY_ARRAY_NOTSWAPPED`, :c:data:`NPY_ARRAY_ENSURECOPY`,\n:c:data:`NPY_ARRAY_WRITEBACKIFCOPY`, :c:data:`NPY_ARRAY_FORCECAST`, and\n:c:data:`NPY_ARRAY_ENSUREARRAY`. Standard combinations of flags can also\nbe used:",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_FROM_OT(PyObject* obj, int typenum)",
            "content": "Similar to :c:func:`PyArray_FROM_O` except it can take an argument of\n*typenum* specifying the type-number the returned array.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_FROM_OTF( \\",
            "content": "PyObject* obj, int typenum, int requirements)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Combination of :c:func:`PyArray_FROM_OF` and :c:func:`PyArray_FROM_OT`",
              "allowing both a *typenum* and a *flags* argument to be provided."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_FROMANY( \\",
            "content": "PyObject* obj, int typenum, int min, int max, int requirements)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Similar to :c:func:`PyArray_FromAny` except the data-type is",
              "specified using a typenumber. :c:func:`PyArray_DescrFromType`",
              "(*typenum*) is passed directly to :c:func:`PyArray_FromAny`. This",
              "macro also adds :c:data:`NPY_ARRAY_DEFAULT` to requirements if",
              ":c:data:`NPY_ARRAY_ENSURECOPY` is passed in as requirements."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject *PyArray_CheckAxis( \\",
            "content": "PyObject* obj, int* axis, int requirements)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Encapsulate the functionality of functions and methods that take",
              "the axis= keyword and work properly with None as the axis",
              "argument. The input array is ``obj``, while ``*axis`` is a",
              "converted integer (so that >=MAXDIMS is the None value), and",
              "``requirements`` gives the needed properties of ``obj``. The",
              "output is a converted version of the input so that requirements",
              "are met and if needed a flattening has occurred. On output",
              "negative values of ``*axis`` are converted and the new value is",
              "checked to ensure consistency with the shape of ``obj``."
            ]
          },
          "type": "BlockQuote"
        }
      ],
      "title": "From other objects"
    },
    {
      "children": [],
      "title": "Dealing with types"
    },
    {
      "children": [
        {
          "data": {
            "argument": "int PyArray_Check(PyObject *op)",
            "content": "Evaluates true if *op* is a Python object whose type is a sub-type\nof :c:data:`PyArray_Type`.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_CheckExact(PyObject *op)",
            "content": "Evaluates true if *op* is a Python object with type\n:c:data:`PyArray_Type`.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_HasArrayInterface(PyObject *op, PyObject *out)",
            "content": "If ``op`` implements any part of the array interface, then ``out``\nwill contain a new reference to the newly created ndarray using\nthe interface or ``out`` will contain ``NULL`` if an error during\nconversion occurs. Otherwise, out will contain a borrowed\nreference to :c:data:`Py_NotImplemented` and no error condition is set.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_HasArrayInterfaceType(\\",
            "content": "PyObject *op, PyArray_Descr *dtype, PyObject *context, PyObject *out)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "If ``op`` implements any part of the array interface, then ``out``",
              "will contain a new reference to the newly created ndarray using",
              "the interface or ``out`` will contain ``NULL`` if an error during",
              "conversion occurs. Otherwise, out will contain a borrowed",
              "reference to Py_NotImplemented and no error condition is set.",
              "This version allows setting of the dtype in the part of the array interface",
              "that looks for the :obj:`~numpy.class.__array__` attribute. `context` is",
              "unused."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArray_IsZeroDim(PyObject *op)",
            "content": "Evaluates true if *op* is an instance of (a subclass of)\n:c:data:`PyArray_Type` and has 0 dimensions.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyArray_IsScalar(op, cls)",
            "content": "Evaluates true if *op* is an instance of ``Py{cls}ArrType_Type``.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_CheckScalar(PyObject *op)",
            "content": "Evaluates true if *op* is either an array scalar (an instance of a\nsub-type of :c:data:`PyGenericArr_Type` ), or an instance of (a\nsub-class of) :c:data:`PyArray_Type` whose dimensionality is 0.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_IsPythonNumber(PyObject *op)",
            "content": "Evaluates true if *op* is an instance of a builtin numeric type (int,\nfloat, complex, long, bool)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_IsPythonScalar(PyObject *op)",
            "content": "Evaluates true if *op* is a builtin Python scalar object (int,\nfloat, complex, bytes, str, long, bool).",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_IsAnyScalar(PyObject *op)",
            "content": "Evaluates true if *op* is either a Python scalar object (see\n:c:func:`PyArray_IsPythonScalar`) or an array scalar (an instance of a sub-\ntype of :c:data:`PyGenericArr_Type` ).",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_CheckAnyScalar(PyObject *op)",
            "content": "Evaluates true if *op* is a Python scalar object (see\n:c:func:`PyArray_IsPythonScalar`), an array scalar (an instance of a\nsub-type of :c:data:`PyGenericArr_Type`) or an instance of a sub-type of\n:c:data:`PyArray_Type` whose dimensionality is 0.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "General check of Python Type"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "For the typenum macros, the argument is an integer representing an enumerated array data type. For the array type checking macros the argument must be a "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyObject *"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " that can be directly interpreted as a "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArrayObject *"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "int PyTypeNum_ISUNSIGNED(int num)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyDataType_ISUNSIGNED(PyArray_Descr *descr)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISUNSIGNED(PyArrayObject *obj)",
            "content": "Type represents an unsigned integer.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyTypeNum_ISSIGNED(int num)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyDataType_ISSIGNED(PyArray_Descr *descr)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISSIGNED(PyArrayObject *obj)",
            "content": "Type represents a signed integer.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyTypeNum_ISINTEGER(int num)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyDataType_ISINTEGER(PyArray_Descr* descr)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISINTEGER(PyArrayObject *obj)",
            "content": "Type represents any integer.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyTypeNum_ISFLOAT(int num)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyDataType_ISFLOAT(PyArray_Descr* descr)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISFLOAT(PyArrayObject *obj)",
            "content": "Type represents any floating point number.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyTypeNum_ISCOMPLEX(int num)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyDataType_ISCOMPLEX(PyArray_Descr* descr)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISCOMPLEX(PyArrayObject *obj)",
            "content": "Type represents any complex floating point number.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyTypeNum_ISNUMBER(int num)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyDataType_ISNUMBER(PyArray_Descr* descr)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISNUMBER(PyArrayObject *obj)",
            "content": "Type represents any integer, floating point, or complex floating point\nnumber.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyTypeNum_ISSTRING(int num)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyDataType_ISSTRING(PyArray_Descr* descr)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISSTRING(PyArrayObject *obj)",
            "content": "Type represents a string data type.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyTypeNum_ISPYTHON(int num)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyDataType_ISPYTHON(PyArray_Descr* descr)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISPYTHON(PyArrayObject *obj)",
            "content": "Type represents an enumerated type corresponding to one of the\nstandard Python scalar (bool, int, float, or complex).",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyTypeNum_ISFLEXIBLE(int num)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyDataType_ISFLEXIBLE(PyArray_Descr* descr)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISFLEXIBLE(PyArrayObject *obj)",
            "content": "Type represents one of the flexible array types ( :c:data:`NPY_STRING`,\n:c:data:`NPY_UNICODE`, or :c:data:`NPY_VOID` ).",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyDataType_ISUNSIZED(PyArray_Descr* descr)",
            "content": "Type has no size information attached, and can be resized. Should only be\ncalled on flexible dtypes. Types that are attached to an array will always\nbe sized, hence the array form of this macro not existing.\n\n.. versionchanged:: 1.18\n\nFor structured datatypes with no fields this function now returns False.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyTypeNum_ISUSERDEF(int num)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyDataType_ISUSERDEF(PyArray_Descr* descr)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISUSERDEF(PyArrayObject *obj)",
            "content": "Type represents a user-defined type.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyTypeNum_ISEXTENDED(int num)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyDataType_ISEXTENDED(PyArray_Descr* descr)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISEXTENDED(PyArrayObject *obj)",
            "content": "Type is either flexible or user-defined.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyTypeNum_ISOBJECT(int num)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyDataType_ISOBJECT(PyArray_Descr* descr)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISOBJECT(PyArrayObject *obj)",
            "content": "Type represents object data type.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyTypeNum_ISBOOL(int num)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyDataType_ISBOOL(PyArray_Descr* descr)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISBOOL(PyArrayObject *obj)",
            "content": "Type represents Boolean data type.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyDataType_HASFIELDS(PyArray_Descr* descr)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_HASFIELDS(PyArrayObject *obj)",
            "content": "Type has fields associated with it.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISNOTSWAPPED(PyArrayObject *m)",
            "content": "Evaluates true if the data area of the ndarray *m* is in machine\nbyte-order according to the array's data-type descriptor.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISBYTESWAPPED(PyArrayObject *m)",
            "content": "Evaluates true if the data area of the ndarray *m* is **not** in\nmachine byte-order according to the array's data-type descriptor.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "npy_bool PyArray_EquivTypes( \\",
            "content": "PyArray_Descr* type1, PyArray_Descr* type2)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Return :c:data:`NPY_TRUE` if *type1* and *type2* actually represent",
              "equivalent types for this platform (the fortran member of each",
              "type is ignored). For example, on 32-bit platforms,",
              ":c:data:`NPY_LONG` and :c:data:`NPY_INT` are equivalent. Otherwise",
              "return :c:data:`NPY_FALSE`."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "npy_bool PyArray_EquivArrTypes( \\",
            "content": "PyArrayObject* a1, PyArrayObject * a2)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Return :c:data:`NPY_TRUE` if *a1* and *a2* are arrays with equivalent",
              "types for this platform."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "npy_bool PyArray_EquivTypenums(int typenum1, int typenum2)",
            "content": "Special case of :c:func:`PyArray_EquivTypes` (...) that does not accept\nflexible data types but may be easier to call.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_EquivByteorders(int b1, int b2)",
            "content": "True if byteorder characters *b1* and *b2* ( :c:data:`NPY_LITTLE`,\n:c:data:`NPY_BIG`, :c:data:`NPY_NATIVE`, :c:data:`NPY_IGNORE` ) are\neither equal or equivalent as to their specification of a native\nbyte order. Thus, on a little-endian machine :c:data:`NPY_LITTLE`\nand :c:data:`NPY_NATIVE` are equivalent where they are not\nequivalent on a big-endian machine.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Data-type checking"
    },
    {
      "children": [
        {
          "data": {
            "argument": "PyObject* PyArray_Cast(PyArrayObject* arr, int typenum)",
            "content": "Mainly for backwards compatibility to the Numeric C-API and for\nsimple casts to non-flexible types. Return a new array object with\nthe elements of *arr* cast to the data-type *typenum* which must\nbe one of the enumerated types and not a flexible type.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_CastToType( \\",
            "content": "PyArrayObject* arr, PyArray_Descr* type, int fortran)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Return a new array of the *type* specified, casting the elements",
              "of *arr* as appropriate. The fortran argument specifies the",
              "ordering of the output array."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArray_CastTo(PyArrayObject* out, PyArrayObject* in)",
            "content": "As of 1.6, this function simply calls :c:func:`PyArray_CopyInto`,\nwhich handles the casting.\n\nCast the elements of the array *in* into the array *out*. The\noutput array should be writeable, have an integer-multiple of the\nnumber of elements in the input array (more than one copy can be\nplaced in out), and have a data type that is one of the builtin\ntypes.  Returns 0 on success and -1 if an error occurs.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyArray_VectorUnaryFunc* PyArray_GetCastFunc( \\",
            "content": "PyArray_Descr* from, int totype)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Return the low-level casting function to cast from the given",
              "descriptor to the builtin type number. If no casting function",
              "exists return ``NULL`` and set an error. Using this function",
              "instead of direct access to *from* ->f->cast will allow support of",
              "any user-defined casting functions added to a descriptors casting",
              "dictionary."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArray_CanCastSafely(int fromtype, int totype)",
            "content": "Returns non-zero if an array of data type *fromtype* can be cast\nto an array of data type *totype* without losing information. An\nexception is that 64-bit integers are allowed to be cast to 64-bit\nfloating point values even though this can lose precision on large\nintegers so as not to proliferate the use of long doubles without\nexplicit requests. Flexible array types are not checked according\nto their lengths with this function.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_CanCastTo( \\",
            "content": "PyArray_Descr* fromtype, PyArray_Descr* totype)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              ":c:func:`PyArray_CanCastTypeTo` supersedes this function in",
              "NumPy 1.6 and later.",
              "",
              "Equivalent to PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING)."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArray_CanCastTypeTo( \\",
            "content": "PyArray_Descr* fromtype, PyArray_Descr* totype, NPY_CASTING casting)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              ".. versionadded:: 1.6",
              "",
              "Returns non-zero if an array of data type *fromtype* (which can",
              "include flexible types) can be cast safely to an array of data",
              "type *totype* (which can include flexible types) according to",
              "the casting rule *casting*. For simple types with :c:data:`NPY_SAFE_CASTING`,",
              "this is basically a wrapper around :c:func:`PyArray_CanCastSafely`, but",
              "for flexible types such as strings or unicode, it produces results",
              "taking into account their sizes. Integer and float types can only be cast",
              "to a string or unicode type using :c:data:`NPY_SAFE_CASTING` if the string",
              "or unicode type is big enough to hold the max value of the integer/float",
              "type being cast from."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArray_CanCastArrayTo( \\",
            "content": "PyArrayObject* arr, PyArray_Descr* totype, NPY_CASTING casting)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              ".. versionadded:: 1.6",
              "",
              "Returns non-zero if *arr* can be cast to *totype* according",
              "to the casting rule given in *casting*.  If *arr* is an array",
              "scalar, its value is taken into account, and non-zero is also",
              "returned when the value will not overflow or be truncated to",
              "an integer when converting to a smaller type.",
              "",
              "This is almost the same as the result of",
              "PyArray_CanCastTypeTo(PyArray_MinScalarType(arr), totype, casting),",
              "but it also handles a special case arising because the set",
              "of uint values is not a subset of the int values for types with the",
              "same number of bits."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyArray_Descr* PyArray_MinScalarType(PyArrayObject* arr)",
            "content": ".. versionadded:: 1.6\n\nIf *arr* is an array, returns its data type descriptor, but if\n*arr* is an array scalar (has 0 dimensions), it finds the data type\nof smallest size to which the value may be converted\nwithout overflow or truncation to an integer.\n\nThis function will not demote complex to float or anything to\nboolean, but will demote a signed integer to an unsigned integer\nwhen the scalar value is positive.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyArray_Descr* PyArray_PromoteTypes( \\",
            "content": "PyArray_Descr* type1, PyArray_Descr* type2)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              ".. versionadded:: 1.6",
              "",
              "Finds the data type of smallest size and kind to which *type1* and",
              "*type2* may be safely converted. This function is symmetric and",
              "associative. A string or unicode result will be the proper size for",
              "storing the max value of the input types converted to a string or unicode."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyArray_Descr* PyArray_ResultType( \\",
            "content": "npy_intp narrs, PyArrayObject **arrs, npy_intp ndtypes, \\\nPyArray_Descr **dtypes)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              ".. versionadded:: 1.6",
              "",
              "This applies type promotion to all the inputs,",
              "using the NumPy rules for combining scalars and arrays, to",
              "determine the output type of a set of operands.  This is the",
              "same result type that ufuncs produce. The specific algorithm",
              "used is as follows.",
              "",
              "Categories are determined by first checking which of boolean,",
              "integer (int/uint), or floating point (float/complex) the maximum",
              "kind of all the arrays and the scalars are.",
              "",
              "If there are only scalars or the maximum category of the scalars",
              "is higher than the maximum category of the arrays,",
              "the data types are combined with :c:func:`PyArray_PromoteTypes`",
              "to produce the return value.",
              "",
              "Otherwise, PyArray_MinScalarType is called on each array, and",
              "the resulting data types are all combined with",
              ":c:func:`PyArray_PromoteTypes` to produce the return value.",
              "",
              "The set of int values is not a subset of the uint values for types",
              "with the same number of bits, something not reflected in",
              ":c:func:`PyArray_MinScalarType`, but handled as a special case in",
              "PyArray_ResultType."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArray_ObjectType(PyObject* op, int mintype)",
            "content": "This function is superseded by :c:func:`PyArray_MinScalarType` and/or\n:c:func:`PyArray_ResultType`.\n\nThis function is useful for determining a common type that two or\nmore arrays can be converted to. It only works for non-flexible\narray types as no itemsize information is passed. The *mintype*\nargument represents the minimum type acceptable, and *op*\nrepresents the object that will be converted to an array. The\nreturn value is the enumerated typenumber that represents the\ndata-type that *op* should have.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void PyArray_ArrayType( \\",
            "content": "PyObject* op, PyArray_Descr* mintype, PyArray_Descr* outtype)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "This function is superseded by :c:func:`PyArray_ResultType`.",
              "",
              "This function works similarly to :c:func:`PyArray_ObjectType` (...)",
              "except it handles flexible arrays. The *mintype* argument can have",
              "an itemsize member and the *outtype* argument will have an",
              "itemsize member at least as big but perhaps bigger depending on",
              "the object *op*."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyArrayObject** PyArray_ConvertToCommonType( \\",
            "content": "PyObject* op, int* n)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "The functionality this provides is largely superseded by iterator",
              ":c:type:`NpyIter` introduced in 1.6, with flag",
              ":c:data:`NPY_ITER_COMMON_DTYPE` or with the same dtype parameter for",
              "all operands.",
              "",
              "Convert a sequence of Python objects contained in *op* to an array",
              "of ndarrays each having the same data type. The type is selected",
              "in the same way as `PyArray_ResultType`. The length of the sequence is",
              "returned in *n*, and an *n* -length array of :c:type:`PyArrayObject`",
              "pointers is the return value (or ``NULL`` if an error occurs).",
              "The returned array must be freed by the caller of this routine",
              "(using :c:func:`PyDataMem_FREE` ) and all the array objects in it",
              "``DECREF`` 'd or a memory-leak will occur. The example template-code",
              "below shows a typically usage:",
              "",
              ".. versionchanged:: 1.18.0",
              "   A mix of scalars and zero-dimensional arrays now produces a type",
              "   capable of holding the scalar value.",
              "   Previously priority was given to the dtype of the arrays.",
              "",
              ".. code-block:: c",
              "",
              "    mps = PyArray_ConvertToCommonType(obj, &n);",
              "    if (mps==NULL) return NULL;",
              "    {code}",
              "    <before return>",
              "    for (i=0; i<n; i++) Py_DECREF(mps[i]);",
              "    PyDataMem_FREE(mps);",
              "    {return}"
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "char* PyArray_Zero(PyArrayObject* arr)",
            "content": "A pointer to newly created memory of size *arr* ->itemsize that\nholds the representation of 0 for that type. The returned pointer,\n*ret*, **must be freed** using :c:func:`PyDataMem_FREE` (ret) when it is\nnot needed anymore.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "char* PyArray_One(PyArrayObject* arr)",
            "content": "A pointer to newly created memory of size *arr* ->itemsize that\nholds the representation of 1 for that type. The returned pointer,\n*ret*, **must be freed** using :c:func:`PyDataMem_FREE` (ret) when it\nis not needed anymore.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ValidType(int typenum)",
            "content": "Returns :c:data:`NPY_TRUE` if *typenum* represents a valid type-number\n(builtin or user-defined or character code). Otherwise, this\nfunction returns :c:data:`NPY_FALSE`.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Converting data types"
    },
    {
      "children": [
        {
          "data": {
            "argument": "void PyArray_InitArrFuncs(PyArray_ArrFuncs* f)",
            "content": "Initialize all function pointers and members to ``NULL``.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_RegisterDataType(PyArray_Descr* dtype)",
            "content": "Register a data-type as a new user-defined data type for\narrays. The type must have most of its entries filled in. This is\nnot always checked and errors can produce segfaults. In\nparticular, the typeobj member of the ``dtype`` structure must be\nfilled with a Python type that has a fixed-size element-size that\ncorresponds to the elsize member of *dtype*. Also the ``f``\nmember must have the required functions: nonzero, copyswap,\ncopyswapn, getitem, setitem, and cast (some of the cast functions\nmay be ``NULL`` if no support is desired). To avoid confusion, you\nshould choose a unique character typecode but this is not enforced\nand not relied on internally.\n\nA user-defined type number is returned that uniquely identifies\nthe type. A pointer to the new structure can then be obtained from\n:c:func:`PyArray_DescrFromType` using the returned type number. A -1 is\nreturned if an error occurs.  If this *dtype* has already been\nregistered (checked only by the address of the pointer), then\nreturn the previously-assigned type-number.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_RegisterCastFunc( \\",
            "content": "PyArray_Descr* descr, int totype, PyArray_VectorUnaryFunc* castfunc)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Register a low-level casting function, *castfunc*, to convert",
              "from the data-type, *descr*, to the given data-type number,",
              "*totype*. Any old casting function is over-written. A ``0`` is",
              "returned on success or a ``-1`` on failure."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArray_RegisterCanCast( \\",
            "content": "PyArray_Descr* descr, int totype, NPY_SCALARKIND scalar)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Register the data-type number, *totype*, as castable from",
              "data-type object, *descr*, of the given *scalar* kind. Use",
              "*scalar* = :c:data:`NPY_NOSCALAR` to register that an array of data-type",
              "*descr* can be cast safely to a data-type whose type_number is",
              "*totype*. The return value is 0 on success or -1 on failure."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArray_TypeNumFromName( \\",
            "content": "char const *str)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Given a string return the type-number for the data-type with that string as",
              "the type-object name.",
              "Returns ``NPY_NOTYPE`` without setting an error if no type can be found.",
              "Only works for user-defined data-types."
            ]
          },
          "type": "BlockQuote"
        }
      ],
      "title": "User-defined data types"
    },
    {
      "children": [
        {
          "data": {
            "argument": "int PyArray_INCREF(PyArrayObject* op)",
            "content": "Used for an array, *op*, that contains any Python objects. It\nincrements the reference count of every object in the array\naccording to the data-type of *op*. A -1 is returned if an error\noccurs, otherwise 0 is returned.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void PyArray_Item_INCREF(char* ptr, PyArray_Descr* dtype)",
            "content": "A function to INCREF all the objects at the location *ptr*\naccording to the data-type *dtype*. If *ptr* is the start of a\nstructured type with an object at any offset, then this will (recursively)\nincrement the reference count of all object-like items in the\nstructured type.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_XDECREF(PyArrayObject* op)",
            "content": "Used for an array, *op*, that contains any Python objects. It\ndecrements the reference count of every object in the array\naccording to the data-type of *op*. Normal return value is 0. A\n-1 is returned if an error occurs.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void PyArray_Item_XDECREF(char* ptr, PyArray_Descr* dtype)",
            "content": "A function to XDECREF all the object-like items at the location\n*ptr* as recorded in the data-type, *dtype*. This works\nrecursively so that if ``dtype`` itself has fields with data-types\nthat contain object-like items, all the object-like fields will be\nXDECREF ``'d``.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void PyArray_FillObjectArray(PyArrayObject* arr, PyObject* obj)",
            "content": "Fill a newly created array with a single value obj at all\nlocations in the structure with object data-types. No checking is\nperformed but *arr* must be of data-type :c:type:`NPY_OBJECT` and be\nsingle-segment and uninitialized (no previous objects in\nposition). Use :c:func:`PyArray_XDECREF` (*arr*) if you need to\ndecrement all the items in the object array prior to calling this\nfunction.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_SetWritebackIfCopyBase(PyArrayObject* arr, PyArrayObject* base)",
            "content": "Precondition: ``arr`` is a copy of ``base`` (though possibly with different\nstrides, ordering, etc.) Sets the :c:data:`NPY_ARRAY_WRITEBACKIFCOPY` flag\nand ``arr->base``, and set ``base`` to READONLY. Call\n:c:func:`PyArray_ResolveWritebackIfCopy` before calling\n`Py_DECREF` in order copy any changes back to ``base`` and\nreset the READONLY flag.\n\nReturns 0 for success, -1 for failure.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "placeholder": "target",
            "value": ".. _array-flags:"
          },
          "type": "Unimplemented"
        }
      ],
      "title": "Special functions for NPY_OBJECT"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "flags"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " attribute of the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArrayObject"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " structure contains important information about the memory used by the array (pointed to by the data member) This flag information must be kept accurate or strange results and even segfaults may result."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "There are 6 (binary) flags that describe the memory area used by the data buffer.  These constants are defined in "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "arrayobject.h"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " and determine the bit-position of the flag.  Python exposes a nice attribute- based interface as well as a dictionary-like interface for getting (and, if appropriate, setting) these flags."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Memory areas of all kinds can be pointed to by an ndarray, necessitating these flags.  If you get an arbitrary "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArrayObject"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " in C-code, you need to be aware of the flags that are set.  If you need to guarantee a certain kind of array (like "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NPY_ARRAY_C_CONTIGUOUS"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NPY_ARRAY_BEHAVED"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "), then pass these requirements into the PyArray_FromAny function."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "title": "Array flags"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "An ndarray can have a data segment that is not a simple contiguous chunk of well-behaved memory you can manipulate. It may not be aligned with word boundaries (very important on some platforms). It might have its data in a different byte-order than the machine recognizes. It might not be writeable. It might be in Fortran-contiguous order. The array flags are used to indicate what can be said about data associated with an array."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_ macro namespace in them. That form of the constant names is deprecated in 1.7."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "NPY_ARRAY_C_CONTIGUOUS",
            "content": "The data area is in C-style contiguous order (last index varies the\nfastest).",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_ARRAY_F_CONTIGUOUS",
            "content": "The data area is in Fortran-style contiguous order (first index varies\nthe fastest).",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "Arrays can be both C-style and Fortran-style contiguous simultaneously. This is clear for 1-dimensional arrays, but can also be true for higher dimensional arrays."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "Even for contiguous arrays a stride for a given dimension "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "arr.strides[dim]"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " may be "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": {
                          "value": "arbitrary"
                        }
                      },
                      "type": "Emph"
                    },
                    {
                      "data": {
                        "value": " if "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "arr.shape[dim] == 1"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " or the array has no elements. It does "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": {
                          "value": "not"
                        }
                      },
                      "type": "Emph"
                    },
                    {
                      "data": {
                        "value": " generally hold that "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "self.strides[-1] == self.itemsize"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " for C-style contiguous arrays or "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "self.strides[0] == self.itemsize"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " for Fortran-style contiguous arrays is true. The correct way to access the "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "itemsize"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " of an array from the C API is "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "PyArray_ITEMSIZE(arr)"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": "."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "argument": ":ref:`Internal memory layout of an ndarray <arrays.ndarray>`",
                  "content": "",
                  "name": "seealso",
                  "options": []
                },
                "type": "BlockDirective"
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "argument": "NPY_ARRAY_OWNDATA",
            "content": "The data area is owned by this array. Should never be set manually, instead\ncreate a ``PyObject`` wrapping the data and set the array's base to that\nobject. For an example, see the test in ``test_mem_policy``.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_ARRAY_ALIGNED",
            "content": "The data area and all array elements are aligned appropriately.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_ARRAY_WRITEABLE",
            "content": "The data area can be written to.\n\nNotice that the above 3 flags are defined so that a new, well-\nbehaved array has these flags defined as true.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_ARRAY_WRITEBACKIFCOPY",
            "content": "The data area represents a (well-behaved) copy whose information\nshould be transferred back to the original when\n:c:func:`PyArray_ResolveWritebackIfCopy` is called.\n\nThis is a special flag that is set if this array represents a copy\nmade because a user required certain flags in\n:c:func:`PyArray_FromAny` and a copy had to be made of some other\narray (and the user asked for this flag to be set in such a\nsituation). The base attribute then points to the \"misbehaved\"\narray (which is set read_only). :c:func`PyArray_ResolveWritebackIfCopy`\nwill copy its contents back to the \"misbehaved\"\narray (casting if necessary) and will reset the \"misbehaved\" array\nto :c:data:`NPY_ARRAY_WRITEABLE`. If the \"misbehaved\" array was not\n:c:data:`NPY_ARRAY_WRITEABLE` to begin with then :c:func:`PyArray_FromAny`\nwould have returned an error because :c:data:`NPY_ARRAY_WRITEBACKIFCOPY`\nwould not have been possible.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": [
                    "PyArray_UpdateFlags"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " (obj, flags) will update the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "obj->flags"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " for "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "flags"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " which can be any of "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NPY_ARRAY_C_CONTIGUOUS"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NPY_ARRAY_F_CONTIGUOUS"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NPY_ARRAY_ALIGNED"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", or "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NPY_ARRAY_WRITEABLE"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "title": "Basic Array Flags"
    },
    {
      "children": [
        {
          "data": {
            "argument": "NPY_ARRAY_BEHAVED",
            "content": ":c:data:`NPY_ARRAY_ALIGNED` \\| :c:data:`NPY_ARRAY_WRITEABLE`",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_ARRAY_CARRAY",
            "content": ":c:data:`NPY_ARRAY_C_CONTIGUOUS` \\| :c:data:`NPY_ARRAY_BEHAVED`",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_ARRAY_CARRAY_RO",
            "content": ":c:data:`NPY_ARRAY_C_CONTIGUOUS` \\| :c:data:`NPY_ARRAY_ALIGNED`",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_ARRAY_FARRAY",
            "content": ":c:data:`NPY_ARRAY_F_CONTIGUOUS` \\| :c:data:`NPY_ARRAY_BEHAVED`",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_ARRAY_FARRAY_RO",
            "content": ":c:data:`NPY_ARRAY_F_CONTIGUOUS` \\| :c:data:`NPY_ARRAY_ALIGNED`",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_ARRAY_DEFAULT",
            "content": ":c:data:`NPY_ARRAY_CARRAY`",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_ARRAY_UPDATE_ALL",
            "content": ":c:data:`NPY_ARRAY_C_CONTIGUOUS` \\| :c:data:`NPY_ARRAY_F_CONTIGUOUS` \\| :c:data:`NPY_ARRAY_ALIGNED`",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Combinations of array flags"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "These constants are used in "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_FromAny"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " (and its macro forms) to specify desired properties of the new array."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "NPY_ARRAY_FORCECAST",
            "content": "Cast to the desired type, even if it can't be done without losing\ninformation.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_ARRAY_ENSURECOPY",
            "content": "Make sure the resulting array is a copy of the original.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_ARRAY_ENSUREARRAY",
            "content": "Make sure the resulting object is an actual ndarray, and not a sub-class.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Flag-like constants"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "For all of these macros "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "arr"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " must be an instance of a (subclass of) "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_Type"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "int PyArray_CHKFLAGS(PyObject *arr, int flags)",
            "content": "The first parameter, arr, must be an ndarray or subclass. The\nparameter, *flags*, should be an integer consisting of bitwise\ncombinations of the possible flags an array can have:\n:c:data:`NPY_ARRAY_C_CONTIGUOUS`, :c:data:`NPY_ARRAY_F_CONTIGUOUS`,\n:c:data:`NPY_ARRAY_OWNDATA`, :c:data:`NPY_ARRAY_ALIGNED`,\n:c:data:`NPY_ARRAY_WRITEABLE`, :c:data:`NPY_ARRAY_WRITEBACKIFCOPY`.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_IS_C_CONTIGUOUS(PyObject *arr)",
            "content": "Evaluates true if *arr* is C-style contiguous.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_IS_F_CONTIGUOUS(PyObject *arr)",
            "content": "Evaluates true if *arr* is Fortran-style contiguous.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISFORTRAN(PyObject *arr)",
            "content": "Evaluates true if *arr* is Fortran-style contiguous and *not*\nC-style contiguous. :c:func:`PyArray_IS_F_CONTIGUOUS`\nis the correct way to test for Fortran-style contiguity.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISWRITEABLE(PyObject *arr)",
            "content": "Evaluates true if the data area of *arr* can be written to",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISALIGNED(PyObject *arr)",
            "content": "Evaluates true if the data area of *arr* is properly aligned on\nthe machine.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISBEHAVED(PyObject *arr)",
            "content": "Evaluates true if the data area of *arr* is aligned and writeable\nand in machine byte-order according to its descriptor.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISBEHAVED_RO(PyObject *arr)",
            "content": "Evaluates true if the data area of *arr* is aligned and in machine\nbyte-order.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISCARRAY(PyObject *arr)",
            "content": "Evaluates true if the data area of *arr* is C-style contiguous,\nand :c:func:`PyArray_ISBEHAVED` (*arr*) is true.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISFARRAY(PyObject *arr)",
            "content": "Evaluates true if the data area of *arr* is Fortran-style\ncontiguous and :c:func:`PyArray_ISBEHAVED` (*arr*) is true.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISCARRAY_RO(PyObject *arr)",
            "content": "Evaluates true if the data area of *arr* is C-style contiguous,\naligned, and in machine byte-order.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISFARRAY_RO(PyObject *arr)",
            "content": "Evaluates true if the data area of *arr* is Fortran-style\ncontiguous, aligned, and in machine byte-order **.**",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ISONESEGMENT(PyObject *arr)",
            "content": "Evaluates true if the data area of *arr* consists of a single\n(C-style or Fortran-style) contiguous segment.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void PyArray_UpdateFlags(PyArrayObject* arr, int flagmask)",
            "content": "The :c:data:`NPY_ARRAY_C_CONTIGUOUS`, :c:data:`NPY_ARRAY_ALIGNED`, and\n:c:data:`NPY_ARRAY_F_CONTIGUOUS` array flags can be \"calculated\" from the\narray object itself. This routine updates one or more of these\nflags of *arr* as specified in *flagmask* by performing the\nrequired calculation.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "It is important to keep the flags updated (using "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": "c",
                        "role": "func",
                        "value": "PyArray_UpdateFlags"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " can help) whenever a manipulation with an array is performed that might cause them to change. Later calculations in NumPy that rely on the state of these flags do not repeat the calculation to update them."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ],
            "kind": "warning",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "argument": "int PyArray_FailUnlessWriteable(PyArrayObject *obj, const char *name)",
            "content": "This function does nothing and returns 0 if *obj* is writeable.\nIt raises an exception and returns -1 if *obj* is not writeable.\nIt may also do other house-keeping, such as issuing warnings on\narrays which are transitioning to become views. Always call this\nfunction at some point before writing to an array.\n\n*name* is a name for the array, used to give better error messages.\nIt can be something like \"assignment destination\", \"output array\",\nor even just \"array\".",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Flag checking"
    },
    {
      "children": [],
      "title": "Array method alternative API"
    },
    {
      "children": [
        {
          "data": {
            "argument": "PyObject* PyArray_GetField( \\",
            "content": "PyArrayObject* self, PyArray_Descr* dtype, int offset)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.getfield<numpy.ndarray.getfield>`",
              "(*self*, *dtype*, *offset*). This function `steals a reference",
              "<https://docs.python.org/3/c-api/intro.html?reference-count-details>`_",
              "to `PyArray_Descr` and returns a new array of the given `dtype` using",
              "the data in the current array at a specified `offset` in bytes. The",
              "`offset` plus the itemsize of the new array type must be less than ``self",
              "->descr->elsize`` or an error is raised. The same shape and strides",
              "as the original array are used. Therefore, this function has the",
              "effect of returning a field from a structured array. But, it can also",
              "be used to select specific bytes or groups of bytes from any array",
              "type."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArray_SetField( \\",
            "content": "PyArrayObject* self, PyArray_Descr* dtype, int offset, PyObject* val)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.setfield<numpy.ndarray.setfield>` (*self*, *val*, *dtype*, *offset*",
              "). Set the field starting at *offset* in bytes and of the given",
              "*dtype* to *val*. The *offset* plus *dtype* ->elsize must be less",
              "than *self* ->descr->elsize or an error is raised. Otherwise, the",
              "*val* argument is converted to an array and copied into the field",
              "pointed to. If necessary, the elements of *val* are repeated to",
              "fill the destination array, But, the number of elements in the",
              "destination must be an integer multiple of the number of elements",
              "in *val*."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Byteswap(PyArrayObject* self, npy_bool inplace)",
            "content": "Equivalent to :meth:`ndarray.byteswap<numpy.ndarray.byteswap>` (*self*, *inplace*). Return an array\nwhose data area is byteswapped. If *inplace* is non-zero, then do\nthe byteswap inplace and return a reference to self. Otherwise,\ncreate a byteswapped copy and leave self unchanged.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_NewCopy(PyArrayObject* old, NPY_ORDER order)",
            "content": "Equivalent to :meth:`ndarray.copy<numpy.ndarray.copy>` (*self*, *fortran*). Make a copy of the\n*old* array. The returned array is always aligned and writeable\nwith data interpreted the same as the old array. If *order* is\n:c:data:`NPY_CORDER`, then a C-style contiguous array is returned. If\n*order* is :c:data:`NPY_FORTRANORDER`, then a Fortran-style contiguous\narray is returned. If *order is* :c:data:`NPY_ANYORDER`, then the array\nreturned is Fortran-style contiguous only if the old one is;\notherwise, it is C-style contiguous.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_ToList(PyArrayObject* self)",
            "content": "Equivalent to :meth:`ndarray.tolist<numpy.ndarray.tolist>` (*self*). Return a nested Python list\nfrom *self*.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_ToString(PyArrayObject* self, NPY_ORDER order)",
            "content": "Equivalent to :meth:`ndarray.tobytes<numpy.ndarray.tobytes>` (*self*, *order*). Return the bytes\nof this array in a Python string.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_ToFile( \\",
            "content": "PyArrayObject* self, FILE* fp, char* sep, char* format)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Write the contents of *self* to the file pointer *fp* in C-style",
              "contiguous fashion. Write the data as binary bytes if *sep* is the",
              "string \"\"or ``NULL``. Otherwise, write the contents of *self* as",
              "text using the *sep* string as the item separator. Each item will",
              "be printed to the file.  If the *format* string is not ``NULL`` or",
              "\"\", then it is a Python print statement format string showing how",
              "the items are to be written."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArray_Dump(PyObject* self, PyObject* file, int protocol)",
            "content": "Pickle the object in *self* to the given *file* (either a string\nor a Python file object). If *file* is a Python string it is\nconsidered to be the name of a file which is then opened in binary\nmode. The given *protocol* is used (if *protocol* is negative, or\nthe highest available is used). This is a simple wrapper around\ncPickle.dump(*self*, *file*, *protocol*).",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Dumps(PyObject* self, int protocol)",
            "content": "Pickle the object in *self* to a Python string and return it. Use\nthe Pickle *protocol* provided (or the highest available if\n*protocol* is negative).",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_FillWithScalar(PyArrayObject* arr, PyObject* obj)",
            "content": "Fill the array, *arr*, with the given scalar object, *obj*. The\nobject is first converted to the data type of *arr*, and then\ncopied into every location. A -1 is returned if an error occurs,\notherwise 0 is returned.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_View( \\",
            "content": "PyArrayObject* self, PyArray_Descr* dtype, PyTypeObject *ptype)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.view<numpy.ndarray.view>` (*self*, *dtype*). Return a new",
              "view of the array *self* as possibly a different data-type, *dtype*,",
              "and different array subclass *ptype*.",
              "",
              "If *dtype* is ``NULL``, then the returned array will have the same",
              "data type as *self*. The new data-type must be consistent with the",
              "size of *self*. Either the itemsizes must be identical, or *self* must",
              "be single-segment and the total number of bytes must be the same.",
              "In the latter case the dimensions of the returned array will be",
              "altered in the last (or first for Fortran-style contiguous arrays)",
              "dimension. The data area of the returned array and self is exactly",
              "the same."
            ]
          },
          "type": "BlockQuote"
        }
      ],
      "title": "Conversion"
    },
    {
      "children": [
        {
          "data": {
            "argument": "PyObject* PyArray_Newshape( \\",
            "content": "PyArrayObject* self, PyArray_Dims* newshape, NPY_ORDER order)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Result will be a new array (pointing to the same memory location",
              "as *self* if possible), but having a shape given by *newshape*.",
              "If the new shape is not compatible with the strides of *self*,",
              "then a copy of the array with the new specified shape will be",
              "returned."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Reshape(PyArrayObject* self, PyObject* shape)",
            "content": "Equivalent to :meth:`ndarray.reshape<numpy.ndarray.reshape>` (*self*, *shape*) where *shape* is a\nsequence. Converts *shape* to a :c:type:`PyArray_Dims` structure and\ncalls :c:func:`PyArray_Newshape` internally.\nFor back-ward compatibility -- Not recommended",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Squeeze(PyArrayObject* self)",
            "content": "Equivalent to :meth:`ndarray.squeeze<numpy.ndarray.squeeze>` (*self*). Return a new view of *self*\nwith all of the dimensions of length 1 removed from the shape.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "matrix objects are always 2-dimensional. Therefore, "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": "c",
                        "role": "func",
                        "value": "PyArray_Squeeze"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " has no effect on arrays of matrix sub-class."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ],
            "kind": "warning",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_SwapAxes(PyArrayObject* self, int a1, int a2)",
            "content": "Equivalent to :meth:`ndarray.swapaxes<numpy.ndarray.swapaxes>` (*self*, *a1*, *a2*). The returned\narray is a new view of the data in *self* with the given axes,\n*a1* and *a2*, swapped.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Resize( \\",
            "content": "PyArrayObject* self, PyArray_Dims* newshape, int refcheck, \\\nNPY_ORDER fortran)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.resize<numpy.ndarray.resize>` (*self*, *newshape*, refcheck",
              "``=`` *refcheck*, order= fortran ). This function only works on",
              "single-segment arrays. It changes the shape of *self* inplace and",
              "will reallocate the memory for *self* if *newshape* has a",
              "different total number of elements then the old shape. If",
              "reallocation is necessary, then *self* must own its data, have",
              "*self* - ``>base==NULL``, have *self* - ``>weakrefs==NULL``, and",
              "(unless refcheck is 0) not be referenced by any other array.",
              "The fortran argument can be :c:data:`NPY_ANYORDER`, :c:data:`NPY_CORDER`,",
              "or :c:data:`NPY_FORTRANORDER`. It currently has no effect. Eventually",
              "it could be used to determine how the resize operation should view",
              "the data when constructing a differently-dimensioned array.",
              "Returns None on success and NULL on error."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Transpose( \\",
            "content": "PyArrayObject* self, PyArray_Dims* permute)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.transpose<numpy.ndarray.transpose>` (*self*, *permute*). Permute the",
              "axes of the ndarray object *self* according to the data structure",
              "*permute* and return the result. If *permute* is ``NULL``, then",
              "the resulting array has its axes reversed. For example if *self*",
              "has shape :math:`10\\times20\\times30`, and *permute* ``.ptr`` is",
              "(0,2,1) the shape of the result is :math:`10\\times30\\times20.` If",
              "*permute* is ``NULL``, the shape of the result is",
              ":math:`30\\times20\\times10.`"
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Flatten(PyArrayObject* self, NPY_ORDER order)",
            "content": "Equivalent to :meth:`ndarray.flatten<numpy.ndarray.flatten>` (*self*, *order*). Return a 1-d copy\nof the array. If *order* is :c:data:`NPY_FORTRANORDER` the elements are\nscanned out in Fortran order (first-dimension varies the\nfastest). If *order* is :c:data:`NPY_CORDER`, the elements of ``self``\nare scanned in C-order (last dimension varies the fastest). If\n*order* :c:data:`NPY_ANYORDER`, then the result of\n:c:func:`PyArray_ISFORTRAN` (*self*) is used to determine which order\nto flatten.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Ravel(PyArrayObject* self, NPY_ORDER order)",
            "content": "Equivalent to *self*.ravel(*order*). Same basic functionality\nas :c:func:`PyArray_Flatten` (*self*, *order*) except if *order* is 0\nand *self* is C-style contiguous, the shape is altered but no copy\nis performed.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Shape Manipulation"
    },
    {
      "children": [
        {
          "data": {
            "argument": "PyObject* PyArray_TakeFrom( \\",
            "content": "PyArrayObject* self, PyObject* indices, int axis, PyArrayObject* ret, \\\nNPY_CLIPMODE clipmode)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.take<numpy.ndarray.take>` (*self*, *indices*, *axis*, *ret*,",
              "*clipmode*) except *axis* =None in Python is obtained by setting",
              "*axis* = :c:data:`NPY_MAXDIMS` in C. Extract the items from self",
              "indicated by the integer-valued *indices* along the given *axis.*",
              "The clipmode argument can be :c:data:`NPY_RAISE`, :c:data:`NPY_WRAP`, or",
              ":c:data:`NPY_CLIP` to indicate what to do with out-of-bound indices. The",
              "*ret* argument can specify an output array rather than having one",
              "created internally."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_PutTo( \\",
            "content": "PyArrayObject* self, PyObject* values, PyObject* indices, \\\nNPY_CLIPMODE clipmode)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to *self*.put(*values*, *indices*, *clipmode*",
              "). Put *values* into *self* at the corresponding (flattened)",
              "*indices*. If *values* is too small it will be repeated as",
              "necessary."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_PutMask( \\",
            "content": "PyArrayObject* self, PyObject* values, PyObject* mask)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Place the *values* in *self* wherever corresponding positions",
              "(using a flattened context) in *mask* are true. The *mask* and",
              "*self* arrays must have the same total number of elements. If",
              "*values* is too small, it will be repeated as necessary."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Repeat( \\",
            "content": "PyArrayObject* self, PyObject* op, int axis)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.repeat<numpy.ndarray.repeat>` (*self*, *op*, *axis*). Copy the",
              "elements of *self*, *op* times along the given *axis*. Either",
              "*op* is a scalar integer or a sequence of length *self*",
              "->dimensions[ *axis* ] indicating how many times to repeat each",
              "item along the axis."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Choose( \\",
            "content": "PyArrayObject* self, PyObject* op, PyArrayObject* ret, \\\nNPY_CLIPMODE clipmode)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.choose<numpy.ndarray.choose>` (*self*, *op*, *ret*, *clipmode*).",
              "Create a new array by selecting elements from the sequence of",
              "arrays in *op* based on the integer values in *self*. The arrays",
              "must all be broadcastable to the same shape and the entries in",
              "*self* should be between 0 and len(*op*). The output is placed",
              "in *ret* unless it is ``NULL`` in which case a new output is",
              "created. The *clipmode* argument determines behavior for when",
              "entries in *self* are not between 0 and len(*op*).",
              "",
              ".. c:macro:: NPY_RAISE",
              "",
              "    raise a ValueError;",
              "",
              ".. c:macro:: NPY_WRAP",
              "",
              "    wrap values < 0 by adding len(*op*) and values >=len(*op*)",
              "    by subtracting len(*op*) until they are in range;",
              "",
              ".. c:macro:: NPY_CLIP",
              "",
              "    all values are clipped to the region [0, len(*op*) )."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Sort(PyArrayObject* self, int axis, NPY_SORTKIND kind)",
            "content": "Equivalent to :meth:`ndarray.sort<numpy.ndarray.sort>` (*self*, *axis*, *kind*).\nReturn an array with the items of *self* sorted along *axis*. The array\nis sorted using the algorithm denoted by *kind*, which is an integer/enum pointing\nto the type of sorting algorithms used.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_ArgSort(PyArrayObject* self, int axis)",
            "content": "Equivalent to :meth:`ndarray.argsort<numpy.ndarray.argsort>` (*self*, *axis*).\nReturn an array of indices such that selection of these indices\nalong the given ``axis`` would return a sorted version of *self*. If *self* ->descr\nis a data-type with fields defined, then self->descr->names is used\nto determine the sort order. A comparison where the first field is equal\nwill use the second field and so on. To alter the sort order of a\nstructured array, create a new data-type with a different order of names\nand construct a view of the array with that new data-type.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_LexSort(PyObject* sort_keys, int axis)",
            "content": "Given a sequence of arrays (*sort_keys*) of the same shape,\nreturn an array of indices (similar to :c:func:`PyArray_ArgSort` (...))\nthat would sort the arrays lexicographically. A lexicographic sort\nspecifies that when two keys are found to be equal, the order is\nbased on comparison of subsequent keys. A merge sort (which leaves\nequal entries unmoved) is required to be defined for the\ntypes. The sort is accomplished by sorting the indices first using\nthe first *sort_key* and then using the second *sort_key* and so\nforth. This is equivalent to the lexsort(*sort_keys*, *axis*)\nPython command. Because of the way the merge-sort works, be sure\nto understand the order the *sort_keys* must be in (reversed from\nthe order you would use when comparing two elements).\n\nIf these arrays are all collected in a structured array, then\n:c:func:`PyArray_Sort` (...) can also be used to sort the array\ndirectly.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_SearchSorted( \\",
            "content": "PyArrayObject* self, PyObject* values, NPY_SEARCHSIDE side, \\\nPyObject* perm)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.searchsorted<numpy.ndarray.searchsorted>` (*self*, *values*, *side*,",
              "*perm*). Assuming *self* is a 1-d array in ascending order, then the",
              "output is an array of indices the same shape as *values* such that, if",
              "the elements in *values* were inserted before the indices, the order of",
              "*self* would be preserved. No checking is done on whether or not self is",
              "in ascending order.",
              "",
              "The *side* argument indicates whether the index returned should be that of",
              "the first suitable location (if :c:data:`NPY_SEARCHLEFT`) or of the last",
              "(if :c:data:`NPY_SEARCHRIGHT`).",
              "",
              "The *sorter* argument, if not ``NULL``, must be a 1D array of integer",
              "indices the same length as *self*, that sorts it into ascending order.",
              "This is typically the result of a call to :c:func:`PyArray_ArgSort` (...)",
              "Binary search is used to find the required insertion points."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArray_Partition( \\",
            "content": "PyArrayObject *self, PyArrayObject * ktharray, int axis, \\\nNPY_SELECTKIND which)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.partition<numpy.ndarray.partition>` (*self*, *ktharray*, *axis*,",
              "*kind*). Partitions the array so that the values of the element indexed by",
              "*ktharray* are in the positions they would be if the array is fully sorted",
              "and places all elements smaller than the kth before and all elements equal",
              "or greater after the kth element. The ordering of all elements within the",
              "partitions is undefined.",
              "If *self*->descr is a data-type with fields defined, then",
              "self->descr->names is used to determine the sort order. A comparison where",
              "the first field is equal will use the second field and so on. To alter the",
              "sort order of a structured array, create a new data-type with a different",
              "order of names and construct a view of the array with that new data-type.",
              "Returns zero on success and -1 on failure."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_ArgPartition( \\",
            "content": "PyArrayObject *op, PyArrayObject * ktharray, int axis, \\\nNPY_SELECTKIND which)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.argpartition<numpy.ndarray.argpartition>` (*self*, *ktharray*, *axis*,",
              "*kind*). Return an array of indices such that selection of these indices",
              "along the given ``axis`` would return a partitioned version of *self*."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Diagonal( \\",
            "content": "PyArrayObject* self, int offset, int axis1, int axis2)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.diagonal<numpy.ndarray.diagonal>` (*self*, *offset*, *axis1*, *axis2*",
              "). Return the *offset* diagonals of the 2-d arrays defined by",
              "*axis1* and *axis2*."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "npy_intp PyArray_CountNonzero(PyArrayObject* self)",
            "content": ".. versionadded:: 1.6\n\nCounts the number of non-zero elements in the array object *self*.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Nonzero(PyArrayObject* self)",
            "content": "Equivalent to :meth:`ndarray.nonzero<numpy.ndarray.nonzero>` (*self*). Returns a tuple of index\narrays that select elements of *self* that are nonzero. If (nd=\n:c:func:`PyArray_NDIM` ( ``self`` ))==1, then a single index array is\nreturned. The index arrays have data type :c:data:`NPY_INTP`. If a\ntuple is returned (nd :math:`\\neq` 1), then its length is nd.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Compress( \\",
            "content": "PyArrayObject* self, PyObject* condition, int axis, PyArrayObject* out)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.compress<numpy.ndarray.compress>` (*self*, *condition*, *axis*",
              "). Return the elements along *axis* corresponding to elements of",
              "*condition* that are true."
            ]
          },
          "type": "BlockQuote"
        }
      ],
      "title": "Item selection and manipulation"
    },
    {
      "children": [
        {
          "data": {
            "argument": "",
            "content": "Pass in :c:data:`NPY_MAXDIMS` for axis in order to achieve the same\neffect that is obtained by passing in ``axis=None`` in Python\n(treating the array as a 1-d array).",
            "name": "tip",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "The out argument specifies where to place the result. If out is NULL, then the output array is created, otherwise the output is placed in out which must be the correct size and type. A new reference to the output array is always returned even when out is not NULL. The caller of the routine has the responsibility to "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "Py_DECREF"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " out if not NULL or a memory-leak will occur."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_ArgMax( \\",
            "content": "PyArrayObject* self, int axis, PyArrayObject* out)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.argmax<numpy.ndarray.argmax>` (*self*, *axis*). Return the index of",
              "the largest element of *self* along *axis*."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_ArgMin( \\",
            "content": "PyArrayObject* self, int axis, PyArrayObject* out)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.argmin<numpy.ndarray.argmin>` (*self*, *axis*). Return the index of",
              "the smallest element of *self* along *axis*."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Max( \\",
            "content": "PyArrayObject* self, int axis, PyArrayObject* out)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.max<numpy.ndarray.max>` (*self*, *axis*). Returns the largest",
              "element of *self* along the given *axis*. When the result is a single",
              "element, returns a numpy scalar instead of an ndarray."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Min( \\",
            "content": "PyArrayObject* self, int axis, PyArrayObject* out)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.min<numpy.ndarray.min>` (*self*, *axis*). Return the smallest",
              "element of *self* along the given *axis*. When the result is a single",
              "element, returns a numpy scalar instead of an ndarray."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Ptp( \\",
            "content": "PyArrayObject* self, int axis, PyArrayObject* out)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.ptp<numpy.ndarray.ptp>` (*self*, *axis*). Return the difference",
              "between the largest element of *self* along *axis* and the",
              "smallest element of *self* along *axis*. When the result is a single",
              "element, returns a numpy scalar instead of an ndarray."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "The rtype argument specifies the data-type the reduction should take place over. This is important if the data-type of the array is not \"large\" enough to handle the output. By default, all integer data-types are made at least as large as "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": "c",
                        "role": "data",
                        "value": "NPY_LONG"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " for the \"add\" and \"multiply\" ufuncs (which form the basis for mean, sum, cumsum, prod, and cumprod functions)."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Mean( \\",
            "content": "PyArrayObject* self, int axis, int rtype, PyArrayObject* out)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.mean<numpy.ndarray.mean>` (*self*, *axis*, *rtype*). Returns the",
              "mean of the elements along the given *axis*, using the enumerated",
              "type *rtype* as the data type to sum in. Default sum behavior is",
              "obtained using :c:data:`NPY_NOTYPE` for *rtype*."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Trace( \\",
            "content": "PyArrayObject* self, int offset, int axis1, int axis2, int rtype, \\\nPyArrayObject* out)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.trace<numpy.ndarray.trace>` (*self*, *offset*, *axis1*, *axis2*,",
              "*rtype*). Return the sum (using *rtype* as the data type of",
              "summation) over the *offset* diagonal elements of the 2-d arrays",
              "defined by *axis1* and *axis2* variables. A positive offset",
              "chooses diagonals above the main diagonal. A negative offset",
              "selects diagonals below the main diagonal."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Clip( \\",
            "content": "PyArrayObject* self, PyObject* min, PyObject* max)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.clip<numpy.ndarray.clip>` (*self*, *min*, *max*). Clip an array,",
              "*self*, so that values larger than *max* are fixed to *max* and",
              "values less than *min* are fixed to *min*."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Conjugate(PyArrayObject* self)",
            "content": "Equivalent to :meth:`ndarray.conjugate<numpy.ndarray.conjugate>` (*self*).\nReturn the complex conjugate of *self*. If *self* is not of\ncomplex data type, then return *self* with a reference.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Round( \\",
            "content": "PyArrayObject* self, int decimals, PyArrayObject* out)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.round<numpy.ndarray.round>` (*self*, *decimals*, *out*). Returns",
              "the array with elements rounded to the nearest decimal place. The",
              "decimal place is defined as the :math:`10^{-\\textrm{decimals}}`",
              "digit so that negative *decimals* cause rounding to the nearest 10's, 100's, etc. If out is ``NULL``, then the output array is created, otherwise the output is placed in *out* which must be the correct size and type."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Std( \\",
            "content": "PyArrayObject* self, int axis, int rtype, PyArrayObject* out)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.std<numpy.ndarray.std>` (*self*, *axis*, *rtype*). Return the",
              "standard deviation using data along *axis* converted to data type",
              "*rtype*."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Sum( \\",
            "content": "PyArrayObject* self, int axis, int rtype, PyArrayObject* out)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.sum<numpy.ndarray.sum>` (*self*, *axis*, *rtype*). Return 1-d",
              "vector sums of elements in *self* along *axis*. Perform the sum",
              "after converting data to data type *rtype*."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_CumSum( \\",
            "content": "PyArrayObject* self, int axis, int rtype, PyArrayObject* out)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.cumsum<numpy.ndarray.cumsum>` (*self*, *axis*, *rtype*). Return",
              "cumulative 1-d sums of elements in *self* along *axis*. Perform",
              "the sum after converting data to data type *rtype*."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Prod( \\",
            "content": "PyArrayObject* self, int axis, int rtype, PyArrayObject* out)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.prod<numpy.ndarray.prod>` (*self*, *axis*, *rtype*). Return 1-d",
              "products of elements in *self* along *axis*. Perform the product",
              "after converting data to data type *rtype*."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_CumProd( \\",
            "content": "PyArrayObject* self, int axis, int rtype, PyArrayObject* out)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.cumprod<numpy.ndarray.cumprod>` (*self*, *axis*, *rtype*). Return",
              "1-d cumulative products of elements in ``self`` along ``axis``.",
              "Perform the product after converting data to data type ``rtype``."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_All( \\",
            "content": "PyArrayObject* self, int axis, PyArrayObject* out)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.all<numpy.ndarray.all>` (*self*, *axis*). Return an array with",
              "True elements for every 1-d sub-array of ``self`` defined by",
              "``axis`` in which all the elements are True."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Any( \\",
            "content": "PyArrayObject* self, int axis, PyArrayObject* out)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Equivalent to :meth:`ndarray.any<numpy.ndarray.any>` (*self*, *axis*). Return an array with",
              "True elements for every 1-d sub-array of *self* defined by *axis*",
              "in which any of the elements are True."
            ]
          },
          "type": "BlockQuote"
        }
      ],
      "title": "Calculation"
    },
    {
      "children": [],
      "title": "Functions"
    },
    {
      "children": [
        {
          "data": {
            "argument": "int PyArray_AsCArray( \\",
            "content": "PyObject** op, void* ptr, npy_intp* dims, int nd, int typenum, \\\nint itemsize)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Sometimes it is useful to access a multidimensional array as a",
              "C-style multi-dimensional array so that algorithms can be",
              "implemented using C's a[i][j][k] syntax. This routine returns a",
              "pointer, *ptr*, that simulates this kind of C-style array, for",
              "1-, 2-, and 3-d ndarrays.",
              "",
              ":param op:",
              "",
              "    The address to any Python object. This Python object will be replaced",
              "    with an equivalent well-behaved, C-style contiguous, ndarray of the",
              "    given data type specified by the last two arguments. Be sure that",
              "    stealing a reference in this way to the input object is justified.",
              "",
              ":param ptr:",
              "",
              "    The address to a (ctype* for 1-d, ctype** for 2-d or ctype*** for 3-d)",
              "    variable where ctype is the equivalent C-type for the data type. On",
              "    return, *ptr* will be addressable as a 1-d, 2-d, or 3-d array.",
              "",
              ":param dims:",
              "",
              "    An output array that contains the shape of the array object. This",
              "    array gives boundaries on any looping that will take place.",
              "",
              ":param nd:",
              "",
              "    The dimensionality of the array (1, 2, or 3).",
              "",
              ":param typenum:",
              "",
              "    The expected data type of the array.",
              "",
              ":param itemsize:",
              "",
              "    This argument is only needed when *typenum* represents a",
              "    flexible array. Otherwise it should be 0."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "The simulation of a C-style array is not complete for 2-d and 3-d arrays. For example, the simulated arrays of pointers cannot be passed to subroutines expecting specific, statically-defined 2-d and 3-d arrays. To pass to functions requiring those kind of inputs, you must statically define the required array and copy data."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "argument": "int PyArray_Free(PyObject* op, void* ptr)",
            "content": "Must be called with the same objects and memory locations returned\nfrom :c:func:`PyArray_AsCArray` (...). This function cleans up memory\nthat otherwise would get leaked.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Concatenate(PyObject* obj, int axis)",
            "content": "Join the sequence of objects in *obj* together along *axis* into a\nsingle array. If the dimensions or types are not compatible an\nerror is raised.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_InnerProduct(PyObject* obj1, PyObject* obj2)",
            "content": "Compute a product-sum over the last dimensions of *obj1* and\n*obj2*. Neither array is conjugated.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_MatrixProduct(PyObject* obj1, PyObject* obj)",
            "content": "Compute a product-sum over the last dimension of *obj1* and the\nsecond-to-last dimension of *obj2*. For 2-d arrays this is a\nmatrix-product. Neither array is conjugated.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_MatrixProduct2( \\",
            "content": "PyObject* obj1, PyObject* obj, PyArrayObject* out)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              ".. versionadded:: 1.6",
              "",
              "Same as PyArray_MatrixProduct, but store the result in *out*.  The",
              "output array must have the correct shape, type, and be",
              "C-contiguous, or an exception is raised."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_EinsteinSum( \\",
            "content": "char* subscripts, npy_intp nop, PyArrayObject** op_in, \\\nPyArray_Descr* dtype, NPY_ORDER order, NPY_CASTING casting, \\\nPyArrayObject* out)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              ".. versionadded:: 1.6",
              "",
              "Applies the Einstein summation convention to the array operands",
              "provided, returning a new array or placing the result in *out*.",
              "The string in *subscripts* is a comma separated list of index",
              "letters. The number of operands is in *nop*, and *op_in* is an",
              "array containing those operands. The data type of the output can",
              "be forced with *dtype*, the output order can be forced with *order*",
              "(:c:data:`NPY_KEEPORDER` is recommended), and when *dtype* is specified,",
              "*casting* indicates how permissive the data conversion should be.",
              "",
              "See the :func:`~numpy.einsum` function for more details."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_CopyAndTranspose(PyObject * op)",
            "content": "A specialized copy and transpose function that works only for 2-d\narrays. The returned array is a transposed copy of *op*.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Correlate( \\",
            "content": "PyObject* op1, PyObject* op2, int mode)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Compute the 1-d correlation of the 1-d arrays *op1* and *op2*",
              ". The correlation is computed at each output point by multiplying",
              "*op1* by a shifted version of *op2* and summing the result. As a",
              "result of the shift, needed values outside of the defined range of",
              "*op1* and *op2* are interpreted as zero. The mode determines how",
              "many shifts to return: 0 - return only shifts that did not need to",
              "assume zero- values; 1 - return an object that is the same size as",
              "*op1*, 2 - return all possible shifts (any overlap at all is",
              "accepted).",
              "",
              ".. rubric:: Notes",
              "",
              "This does not compute the usual correlation: if op2 is larger than op1, the",
              "arguments are swapped, and the conjugate is never taken for complex arrays.",
              "See PyArray_Correlate2 for the usual signal processing correlation."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Correlate2( \\",
            "content": "PyObject* op1, PyObject* op2, int mode)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Updated version of PyArray_Correlate, which uses the usual definition of",
              "correlation for 1d arrays. The correlation is computed at each output point",
              "by multiplying *op1* by a shifted version of *op2* and summing the result.",
              "As a result of the shift, needed values outside of the defined range of",
              "*op1* and *op2* are interpreted as zero. The mode determines how many",
              "shifts to return: 0 - return only shifts that did not need to assume zero-",
              "values; 1 - return an object that is the same size as *op1*, 2 - return all",
              "possible shifts (any overlap at all is accepted).",
              "",
              ".. rubric:: Notes",
              "",
              "Compute z as follows::",
              "",
              "  z[k] = sum_n op1[n] * conj(op2[n+k])"
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Where( \\",
            "content": "PyObject* condition, PyObject* x, PyObject* y)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "If both ``x`` and ``y`` are ``NULL``, then return",
              ":c:func:`PyArray_Nonzero` (*condition*). Otherwise, both *x* and *y*",
              "must be given and the object returned is shaped like *condition*",
              "and has elements of *x* and *y* where *condition* is respectively",
              "True or False."
            ]
          },
          "type": "BlockQuote"
        }
      ],
      "title": "Array Functions"
    },
    {
      "children": [
        {
          "data": {
            "argument": "npy_bool PyArray_CheckStrides( \\",
            "content": "int elsize, int nd, npy_intp numbytes, npy_intp const* dims, \\\nnpy_intp const* newstrides)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Determine if *newstrides* is a strides array consistent with the",
              "memory of an *nd* -dimensional array with shape ``dims`` and",
              "element-size, *elsize*. The *newstrides* array is checked to see",
              "if jumping by the provided number of bytes in each direction will",
              "ever mean jumping more than *numbytes* which is the assumed size",
              "of the available memory segment. If *numbytes* is 0, then an",
              "equivalent *numbytes* is computed assuming *nd*, *dims*, and",
              "*elsize* refer to a single-segment array. Return :c:data:`NPY_TRUE` if",
              "*newstrides* is acceptable, otherwise return :c:data:`NPY_FALSE`."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "npy_intp PyArray_MultiplyList(npy_intp const* seq, int n)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_MultiplyIntList(int const* seq, int n)",
            "content": "Both of these routines multiply an *n* -length array, *seq*, of\nintegers and return the result. No overflow checking is performed.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_CompareLists(npy_intp const* l1, npy_intp const* l2, int n)",
            "content": "Given two *n* -length arrays of integers, *l1*, and *l2*, return\n1 if the lists are identical; otherwise, return 0.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Other functions"
    },
    {
      "children": [
        {
          "data": {
            "children": [],
            "kind": "versionadded",
            "title": "1.7.0"
          },
          "type": "Admonition"
        },
        {
          "data": {
            "argument": "NpyAuxData",
            "content": "",
            "name": "c:type",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "When working with more complex dtypes which are composed of other dtypes, such as the struct dtype, creating inner loops that manipulate the dtypes requires carrying along additional data. NumPy supports this idea through a struct "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NpyAuxData"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", mandating a few conventions so that it is possible to do this."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Defining an "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NpyAuxData"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is similar to defining a class in C++, but the object semantics have to be tracked manually since the API is in C. Here's an example for a function which doubles up an element using an element copier function as a primitive."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "c",
            "content": "typedef struct {\n    NpyAuxData base;\n    ElementCopier_Func *func;\n    NpyAuxData *funcdata;\n} eldoubler_aux_data;\n\nvoid free_element_doubler_aux_data(NpyAuxData *data)\n{\n    eldoubler_aux_data *d = (eldoubler_aux_data *)data;\n    /* Free the memory owned by this auxdata */\n    NPY_AUXDATA_FREE(d->funcdata);\n    PyArray_free(d);\n}\n\nNpyAuxData *clone_element_doubler_aux_data(NpyAuxData *data)\n{\n    eldoubler_aux_data *ret = PyArray_malloc(sizeof(eldoubler_aux_data));\n    if (ret == NULL) {\n        return NULL;\n    }\n\n    /* Raw copy of all data */\n    memcpy(ret, data, sizeof(eldoubler_aux_data));\n\n    /* Fix up the owned auxdata so we have our own copy */\n    ret->funcdata = NPY_AUXDATA_CLONE(ret->funcdata);\n    if (ret->funcdata == NULL) {\n        PyArray_free(ret);\n        return NULL;\n    }\n\n    return (NpyAuxData *)ret;\n}\n\nNpyAuxData *create_element_doubler_aux_data(\n                            ElementCopier_Func *func,\n                            NpyAuxData *funcdata)\n{\n    eldoubler_aux_data *ret = PyArray_malloc(sizeof(eldoubler_aux_data));\n    if (ret == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    memset(&ret, 0, sizeof(eldoubler_aux_data));\n    ret->base->free = &free_element_doubler_aux_data;\n    ret->base->clone = &clone_element_doubler_aux_data;\n    ret->func = func;\n    ret->funcdata = funcdata;\n\n    return (NpyAuxData *)ret;\n}",
            "name": "code-block",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NpyAuxData_FreeFunc",
            "content": "The function pointer type for NpyAuxData free functions.",
            "name": "c:type",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NpyAuxData_CloneFunc",
            "content": "The function pointer type for NpyAuxData clone functions. These\nfunctions should never set the Python exception on error, because\nthey may be called from a multi-threaded context.",
            "name": "c:type",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void NPY_AUXDATA_FREE(NpyAuxData *auxdata)",
            "content": "A macro which calls the auxdata's free function appropriately,\ndoes nothing if auxdata is NULL.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NpyAuxData *NPY_AUXDATA_CLONE(NpyAuxData *auxdata)",
            "content": "A macro which calls the auxdata's clone function appropriately,\nreturning a deep copy of the auxiliary data.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Auxiliary Data With Object Semantics"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "As of NumPy 1.6.0, these array iterators are superseded by the new array iterator, "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NpyIter"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "An array iterator is a simple way to access the elements of an N-dimensional array quickly and efficiently. Section "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "2\n<#sec-array-iterator>"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " provides more description and examples of this useful approach to looping over an array."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_IterNew(PyObject* arr)",
            "content": "Return an array iterator object from the array, *arr*. This is\nequivalent to *arr*. **flat**. The array iterator object makes\nit easy to loop over an N-dimensional non-contiguous array in\nC-style contiguous fashion.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_IterAllButAxis(PyObject* arr, int* axis)",
            "content": "Return an array iterator that will iterate over all axes but the\none provided in *\\*axis*. The returned iterator cannot be used\nwith :c:func:`PyArray_ITER_GOTO1D`. This iterator could be used to\nwrite something similar to what ufuncs do wherein the loop over\nthe largest axis is done by a separate sub-routine. If *\\*axis* is\nnegative then *\\*axis* will be set to the axis having the smallest\nstride and that axis will be used.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject *PyArray_BroadcastToShape( \\",
            "content": "PyObject* arr, npy_intp const *dimensions, int nd)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Return an array iterator that is broadcast to iterate as an array",
              "of the shape provided by *dimensions* and *nd*."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArrayIter_Check(PyObject* op)",
            "content": "Evaluates true if *op* is an array iterator (or instance of a\nsubclass of the array iterator type).",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void PyArray_ITER_RESET(PyObject* iterator)",
            "content": "Reset an *iterator* to the beginning of the array.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void PyArray_ITER_NEXT(PyObject* iterator)",
            "content": "Incremement the index and the dataptr members of the *iterator* to\npoint to the next element of the array. If the array is not\n(C-style) contiguous, also increment the N-dimensional coordinates\narray.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void *PyArray_ITER_DATA(PyObject* iterator)",
            "content": "A pointer to the current element of the array.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void PyArray_ITER_GOTO( \\",
            "content": "PyObject* iterator, npy_intp* destination)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Set the *iterator* index, dataptr, and coordinates members to the",
              "location in the array indicated by the N-dimensional c-array,",
              "*destination*, which must have size at least *iterator*",
              "->nd_m1+1."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "void PyArray_ITER_GOTO1D(PyObject* iterator, npy_intp index)",
            "content": "Set the *iterator* index and dataptr to the location in the array\nindicated by the integer *index* which points to an element in the\nC-styled flattened array.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ITER_NOTDONE(PyObject* iterator)",
            "content": "Evaluates TRUE as long as the iterator has not looped through all of\nthe elements, otherwise it evaluates FALSE.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Array Iterators"
    },
    {
      "children": [
        {
          "data": {
            "argument": "PyObject* PyArray_MultiIterNew(int num, ...)",
            "content": "A simplified interface to broadcasting. This function takes the\nnumber of arrays to broadcast and then *num* extra ( :c:type:`PyObject *<PyObject>`\n) arguments. These arguments are converted to arrays and iterators\nare created. :c:func:`PyArray_Broadcast` is then called on the resulting\nmulti-iterator object. The resulting, broadcasted mult-iterator\nobject is then returned. A broadcasted operation can then be\nperformed using a single loop and using :c:func:`PyArray_MultiIter_NEXT`\n(..)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void PyArray_MultiIter_RESET(PyObject* multi)",
            "content": "Reset all the iterators to the beginning in a multi-iterator\nobject, *multi*.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void PyArray_MultiIter_NEXT(PyObject* multi)",
            "content": "Advance each iterator in a multi-iterator object, *multi*, to its\nnext (broadcasted) element.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void *PyArray_MultiIter_DATA(PyObject* multi, int i)",
            "content": "Return the data-pointer of the *i* :math:`^{\\textrm{th}}` iterator\nin a multi-iterator object.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void PyArray_MultiIter_NEXTi(PyObject* multi, int i)",
            "content": "Advance the pointer of only the *i* :math:`^{\\textrm{th}}` iterator.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void PyArray_MultiIter_GOTO( \\",
            "content": "PyObject* multi, npy_intp* destination)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Advance each iterator in a multi-iterator object, *multi*, to the",
              "given :math:`N` -dimensional *destination* where :math:`N` is the",
              "number of dimensions in the broadcasted array."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "void PyArray_MultiIter_GOTO1D(PyObject* multi, npy_intp index)",
            "content": "Advance each iterator in a multi-iterator object, *multi*, to the\ncorresponding location of the *index* into the flattened\nbroadcasted array.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_MultiIter_NOTDONE(PyObject* multi)",
            "content": "Evaluates TRUE as long as the multi-iterator has not looped\nthrough all of the elements (of the broadcasted result), otherwise\nit evaluates FALSE.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_Broadcast(PyArrayMultiIterObject* mit)",
            "content": "This function encapsulates the broadcasting rules. The *mit*\ncontainer should already contain iterators for all the arrays that\nneed to be broadcast. On return, these iterators will be adjusted\nso that iteration over each simultaneously will accomplish the\nbroadcasting. A negative number is returned if an error occurs.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_RemoveSmallest(PyArrayMultiIterObject* mit)",
            "content": "This function takes a multi-iterator object that has been\npreviously \"broadcasted,\" finds the dimension with the smallest\n\"sum of strides\" in the broadcasted result and adapts all the\niterators so as not to iterate over that dimension (by effectively\nmaking them of length-1 in that dimension). The corresponding\ndimension is returned unless *mit* ->nd is 0, then -1 is\nreturned. This function is useful for constructing ufunc-like\nroutines that broadcast their inputs correctly and then call a\nstrided 1-d version of the routine as the inner-loop.  This 1-d\nversion is usually optimized for speed and for this reason the\nloop should be performed over the axis that won't require large\nstride jumps.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Broadcasting (multi-iterators)"
    },
    {
      "children": [
        {
          "data": {
            "children": [],
            "kind": "versionadded",
            "title": "1.4.0"
          },
          "type": "Admonition"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Neighborhood iterators are subclasses of the iterator object, and can be used to iter over a neighborhood of a point. For example, you may want to iterate over every voxel of a 3d image, and for every such voxel, iterate over an hypercube. Neighborhood iterator automatically handle boundaries, thus making this kind of code much easier to write than manual boundaries handling, at the cost of a slight overhead."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_NeighborhoodIterNew( \\",
            "content": "PyArrayIterObject* iter, npy_intp bounds, int mode, \\\nPyArrayObject* fill_value)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "This function creates a new neighborhood iterator from an existing",
              "iterator.  The neighborhood will be computed relatively to the position",
              "currently pointed by *iter*, the bounds define the shape of the",
              "neighborhood iterator, and the mode argument the boundaries handling mode.",
              "",
              "The *bounds* argument is expected to be a (2 * iter->ao->nd) arrays, such",
              "as the range bound[2*i]->bounds[2*i+1] defines the range where to walk for",
              "dimension i (both bounds are included in the walked coordinates). The",
              "bounds should be ordered for each dimension (bounds[2*i] <= bounds[2*i+1]).",
              "",
              "The mode should be one of:",
              "",
              ".. c:macro:: NPY_NEIGHBORHOOD_ITER_ZERO_PADDING",
              "",
              "        Zero padding. Outside bounds values will be 0.",
              "",
              ".. c:macro:: NPY_NEIGHBORHOOD_ITER_ONE_PADDING",
              "",
              "        One padding, Outside bounds values will be 1.",
              "",
              ".. c:macro:: NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING",
              "",
              "        Constant padding. Outside bounds values will be the",
              "        same as the first item in fill_value.",
              "",
              ".. c:macro:: NPY_NEIGHBORHOOD_ITER_MIRROR_PADDING",
              "",
              "        Mirror padding. Outside bounds values will be as if the",
              "        array items were mirrored. For example, for the array [1, 2, 3, 4],",
              "        x[-2] will be 2, x[-2] will be 1, x[4] will be 4, x[5] will be 1,",
              "        etc...",
              "",
              ".. c:macro:: NPY_NEIGHBORHOOD_ITER_CIRCULAR_PADDING",
              "",
              "        Circular padding. Outside bounds values will be as if the array",
              "        was repeated. For example, for the array [1, 2, 3, 4], x[-2] will",
              "        be 3, x[-2] will be 4, x[4] will be 1, x[5] will be 2, etc...",
              "",
              "If the mode is constant filling (`NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING`),",
              "fill_value should point to an array object which holds the filling value",
              "(the first item will be the filling value if the array contains more than",
              "one item). For other cases, fill_value may be NULL.",
              "",
              "- The iterator holds a reference to iter",
              "- Return NULL on failure (in which case the reference count of iter is not",
              "  changed)",
              "- iter itself can be a Neighborhood iterator: this can be useful for .e.g",
              "  automatic boundaries handling",
              "- the object returned by this function should be safe to use as a normal",
              "  iterator",
              "- If the position of iter is changed, any subsequent call to",
              "  PyArrayNeighborhoodIter_Next is undefined behavior, and",
              "  PyArrayNeighborhoodIter_Reset must be called.",
              "- If the position of iter is not the beginning of the data and the",
              "  underlying data for iter is contiguous, the iterator will point to the",
              "  start of the data instead of position pointed by iter.",
              "  To avoid this situation, iter should be moved to the required position",
              "  only after the creation of iterator, and PyArrayNeighborhoodIter_Reset",
              "  must be called.",
              "",
              ".. code-block:: c",
              "",
              "   PyArrayIterObject *iter;",
              "   PyArrayNeighborhoodIterObject *neigh_iter;",
              "   iter = PyArray_IterNew(x);",
              "",
              "   /*For a 3x3 kernel */",
              "   bounds = {-1, 1, -1, 1};",
              "   neigh_iter = (PyArrayNeighborhoodIterObject*)PyArray_NeighborhoodIterNew(",
              "        iter, bounds, NPY_NEIGHBORHOOD_ITER_ZERO_PADDING, NULL);",
              "",
              "   for(i = 0; i < iter->size; ++i) {",
              "        for (j = 0; j < neigh_iter->size; ++j) {",
              "                /* Walk around the item currently pointed by iter->dataptr */",
              "                PyArrayNeighborhoodIter_Next(neigh_iter);",
              "        }",
              "",
              "        /* Move to the next point of iter */",
              "        PyArrayIter_Next(iter);",
              "        PyArrayNeighborhoodIter_Reset(neigh_iter);",
              "   }"
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArrayNeighborhoodIter_Reset( \\",
            "content": "PyArrayNeighborhoodIterObject* iter)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Reset the iterator position to the first point of the neighborhood. This",
              "should be called whenever the iter argument given at",
              "PyArray_NeighborhoodIterObject is changed (see example)"
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArrayNeighborhoodIter_Next( \\",
            "content": "PyArrayNeighborhoodIterObject* iter)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "After this call, iter->dataptr points to the next point of the",
              "neighborhood. Calling this function after every point of the",
              "neighborhood has been visited is undefined."
            ]
          },
          "type": "BlockQuote"
        }
      ],
      "title": "Neighborhood iterator"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Array mapping is the machinery behind advanced indexing."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_MapIterArray(PyArrayObject *a, \\",
            "content": "PyObject *index)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Use advanced indexing to iterate an array."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "void PyArray_MapIterSwapAxes(PyArrayMapIterObject *mit, \\",
            "content": "PyArrayObject **ret, int getmap)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Swap the axes to or from their inserted form. ``MapIter`` always puts the",
              "advanced (array) indices first in the iteration. But if they are",
              "consecutive, it will insert/transpose them back before returning.",
              "This is stored as ``mit->consec != 0`` (the place where they are inserted).",
              "For assignments, the opposite happens: the values to be assigned are",
              "transposed (``getmap=1`` instead of ``getmap=0``). ``getmap=0`` and",
              "``getmap=1`` undo the other operation."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "void PyArray_MapIterNext(PyArrayMapIterObject *mit)",
            "content": "This function needs to update the state of the map iterator\nand point ``mit->dataptr`` to the memory-location of the next object.\n\nNote that this function never handles an extra operand but provides\ncompatibility for an old (exposed) API.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_MapIterArrayCopyIfOverlap(PyArrayObject *a, \\",
            "content": "PyObject *index, int copy_if_overlap, PyArrayObject *extra_op)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Similar to :c:func:`PyArray_MapIterArray` but with an additional",
              "``copy_if_overlap`` argument. If ``copy_if_overlap != 0``, checks if ``a``",
              "has memory overlap with any of the arrays in ``index`` and with",
              "``extra_op``, and make copies as appropriate to avoid problems if the",
              "input is modified during the iteration. ``iter->array`` may contain a",
              "copied array (WRITEBACKIFCOPY set)."
            ]
          },
          "type": "BlockQuote"
        }
      ],
      "title": "Array mapping"
    },
    {
      "children": [
        {
          "data": {
            "argument": "PyObject* PyArray_Return(PyArrayObject* arr)",
            "content": "This function steals a reference to *arr*.\n\nThis function checks to see if *arr* is a 0-dimensional array and,\nif so, returns the appropriate array scalar. It should be used\nwhenever 0-dimensional arrays could be returned to Python.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_Scalar( \\",
            "content": "void* data, PyArray_Descr* dtype, PyObject* base)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Return an array scalar object of the given *dtype* by **copying**",
              "from memory pointed to by *data*.  *base* is expected to be the",
              "array object that is the owner of the data.  *base* is required",
              "if `dtype` is a ``void`` scalar, or if the ``NPY_USE_GETITEM``",
              "flag is set and it is known that the ``getitem`` method uses",
              "the ``arr`` argument without checking if it is ``NULL``.  Otherwise",
              "`base` may be ``NULL``.",
              "",
              "If the data is not in native byte order (as indicated by",
              "``dtype->byteorder``) then this function will byteswap the data,",
              "because array scalars are always in correct machine-byte order."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_ToScalar(void* data, PyArrayObject* arr)",
            "content": "Return an array scalar object of the type and itemsize indicated\nby the array object *arr* copied from the memory pointed to by\n*data* and swapping if the data in *arr* is not in machine\nbyte-order.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_FromScalar( \\",
            "content": "PyObject* scalar, PyArray_Descr* outcode)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Return a 0-dimensional array of type determined by *outcode* from",
              "*scalar* which should be an array-scalar object. If *outcode* is",
              "NULL, then the type is determined from *scalar*."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "void PyArray_ScalarAsCtype(PyObject* scalar, void* ctypeptr)",
            "content": "Return in *ctypeptr* a pointer to the actual value in an array\nscalar. There is no error checking so *scalar* must be an\narray-scalar object, and ctypeptr must have enough space to hold\nthe correct type. For flexible-sized types, a pointer to the data\nis copied into the memory of *ctypeptr*, for all other types, the\nactual data is copied into the address pointed to by *ctypeptr*.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void PyArray_CastScalarToCtype( \\",
            "content": "PyObject* scalar, void* ctypeptr, PyArray_Descr* outcode)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Return the data (cast to the data type indicated by *outcode*)",
              "from the array-scalar, *scalar*, into the memory pointed to by",
              "*ctypeptr* (which must be large enough to handle the incoming",
              "memory)."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_TypeObjectFromType(int type)",
            "content": "Returns a scalar type-object from a type-number, *type*\n. Equivalent to :c:func:`PyArray_DescrFromType` (*type*)->typeobj\nexcept for reference counting and error-checking. Returns a new\nreference to the typeobject on success or ``NULL`` on failure.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_SCALARKIND PyArray_ScalarKind( \\",
            "content": "int typenum, PyArrayObject** arr)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "See the function :c:func:`PyArray_MinScalarType` for an alternative",
              "mechanism introduced in NumPy 1.6.0.",
              "",
              "Return the kind of scalar represented by *typenum* and the array",
              "in *\\*arr* (if *arr* is not ``NULL`` ). The array is assumed to be",
              "rank-0 and only used if *typenum* represents a signed integer. If",
              "*arr* is not ``NULL`` and the first element is negative then",
              ":c:data:`NPY_INTNEG_SCALAR` is returned, otherwise",
              ":c:data:`NPY_INTPOS_SCALAR` is returned. The possible return values",
              "are the enumerated values in :c:type:`NPY_SCALARKIND`."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArray_CanCoerceScalar( \\",
            "content": "char thistype, char neededtype, NPY_SCALARKIND scalar)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "See the function :c:func:`PyArray_ResultType` for details of",
              "NumPy type promotion, updated in NumPy 1.6.0.",
              "",
              "Implements the rules for scalar coercion. Scalars are only",
              "silently coerced from thistype to neededtype if this function",
              "returns nonzero.  If scalar is :c:data:`NPY_NOSCALAR`, then this",
              "function is equivalent to :c:func:`PyArray_CanCastSafely`. The rule is",
              "that scalars of the same KIND can be coerced into arrays of the",
              "same KIND. This rule means that high-precision scalars will never",
              "cause low-precision arrays of the same KIND to be upcast."
            ]
          },
          "type": "BlockQuote"
        }
      ],
      "title": "Array Scalars"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "Data-type objects must be reference counted so be aware of the action on the data-type reference of different C-API calls. The standard rule is that when a data-type object is returned it is a new reference.  Functions that take "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": "c",
                        "role": "expr",
                        "value": "PyArray_Descr *"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " objects and return arrays steal references to the data-type their inputs unless otherwise noted. Therefore, you must own a reference to any data-type object used as input to such a function."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ],
            "kind": "warning",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "argument": "int PyArray_DescrCheck(PyObject* obj)",
            "content": "Evaluates as true if *obj* is a data-type object ( :c:expr:`PyArray_Descr *` ).",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyArray_Descr* PyArray_DescrNew(PyArray_Descr* obj)",
            "content": "Return a new data-type object copied from *obj* (the fields\nreference is just updated so that the new object points to the\nsame fields dictionary if any).",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyArray_Descr* PyArray_DescrNewFromType(int typenum)",
            "content": "Create a new data-type object from the built-in (or\nuser-registered) data-type indicated by *typenum*. All builtin\ntypes should not have any of their fields changed. This creates a\nnew copy of the :c:type:`PyArray_Descr` structure so that you can fill\nit in as appropriate. This function is especially needed for\nflexible data-types which need to have a new elsize member in\norder to be meaningful in array construction.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyArray_Descr* PyArray_DescrNewByteorder( \\",
            "content": "PyArray_Descr* obj, char newendian)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Create a new data-type object with the byteorder set according to",
              "*newendian*. All referenced data-type objects (in subdescr and",
              "fields members of the data-type object) are also changed",
              "(recursively).",
              "",
              "The value of *newendian* is one of these macros:"
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "value": "..\n    dedent the enumeration of flags to avoid missing references sphinx warnings"
          },
          "type": "Comment"
        },
        {
          "data": {
            "argument": "NPY_IGNORE",
            "content": "NPY_SWAP\nNPY_NATIVE\nNPY_LITTLE\nNPY_BIG",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "If a byteorder of :c:data:`NPY_IGNORE` is encountered it",
              "is left alone. If newendian is :c:data:`NPY_SWAP`, then all byte-orders",
              "are swapped. Other valid newendian values are :c:data:`NPY_NATIVE`,",
              ":c:data:`NPY_LITTLE`, and :c:data:`NPY_BIG` which all cause",
              "the returned data-typed descriptor (and all it's",
              "referenced data-type descriptors) to have the corresponding byte-",
              "order."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyArray_Descr* PyArray_DescrFromObject( \\",
            "content": "PyObject* op, PyArray_Descr* mintype)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Determine an appropriate data-type object from the object *op*",
              "(which should be a \"nested\" sequence object) and the minimum",
              "data-type descriptor mintype (which can be ``NULL`` ). Similar in",
              "behavior to array(*op*).dtype. Don't confuse this function with",
              ":c:func:`PyArray_DescrConverter`. This function essentially looks at",
              "all the objects in the (nested) sequence and determines the",
              "data-type from the elements it finds."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyArray_Descr* PyArray_DescrFromScalar(PyObject* scalar)",
            "content": "Return a data-type object from an array-scalar object. No checking\nis done to be sure that *scalar* is an array scalar. If no\nsuitable data-type can be determined, then a data-type of\n:c:data:`NPY_OBJECT` is returned by default.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyArray_Descr* PyArray_DescrFromType(int typenum)",
            "content": "Returns a data-type object corresponding to *typenum*. The\n*typenum* can be one of the enumerated types, a character code for\none of the enumerated types, or a user-defined type. If you want to use a\nflexible size array, then you need to ``flexible typenum`` and set the\nresults ``elsize`` parameter to the desired size. The typenum is one of the\n:c:data:`NPY_TYPES`.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_DescrConverter(PyObject* obj, PyArray_Descr** dtype)",
            "content": "Convert any compatible Python object, *obj*, to a data-type object\nin *dtype*. A large number of Python objects can be converted to\ndata-type objects. See :ref:`arrays.dtypes` for a complete\ndescription. This version of the converter converts None objects\nto a :c:data:`NPY_DEFAULT_TYPE` data-type object. This function can\nbe used with the \"O&\" character code in :c:func:`PyArg_ParseTuple`\nprocessing.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_DescrConverter2( \\",
            "content": "PyObject* obj, PyArray_Descr** dtype)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Convert any compatible Python object, *obj*, to a data-type",
              "object in *dtype*. This version of the converter converts None",
              "objects so that the returned data-type is ``NULL``. This function",
              "can also be used with the \"O&\" character in PyArg_ParseTuple",
              "processing."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int Pyarray_DescrAlignConverter( \\",
            "content": "PyObject* obj, PyArray_Descr** dtype)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Like :c:func:`PyArray_DescrConverter` except it aligns C-struct-like",
              "objects on word-boundaries as the compiler would."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int Pyarray_DescrAlignConverter2( \\",
            "content": "PyObject* obj, PyArray_Descr** dtype)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Like :c:func:`PyArray_DescrConverter2` except it aligns C-struct-like",
              "objects on word-boundaries as the compiler would."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "PyObject *PyArray_FieldNames(PyObject* dict)",
            "content": "Take the fields dictionary, *dict*, such as the one attached to a\ndata-type object and construct an ordered-list of field names such\nas is stored in the names field of the :c:type:`PyArray_Descr` object.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Data-type descriptors"
    },
    {
      "children": [],
      "title": "Conversion Utilities"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "All of these functions can be used in "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArg_ParseTuple"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " (...) with the \"O&\" format specifier to automatically convert any Python object to the required C-object. All of these functions return "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NPY_SUCCEED"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " if successful and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NPY_FAIL"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " if not. The first argument to all of these function is a Python object. The second argument is the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "content": {
                    "value": "address"
                  }
                },
                "type": "Strong"
              },
              {
                "data": {
                  "value": " of the C-type to convert the Python object to."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "Be sure to understand what steps you should take to manage the memory when using these conversion functions. These functions can require freeing memory, and/or altering the reference counts of specific objects based on your use."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ],
            "kind": "warning",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "argument": "int PyArray_Converter(PyObject* obj, PyObject** address)",
            "content": "Convert any Python object to a :c:type:`PyArrayObject`. If\n:c:func:`PyArray_Check` (*obj*) is TRUE then its reference count is\nincremented and a reference placed in *address*. If *obj* is not\nan array, then convert it to an array using :c:func:`PyArray_FromAny`\n. No matter what is returned, you must DECREF the object returned\nby this routine in *address* when you are done with it.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_OutputConverter( \\",
            "content": "PyObject* obj, PyArrayObject** address)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "This is a default converter for output arrays given to",
              "functions. If *obj* is :c:data:`Py_None` or ``NULL``, then *\\*address*",
              "will be ``NULL`` but the call will succeed. If :c:func:`PyArray_Check` (",
              "*obj*) is TRUE then it is returned in *\\*address* without",
              "incrementing its reference count."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArray_IntpConverter(PyObject* obj, PyArray_Dims* seq)",
            "content": "Convert any Python sequence, *obj*, smaller than :c:data:`NPY_MAXDIMS`\nto a C-array of :c:type:`npy_intp`. The Python object could also be a\nsingle number. The *seq* variable is a pointer to a structure with\nmembers ptr and len. On successful return, *seq* ->ptr contains a\npointer to memory that must be freed, by calling :c:func:`PyDimMem_FREE`,\nto avoid a memory leak. The restriction on memory size allows this\nconverter to be conveniently used for sequences intended to be\ninterpreted as array shapes.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_BufferConverter(PyObject* obj, PyArray_Chunk* buf)",
            "content": "Convert any Python object, *obj*, with a (single-segment) buffer\ninterface to a variable with members that detail the object's use\nof its chunk of memory. The *buf* variable is a pointer to a\nstructure with base, ptr, len, and flags members. The\n:c:type:`PyArray_Chunk` structure is binary compatible with the\nPython's buffer object (through its len member on 32-bit platforms\nand its ptr member on 64-bit platforms or in Python 2.5). On\nreturn, the base member is set to *obj* (or its base if *obj* is\nalready a buffer object pointing to another object). If you need\nto hold on to the memory be sure to INCREF the base member. The\nchunk of memory is pointed to by *buf* ->ptr member and has length\n*buf* ->len. The flags member of *buf* is :c:data:`NPY_ARRAY_ALIGNED`\nwith the :c:data:`NPY_ARRAY_WRITEABLE` flag set if *obj* has\na writeable buffer interface.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_AxisConverter(PyObject* obj, int* axis)",
            "content": "Convert a Python object, *obj*, representing an axis argument to\nthe proper value for passing to the functions that take an integer\naxis. Specifically, if *obj* is None, *axis* is set to\n:c:data:`NPY_MAXDIMS` which is interpreted correctly by the C-API\nfunctions that take axis arguments.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_BoolConverter(PyObject* obj, npy_bool* value)",
            "content": "Convert any Python object, *obj*, to :c:data:`NPY_TRUE` or\n:c:data:`NPY_FALSE`, and place the result in *value*.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ByteorderConverter(PyObject* obj, char* endian)",
            "content": "Convert Python strings into the corresponding byte-order\ncharacter:\n'>', '<', 's', '=', or '\\|'.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_SortkindConverter(PyObject* obj, NPY_SORTKIND* sort)",
            "content": "Convert Python strings into one of :c:data:`NPY_QUICKSORT` (starts\nwith 'q' or 'Q'), :c:data:`NPY_HEAPSORT` (starts with 'h' or 'H'),\n:c:data:`NPY_MERGESORT` (starts with 'm' or 'M') or :c:data:`NPY_STABLESORT`\n(starts with 't' or 'T'). :c:data:`NPY_MERGESORT` and :c:data:`NPY_STABLESORT`\nare aliased to each other for backwards compatibility and may refer to one\nof several stable sorting algorithms depending on the data type.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_SearchsideConverter( \\",
            "content": "PyObject* obj, NPY_SEARCHSIDE* side)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Convert Python strings into one of :c:data:`NPY_SEARCHLEFT` (starts with 'l'",
              "or 'L'), or :c:data:`NPY_SEARCHRIGHT` (starts with 'r' or 'R')."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArray_OrderConverter(PyObject* obj, NPY_ORDER* order)",
            "content": "Convert the Python strings 'C', 'F', 'A', and 'K' into the :c:type:`NPY_ORDER`\nenumeration :c:data:`NPY_CORDER`, :c:data:`NPY_FORTRANORDER`,\n:c:data:`NPY_ANYORDER`, and :c:data:`NPY_KEEPORDER`.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_CastingConverter( \\",
            "content": "PyObject* obj, NPY_CASTING* casting)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Convert the Python strings 'no', 'equiv', 'safe', 'same_kind', and",
              "'unsafe' into the :c:type:`NPY_CASTING` enumeration :c:data:`NPY_NO_CASTING`,",
              ":c:data:`NPY_EQUIV_CASTING`, :c:data:`NPY_SAFE_CASTING`,",
              ":c:data:`NPY_SAME_KIND_CASTING`, and :c:data:`NPY_UNSAFE_CASTING`."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArray_ClipmodeConverter( \\",
            "content": "PyObject* object, NPY_CLIPMODE* val)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Convert the Python strings 'clip', 'wrap', and 'raise' into the",
              ":c:type:`NPY_CLIPMODE` enumeration :c:data:`NPY_CLIP`, :c:data:`NPY_WRAP`,",
              "and :c:data:`NPY_RAISE`."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArray_ConvertClipmodeSequence( \\",
            "content": "PyObject* object, NPY_CLIPMODE* modes, int n)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Converts either a sequence of clipmodes or a single clipmode into",
              "a C array of :c:type:`NPY_CLIPMODE` values. The number of clipmodes *n*",
              "must be known before calling this function. This function is provided",
              "to help functions allow a different clipmode for each dimension."
            ]
          },
          "type": "BlockQuote"
        }
      ],
      "title": "For use with :c:func:`PyArg_ParseTuple`"
    },
    {
      "children": [
        {
          "data": {
            "argument": "int PyArray_PyIntAsInt(PyObject* op)",
            "content": "Convert all kinds of Python objects (including arrays and array\nscalars) to a standard integer. On error, -1 is returned and an\nexception set. You may find useful the macro:\n\n.. code-block:: c\n\n    #define error_converting(x) (((x) == -1) && PyErr_Occurred())",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "npy_intp PyArray_PyIntAsIntp(PyObject* op)",
            "content": "Convert all kinds of Python objects (including arrays and array\nscalars) to a (platform-pointer-sized) integer. On error, -1 is\nreturned and an exception set.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_IntpFromSequence( \\",
            "content": "PyObject* seq, npy_intp* vals, int maxvals)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": [
              "Convert any Python sequence (or single Python number) passed in as",
              "*seq* to (up to) *maxvals* pointer-sized integers and place them",
              "in the *vals* array. The sequence can be smaller then *maxvals* as",
              "the number of converted objects is returned."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "int PyArray_TypestrConvert(int itemsize, int gentype)",
            "content": "Convert typestring characters (with *itemsize*) to basic\nenumerated data types. The typestring character corresponding to\nsigned and unsigned integers, floating point numbers, and\ncomplex-floating point numbers are recognized and converted. Other\nvalues of gentype are returned. This function can be used to\nconvert, for example, the string 'f4' to :c:data:`NPY_FLOAT32`.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Other conversions"
    },
    {
      "children": [],
      "title": "Miscellaneous"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "In order to make use of the C-API from another extension module, the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "import_array"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " function must be called. If the extension module is self-contained in a single .c file, then that is all that needs to be done. If, however, the extension module involves multiple files where the C-API is needed then some additional steps must be taken."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "void import_array(void)",
            "content": "This function must be called in the initialization section of a\nmodule that will make use of the C-API. It imports the module\nwhere the function-pointer table is stored and points the correct\nvariable to it.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PY_ARRAY_UNIQUE_SYMBOL",
            "content": "",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NO_IMPORT_ARRAY",
            "content": "Using these #defines you can use the C-API in multiple files for a\nsingle extension module. In each file you must define\n:c:macro:`PY_ARRAY_UNIQUE_SYMBOL` to some name that will hold the\nC-API (*e.g.* myextension_ARRAY_API). This must be done **before**\nincluding the numpy/arrayobject.h file. In the module\ninitialization routine you call :c:func:`import_array`. In addition,\nin the files that do not have the module initialization\nsub_routine define :c:macro:`NO_IMPORT_ARRAY` prior to including\nnumpy/arrayobject.h.\n\nSuppose I have two files coolmodule.c and coolhelper.c which need\nto be compiled and linked into a single extension module. Suppose\ncoolmodule.c contains the required initcool module initialization\nfunction (with the import_array() function called). Then,\ncoolmodule.c would have at the top:\n\n.. code-block:: c\n\n    #define PY_ARRAY_UNIQUE_SYMBOL cool_ARRAY_API\n    #include numpy/arrayobject.h\n\nOn the other hand, coolhelper.c would contain at the top:\n\n.. code-block:: c\n\n    #define NO_IMPORT_ARRAY\n    #define PY_ARRAY_UNIQUE_SYMBOL cool_ARRAY_API\n    #include numpy/arrayobject.h\n\nYou can also put the common two last lines into an extension-local\nheader file as long as you make sure that NO_IMPORT_ARRAY is\n#defined before #including that file.\n\nInternally, these #defines work as follows:\n\n    * If neither is defined, the C-API is declared to be\n      ``static void**``, so it is only visible within the\n      compilation unit that #includes numpy/arrayobject.h.\n    * If :c:macro:`PY_ARRAY_UNIQUE_SYMBOL` is #defined, but\n      :c:macro:`NO_IMPORT_ARRAY` is not, the C-API is declared to\n      be ``void**``, so that it will also be visible to other\n      compilation units.\n    * If :c:macro:`NO_IMPORT_ARRAY` is #defined, regardless of\n      whether :c:macro:`PY_ARRAY_UNIQUE_SYMBOL` is, the C-API is\n      declared to be ``extern void**``, so it is expected to\n      be defined in another compilation unit.\n    * Whenever :c:macro:`PY_ARRAY_UNIQUE_SYMBOL` is #defined, it\n      also changes the name of the variable holding the C-API, which\n      defaults to ``PyArray_API``, to whatever the macro is\n      #defined to.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Importing the API"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Because python extensions are not used in the same way as usual libraries on most platforms, some errors cannot be automatically detected at build time or even runtime. For example, if you build an extension using a function available only for numpy >= 1.3.0, and you import the extension later with numpy 1.2, you will not get an import error (but almost certainly a segmentation fault when calling the function). That's why several functions are provided to check for numpy versions. The macros "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NPY_VERSION"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "  and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NPY_FEATURE_VERSION"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " corresponds to the numpy version used to build the extension, whereas the versions returned by the functions "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_GetNDArrayCVersion"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_GetNDArrayCFeatureVersion"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " corresponds to the runtime numpy's version."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The rules for ABI and API compatibilities can be summarized as follows:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": [
              "* Whenever :c:data:`NPY_VERSION` != ``PyArray_GetNDArrayCVersion()``, the",
              "  extension has to be recompiled (ABI incompatibility).",
              "* :c:data:`NPY_VERSION` == ``PyArray_GetNDArrayCVersion()`` and",
              "  :c:data:`NPY_FEATURE_VERSION` <= ``PyArray_GetNDArrayCFeatureVersion()`` means",
              "  backward compatible changes."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "ABI incompatibility is automatically detected in every numpy's version. API incompatibility detection was added in numpy 1.4.0. If you want to supported many different numpy versions with one extension binary, you have to build your extension with the lowest "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NPY_FEATURE_VERSION"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " as possible."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "NPY_VERSION",
            "content": "The current version of the ndarray object (check to see if this\nvariable is defined to guarantee the ``numpy/arrayobject.h`` header is\nbeing used).",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_FEATURE_VERSION",
            "content": "The current version of the C-API.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "unsigned int PyArray_GetNDArrayCVersion(void)",
            "content": "This just returns the value :c:data:`NPY_VERSION`. :c:data:`NPY_VERSION`\nchanges whenever a backward incompatible change at the ABI level. Because\nit is in the C-API, however, comparing the output of this function from the\nvalue defined in the current header gives a way to test if the C-API has\nchanged thus requiring a re-compilation of extension modules that use the\nC-API. This is automatically checked in the function :c:func:`import_array`.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "unsigned int PyArray_GetNDArrayCFeatureVersion(void)",
            "content": ".. versionadded:: 1.4.0\n\nThis just returns the value :c:data:`NPY_FEATURE_VERSION`.\n:c:data:`NPY_FEATURE_VERSION` changes whenever the API changes (e.g. a\nfunction is added). A changed value does not always require a recompile.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Checking the API Version"
    },
    {
      "children": [
        {
          "data": {
            "argument": "int PyArray_SetNumericOps(PyObject* dict)",
            "content": "NumPy stores an internal table of Python callable objects that are\nused to implement arithmetic operations for arrays as well as\ncertain array calculation methods. This function allows the user\nto replace any or all of these Python objects with their own\nversions. The keys of the dictionary, *dict*, are the named\nfunctions to replace and the paired value is the Python callable\nobject to use. Care should be taken that the function used to\nreplace an internal array operation does not itself call back to\nthat internal array operation (unless you have designed the\nfunction to handle that), or an unchecked infinite recursion can\nresult (possibly causing program crash). The key names that\nrepresent operations that can be replaced are:\n\n    **add**, **subtract**, **multiply**, **divide**,\n    **remainder**, **power**, **square**, **reciprocal**,\n    **ones_like**, **sqrt**, **negative**, **positive**,\n    **absolute**, **invert**, **left_shift**, **right_shift**,\n    **bitwise_and**, **bitwise_xor**, **bitwise_or**,\n    **less**, **less_equal**, **equal**, **not_equal**,\n    **greater**, **greater_equal**, **floor_divide**,\n    **true_divide**, **logical_or**, **logical_and**,\n    **floor**, **ceil**, **maximum**, **minimum**, **rint**.\n\n\nThese functions are included here because they are used at least once\nin the array object's methods. The function returns -1 (without\nsetting a Python Error) if one of the objects being assigned is not\ncallable.\n\n.. deprecated:: 1.16",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyObject* PyArray_GetNumericOps(void)",
            "content": "Return a Python dictionary containing the callable Python objects\nstored in the internal arithmetic operation table. The keys of\nthis dictionary are given in the explanation for :c:func:`PyArray_SetNumericOps`.\n\n.. deprecated:: 1.16",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void PyArray_SetStringFunction(PyObject* op, int repr)",
            "content": "This function allows you to alter the tp_str and tp_repr methods\nof the array object to any Python function. Thus you can alter\nwhat happens for all arrays when str(arr) or repr(arr) is called\nfrom Python. The function to be called is passed in as *op*. If\n*repr* is non-zero, then this function will be called in response\nto repr(arr), otherwise the function will be called in response to\nstr(arr). No check on whether or not *op* is callable is\nperformed. The callable passed in to *op* should expect an array\nargument and should return a string to be printed.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Internal Flexibility"
    },
    {
      "children": [
        {
          "data": {
            "argument": "char* PyDataMem_NEW(size_t nbytes)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void PyDataMem_FREE(char* ptr)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "char* PyDataMem_RENEW(void * ptr, size_t newbytes)",
            "content": "Macros to allocate, free, and reallocate memory. These macros are used\ninternally to create arrays.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "npy_intp*  PyDimMem_NEW(int nd)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void PyDimMem_FREE(char* ptr)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "npy_intp* PyDimMem_RENEW(void* ptr, size_t newnd)",
            "content": "Macros to allocate, free, and reallocate dimension and strides memory.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void* PyArray_malloc(size_t nbytes)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void PyArray_free(void* ptr)",
            "content": "",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void* PyArray_realloc(npy_intp* ptr, size_t nbytes)",
            "content": "These macros use different memory allocators, depending on the\nconstant :c:data:`NPY_USE_PYMEM`. The system malloc is used when\n:c:data:`NPY_USE_PYMEM` is 0, if :c:data:`NPY_USE_PYMEM` is 1, then\nthe Python memory allocator is used.\n\n.. c:macro:: NPY_USE_PYMEM",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "int PyArray_ResolveWritebackIfCopy(PyArrayObject* obj)",
            "content": "If ``obj.flags`` has :c:data:`NPY_ARRAY_WRITEBACKIFCOPY`, this function\nclears the flags, `DECREF` s\n`obj->base` and makes it writeable, and sets ``obj->base`` to NULL. It then\ncopies ``obj->data`` to `obj->base->data`, and returns the error state of\nthe copy operation. This is the opposite of\n:c:func:`PyArray_SetWritebackIfCopyBase`. Usually this is called once\nyou are finished with ``obj``, just before ``Py_DECREF(obj)``. It may be called\nmultiple times, or with ``NULL`` input. See also\n:c:func:`PyArray_DiscardWritebackIfCopy`.\n\nReturns 0 if nothing was done, -1 on error, and 1 if action was taken.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Memory management"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "These macros are only meaningful if "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NPY_ALLOW_THREADS"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " evaluates True during compilation of the extension module. Otherwise, these macros are equivalent to whitespace. Python uses a single Global Interpreter Lock (GIL) for each Python process so that only a single thread may execute at a time (even on multi-cpu machines). When calling out to a compiled function that may take time to compute (and does not have side-effects for other threads like updated global variables), the GIL should be released so that other Python threads can run while the time-consuming calculations are performed. This can be accomplished using two groups of macros. Typically, if one macro in a group is used in a code block, all of them must be used in the same code block. Currently, "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NPY_ALLOW_THREADS"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is defined to the python-defined "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "WITH_THREADS"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " constant unless the environment variable "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NPY_NOSMP"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is set in which case "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NPY_ALLOW_THREADS"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is defined to be 0."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "NPY_ALLOW_THREADS",
            "content": "",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "WITH_THREADS",
            "content": "",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Threading support"
    },
    {
      "children": [
        {
          "data": {
            "value": [
              "This group is used to call code that may take some time but does not",
              "use any Python C-API calls. Thus, the GIL should be released during",
              "its calculation.",
              "",
              ".. c:macro:: NPY_BEGIN_ALLOW_THREADS",
              "",
              "    Equivalent to :c:macro:`Py_BEGIN_ALLOW_THREADS` except it uses",
              "    :c:data:`NPY_ALLOW_THREADS` to determine if the macro if",
              "    replaced with white-space or not.",
              "",
              ".. c:macro:: NPY_END_ALLOW_THREADS",
              "",
              "    Equivalent to :c:macro:`Py_END_ALLOW_THREADS` except it uses",
              "    :c:data:`NPY_ALLOW_THREADS` to determine if the macro if",
              "    replaced with white-space or not.",
              "",
              ".. c:macro:: NPY_BEGIN_THREADS_DEF",
              "",
              "    Place in the variable declaration area. This macro sets up the",
              "    variable needed for storing the Python state.",
              "",
              ".. c:macro:: NPY_BEGIN_THREADS",
              "",
              "    Place right before code that does not need the Python",
              "    interpreter (no Python C-API calls). This macro saves the",
              "    Python state and releases the GIL.",
              "",
              ".. c:macro:: NPY_END_THREADS",
              "",
              "    Place right after code that does not need the Python",
              "    interpreter. This macro acquires the GIL and restores the",
              "    Python state from the saved variable.",
              "",
              ".. c:function:: void NPY_BEGIN_THREADS_DESCR(PyArray_Descr *dtype)",
              "",
              "    Useful to release the GIL only if *dtype* does not contain",
              "    arbitrary Python objects which may need the Python interpreter",
              "    during execution of the loop.",
              "",
              ".. c:function:: void NPY_END_THREADS_DESCR(PyArray_Descr *dtype)",
              "",
              "    Useful to regain the GIL in situations where it was released",
              "    using the BEGIN form of this macro.",
              "",
              ".. c:function:: void NPY_BEGIN_THREADS_THRESHOLDED(int loop_size)",
              "",
              "    Useful to release the GIL only if *loop_size* exceeds a",
              "    minimum threshold, currently set to 500. Should be matched",
              "    with a :c:macro:`NPY_END_THREADS` to regain the GIL."
            ]
          },
          "type": "BlockQuote"
        }
      ],
      "title": "Group 1"
    },
    {
      "children": [
        {
          "data": {
            "value": [
              "This group is used to re-acquire the Python GIL after it has been",
              "released. For example, suppose the GIL has been released (using the",
              "previous calls), and then some path in the code (perhaps in a",
              "different subroutine) requires use of the Python C-API, then these",
              "macros are useful to acquire the GIL. These macros accomplish",
              "essentially a reverse of the previous three (acquire the LOCK saving",
              "what state it had) and then re-release it with the saved state.",
              "",
              ".. c:macro:: NPY_ALLOW_C_API_DEF",
              "",
              "    Place in the variable declaration area to set up the necessary",
              "    variable.",
              "",
              ".. c:macro:: NPY_ALLOW_C_API",
              "",
              "    Place before code that needs to call the Python C-API (when it is",
              "    known that the GIL has already been released).",
              "",
              ".. c:macro:: NPY_DISABLE_C_API",
              "",
              "    Place after code that needs to call the Python C-API (to re-release",
              "    the GIL)."
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "argument": "",
            "content": "Never use semicolons after the threading support macros.",
            "name": "tip",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Group 2"
    },
    {
      "children": [
        {
          "data": {
            "argument": "NPY_PRIORITY",
            "content": "Default priority for arrays.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_SUBTYPE_PRIORITY",
            "content": "Default subtype priority.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_SCALAR_PRIORITY",
            "content": "Default scalar priority (very small)",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "double PyArray_GetPriority(PyObject* obj, double def)",
            "content": "Return the :obj:`~numpy.class.__array_priority__` attribute (converted to a\ndouble) of *obj* or *def* if no attribute of that name\nexists. Fast returns that avoid the attribute lookup are provided\nfor objects of type :c:data:`PyArray_Type`.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Priority"
    },
    {
      "children": [
        {
          "data": {
            "argument": "NPY_BUFSIZE",
            "content": "Default size of the user-settable internal buffers.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_MIN_BUFSIZE",
            "content": "Smallest size of user-settable internal buffers.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_MAX_BUFSIZE",
            "content": "Largest size allowed for the user-settable buffers.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Default buffers"
    },
    {
      "children": [
        {
          "data": {
            "argument": "NPY_NUM_FLOATTYPE",
            "content": "The number of floating-point types",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_MAXDIMS",
            "content": "The maximum number of dimensions allowed in arrays.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_MAXARGS",
            "content": "The maximum number of array arguments that can be used in functions.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_FALSE",
            "content": "Defined as 0 for use with Bool.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_TRUE",
            "content": "Defined as 1 for use with Bool.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_FAIL",
            "content": "The return value of failed converter functions which are called using\nthe \"O&\" syntax in :c:func:`PyArg_ParseTuple`-like functions.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_SUCCEED",
            "content": "The return value of successful converter functions which are called\nusing the \"O&\" syntax in :c:func:`PyArg_ParseTuple`-like functions.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Other constants"
    },
    {
      "children": [
        {
          "data": {
            "argument": "int PyArray_SAMESHAPE(PyArrayObject *a1, PyArrayObject *a2)",
            "content": "Evaluates as True if arrays *a1* and *a2* have the same shape.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyArray_MAX(a,b)",
            "content": "Returns the maximum of *a* and *b*. If (*a*) or (*b*) are\nexpressions they are evaluated twice.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyArray_MIN(a,b)",
            "content": "Returns the minimum of *a* and *b*. If (*a*) or (*b*) are\nexpressions they are evaluated twice.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyArray_CLT(a,b)",
            "content": "",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyArray_CGT(a,b)",
            "content": "",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyArray_CLE(a,b)",
            "content": "",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyArray_CGE(a,b)",
            "content": "",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyArray_CEQ(a,b)",
            "content": "",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PyArray_CNE(a,b)",
            "content": "Implements the complex comparisons between two complex numbers\n(structures with a real and imag member) using NumPy's definition\nof the ordering which is lexicographic: comparing the real parts\nfirst and then the complex parts if the real parts are equal.",
            "name": "c:macro",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "npy_intp PyArray_REFCOUNT(PyObject* op)",
            "content": "Returns the reference count of any Python object.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void PyArray_DiscardWritebackIfCopy(PyObject* obj)",
            "content": "If ``obj.flags`` has :c:data:`NPY_ARRAY_WRITEBACKIFCOPY`, this function\nclears the flags, `DECREF` s\n`obj->base` and makes it writeable, and sets ``obj->base`` to NULL. In\ncontrast to :c:func:`PyArray_DiscardWritebackIfCopy` it makes no attempt\nto copy the data from `obj->base` This undoes\n:c:func:`PyArray_SetWritebackIfCopyBase`. Usually this is called after an\nerror when you are finished with ``obj``, just before ``Py_DECREF(obj)``.\nIt may be called multiple times, or with ``NULL`` input.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "void PyArray_XDECREF_ERR(PyObject* obj)",
            "content": "Deprecated in 1.14, use :c:func:`PyArray_DiscardWritebackIfCopy`\nfollowed by ``Py_XDECREF``\n\nDECREF's an array object which may have the\n:c:data:`NPY_ARRAY_WRITEBACKIFCOPY`\nflag set without causing the contents to be copied back into the\noriginal array. Resets the :c:data:`NPY_ARRAY_WRITEABLE` flag on the base\nobject. This is useful for recovering from an error condition when\nwriteback semantics are used, but will lead to wrong results.",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Miscellaneous Macros"
    },
    {
      "children": [
        {
          "data": {
            "argument": "NPY_SORTKIND",
            "content": "A special variable-type which can take on different values to indicate\nthe sorting algorithm being used.\n\n.. c:enumerator:: NPY_QUICKSORT\n\n.. c:enumerator:: NPY_HEAPSORT\n\n.. c:enumerator:: NPY_MERGESORT\n\n.. c:enumerator:: NPY_STABLESORT\n\n    Used as an alias of :c:data:`NPY_MERGESORT` and vica versa.\n\n.. c:enumerator:: NPY_NSORTS\n\n   Defined to be the number of sorts. It is fixed at three by the need for\n   backwards compatibility, and consequently :c:data:`NPY_MERGESORT` and\n   :c:data:`NPY_STABLESORT` are aliased to each other and may refer to one\n   of several stable sorting algorithms depending on the data type.",
            "name": "c:enum",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_SCALARKIND",
            "content": "A special variable type indicating the number of \"kinds\" of\nscalars distinguished in determining scalar-coercion rules. This\nvariable can take on the values:\n\n.. c:enumerator:: NPY_NOSCALAR\n\n.. c:enumerator:: NPY_BOOL_SCALAR\n\n.. c:enumerator:: NPY_INTPOS_SCALAR\n\n.. c:enumerator:: NPY_INTNEG_SCALAR\n\n.. c:enumerator:: NPY_FLOAT_SCALAR\n\n.. c:enumerator:: NPY_COMPLEX_SCALAR\n\n.. c:enumerator:: NPY_OBJECT_SCALAR\n\n.. c:enumerator:: NPY_NSCALARKINDS\n\n   Defined to be the number of scalar kinds\n   (not including :c:data:`NPY_NOSCALAR`).",
            "name": "c:enum",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_ORDER",
            "content": "An enumeration type indicating the element order that an array should be\ninterpreted in. When a brand new array is created, generally\nonly **NPY_CORDER** and **NPY_FORTRANORDER** are used, whereas\nwhen one or more inputs are provided, the order can be based on them.\n\n.. c:enumerator:: NPY_ANYORDER\n\n    Fortran order if all the inputs are Fortran, C otherwise.\n\n.. c:enumerator:: NPY_CORDER\n\n    C order.\n\n.. c:enumerator:: NPY_FORTRANORDER\n\n    Fortran order.\n\n.. c:enumerator:: NPY_KEEPORDER\n\n    An order as close to the order of the inputs as possible, even\n    if the input is in neither C nor Fortran order.",
            "name": "c:enum",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_CLIPMODE",
            "content": "A variable type indicating the kind of clipping that should be\napplied in certain functions.\n\n.. c:enumerator:: NPY_RAISE\n\n    The default for most operations, raises an exception if an index\n    is out of bounds.\n\n.. c:enumerator:: NPY_CLIP\n\n    Clips an index to the valid range if it is out of bounds.\n\n.. c:enumerator:: NPY_WRAP\n\n    Wraps an index to the valid range if it is out of bounds.",
            "name": "c:enum",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_SEARCHSIDE",
            "content": "A variable type indicating whether the index returned should be that of\nthe first suitable location (if :c:data:`NPY_SEARCHLEFT`) or of the last\n(if :c:data:`NPY_SEARCHRIGHT`).\n\n.. c:enumerator:: NPY_SEARCHLEFT\n\n.. c:enumerator:: NPY_SEARCHRIGHT",
            "name": "c:enum",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_SELECTKIND",
            "content": "A variable type indicating the selection algorithm being used.\n\n.. c:enumerator:: NPY_INTROSELECT",
            "name": "c:enum",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NPY_CASTING",
            "content": ".. versionadded:: 1.6\n\nAn enumeration type indicating how permissive data conversions should\nbe. This is used by the iterator added in NumPy 1.6, and is intended\nto be used more broadly in a future version.\n\n.. c:enumerator:: NPY_NO_CASTING\n\n    Only allow identical types.\n\n.. c:enumerator:: NPY_EQUIV_CASTING\n\n   Allow identical and casts involving byte swapping.\n\n.. c:enumerator:: NPY_SAFE_CASTING\n\n   Only allow casts which will not cause values to be rounded,\n   truncated, or otherwise changed.\n\n.. c:enumerator:: NPY_SAME_KIND_CASTING\n\n   Allow any safe casts, and casts between types of the same kind.\n   For example, float64 -> float32 is permitted with this rule.\n\n.. c:enumerator:: NPY_UNSAFE_CASTING\n\n   Allow any cast, no matter what kind of data loss may occur.",
            "name": "c:enum",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "",
            "content": "pair: ndarray; C-API",
            "name": "index",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Enumerated Types"
    }
  ],
  "example_section_data": {
    "children": [],
    "title": null
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "refs": [],
  "see_also": [],
  "signature": {
    "value": null
  }
}