{
  "_content": {},
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "data": {
            "args0": [],
            "directive_name": "currentmodule",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "numpy.random "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        }
      ],
      "title": null
    },
    {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "The random values produced by "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "~Generator"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " originate in a BitGenerator.  The BitGenerators do not directly provide random numbers and only contains methods used for seeding, getting or setting the state, jumping or advancing the state, and for accessing low-level wrappers for consumption by code that can efficiently access the functions provided, e.g., "
                },
                "type": "Words"
              },
              {
                "data": {
                  "target": "https://numba.pydata.org",
                  "value": "numba"
                },
                "type": "ExternalLink"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        }
      ],
      "title": "Bit Generators"
    },
    {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "The included BitGenerators are:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "value": [
                  {
                    "data": {
                      "inline": [
                        {
                          "data": {
                            "value": "PCG-64 - The default. A fast generator that can be advanced by an arbitrary   amount. See the documentation for "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": [
                              "~.PCG64.advance"
                            ]
                          },
                          "type": "Verbatim"
                        },
                        {
                          "data": {
                            "value": ". PCG-64 has   a period of "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": [
                              "2^{128}"
                            ]
                          },
                          "type": "Math"
                        },
                        {
                          "data": {
                            "value": ". See the "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "domain": null,
                            "role": null,
                            "value": "PCG author's page"
                          },
                          "type": "Directive"
                        },
                        {
                          "data": {
                            "value": " for more details   about this class of PRNG."
                          },
                          "type": "Words"
                        }
                      ],
                      "inner": []
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "value": [
                  {
                    "data": {
                      "inline": [
                        {
                          "data": {
                            "value": "PCG-64 DXSM - An upgraded version of PCG-64 with better statistical   properties in parallel contexts. See "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": [
                              "upgrading-pcg64"
                            ]
                          },
                          "type": "Verbatim"
                        },
                        {
                          "data": {
                            "value": " for more   information on these improvements."
                          },
                          "type": "Words"
                        }
                      ],
                      "inner": []
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "value": [
                  {
                    "data": {
                      "inline": [
                        {
                          "data": {
                            "value": "MT19937 - The standard Python BitGenerator. Adds a "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "domain": null,
                            "role": null,
                            "value": "MT19937.jumped"
                          },
                          "type": "Directive"
                        },
                        {
                          "data": {
                            "value": "   function that returns a new generator with state as-if "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": [
                              "2^{128}"
                            ]
                          },
                          "type": "Math"
                        },
                        {
                          "data": {
                            "value": " draws have   been made."
                          },
                          "type": "Words"
                        }
                      ],
                      "inner": []
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "value": [
                  {
                    "data": {
                      "inline": [
                        {
                          "data": {
                            "value": "Philox - A counter-based generator capable of being advanced an   arbitrary number of steps or generating independent streams. See the   "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "domain": null,
                            "role": null,
                            "value": "Random123"
                          },
                          "type": "Directive"
                        },
                        {
                          "data": {
                            "value": " page for more details about this class of bit generators."
                          },
                          "type": "Words"
                        }
                      ],
                      "inner": []
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "value": [
                  {
                    "data": {
                      "inline": [
                        {
                          "data": {
                            "value": "SFC64 - A fast generator based on random invertible mappings. Usually the   fastest generator of the four. See the "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "domain": null,
                            "role": null,
                            "value": "SFC author's page"
                          },
                          "type": "Directive"
                        },
                        {
                          "data": {
                            "value": " for (a little)   more detail."
                          },
                          "type": "Words"
                        }
                      ],
                      "inner": []
                    },
                    "type": "Paragraph"
                  }
                ]
              }
            ]
          },
          "type": "BulletList"
        },
        {
          "data": {
            "placeholder": "target",
            "value": ".. _`PCG author's page`: http://www.pcg-random.org/"
          },
          "type": "Unimplemented"
        },
        {
          "data": {
            "placeholder": "target",
            "value": ".. _`Random123`: https://www.deshawresearch.com/resources_random123.html"
          },
          "type": "Unimplemented"
        },
        {
          "data": {
            "placeholder": "target",
            "value": ".. _`SFC author's page`: http://pracrand.sourceforge.net/RNG_engines.txt"
          },
          "type": "Unimplemented"
        },
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "BitGenerator "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "args0": [
              ":maxdepth: 1"
            ],
            "directive_name": "toctree",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "MT19937 < mt19937> PCG64 < pcg64> PCG64DXSM < pcg64dxsm> Philox < philox> SFC64 < sfc64> "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Supported BitGenerators"
    },
    {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "A BitGenerator provides a stream of random values. In order to generate reproducible streams, BitGenerators support setting their initial state via a seed. All of the provided BitGenerators will take an arbitrary-sized non-negative integer, or a list of such integers, as a seed. BitGenerators need to take those inputs and process them into a high-quality internal state for the BitGenerator. All of the BitGenerators in numpy delegate that task to "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "SeedSequence"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": ", which uses hashing techniques to ensure that even low-quality seeds generate high-quality initial states."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "python"
            ],
            "directive_name": "code-block",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "from numpy.random import PCG64 bg = PCG64 ( 12345678903141592653589793) "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": ".. end_block"
          },
          "type": "Comment"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "~SeedSequence"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " is designed to be convenient for implementing best practices. We recommend that a stochastic program defaults to using entropy from the OS so that each run is different. The program should print out or log that entropy. In order to reproduce a past value, the program should allow the user to provide that value through some mechanism, a command-line argument is common, so that the user can then re-enter that entropy to reproduce the result. "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "~SeedSequence"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " can take care of everything except for communicating with the user, which is up to you."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "python"
            ],
            "directive_name": "code-block",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "from numpy.random import PCG64, SeedSequence # Get the user ' s seed somehow, maybe through `argparse`. # If the user did not provide a seed, it should return `None`. seed = get_user_seed ( ) ss = SeedSequence ( seed) print ( ' seed = { } ' .format ( ss.entropy)) bg = PCG64 ( ss) "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": ".. end_block"
          },
          "type": "Comment"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "We default to using a 128-bit integer using entropy gathered from the OS. This is a good amount of entropy to initialize all of the generators that we have in numpy. We do not recommend using small seeds below 32 bits for general use. Using just a small set of seeds to instantiate larger state spaces means that there are some initial states that are impossible to reach. This creates some biases if everyone uses such values."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "There will not be anything "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "wrong"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " with the results, per se; even a seed of 0 is perfectly fine thanks to the processing that "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "~SeedSequence"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " does. If you just need "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "some"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " fixed value for unit tests or debugging, feel free to use whatever seed you like. But if you want to make inferences from the results or publish them, drawing from a larger set of seeds is good practice."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "If you need to generate a good seed \"offline\", then "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "SeedSequence().entropy"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " or using "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "secrets.randbits(128)"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " from the standard library are both convenient ways."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "If you need to run several stochastic simulations in parallel, best practice is to construct a random generator instance for each simulation.  To make sure that the random streams have distinct initial states, you can use the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "spawn"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " method of "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "~SeedSequence"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": ". For instance, here we construct a list of 12 instances:"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "python"
            ],
            "directive_name": "code-block",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "from numpy.random import PCG64, SeedSequence # High quality initial entropy entropy = 0x87351080e25cb0fad77a44a3be03b491 base_seq = SeedSequence ( entropy) child_seqs = base_seq.spawn ( 12) # a list of 12 SeedSequences generators = [ PCG64 ( seq) for seq in child_seqs] "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": ".. end_block"
          },
          "type": "Comment"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "An alternative way is to use the fact that a "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "~SeedSequence"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " can be initialized by a tuple of elements. Here we use a base entropy value and an integer "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "worker_id"
                  ]
                },
                "type": "Verbatim"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "python"
            ],
            "directive_name": "code-block",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "from numpy.random import PCG64, SeedSequence # High quality initial entropy entropy = 0x87351080e25cb0fad77a44a3be03b491 sequences = [ SeedSequence ( ( entropy, worker_id)) for worker_id in range ( 12)] generators = [ PCG64 ( seq) for seq in sequences] "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": ".. end_block"
          },
          "type": "Comment"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Note that the sequences produced by the latter method will be distinct from those constructed via "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "~SeedSequence.spawn"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              ":toctree: generated/"
            ],
            "directive_name": "autosummary",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "SeedSequence "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Seeding and Entropy"
    }
  ],
  "example_section_data": {
    "children": [],
    "title": null
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "refs": [],
  "see_also": [],
  "signature": {
    "value": null
  }
}