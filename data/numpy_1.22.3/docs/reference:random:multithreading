{
  "_content": {},
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "The four core distributions ("
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "~.Generator.random"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "~.Generator.standard_normal"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "~.Generator.standard_exponential"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "~.Generator.standard_gamma"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ") all allow existing arrays to be filled using the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "out"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " keyword argument. Existing arrays need to be contiguous and well-behaved (writable and aligned). Under normal circumstances, arrays created using the common constructors such as "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "numpy.empty"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " will satisfy these requirements."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "This example makes use of Python 3 "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "concurrent.futures"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " to fill an array using multiple threads.  Threads are long-lived so that repeated calls do not require any additional overheads from thread creation."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "The random numbers generated are reproducible in the sense that the same seed will produce the same outputs, given that the number of threads does not change."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "ipython"
            ],
            "directive_name": "code-block",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "from numpy.random import default_rng, SeedSequence import multiprocessing import concurrent.futures import numpy as np class MultithreadedRNG : def __init__ ( self, n, seed=None, threads=None) : if threads is None : threads = multiprocessing.cpu_count ( ) self.threads = threads seq = SeedSequence ( seed) self._random_generators = [ default_rng ( s) for s in seq.spawn ( threads)] self.n = n self.executor = concurrent.futures.ThreadPoolExecutor ( threads) self.values = np.empty ( n) self.step = np.ceil ( n / threads).astype ( np.int_) def fill ( self) : def _fill ( random_state, out, first, last) : random_state.standard_normal ( out=out [ first : last]) futures = { } for i in range ( self.threads) : args = ( _fill, self._random_generators [ i], self.values, i * self.step, ( i + 1) * self.step) futures [ self.executor.submit ( *args)] = i concurrent.futures.wait ( futures) def __del__ ( self) : self.executor.shutdown ( False) "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "The multithreaded random number generator can be used to fill an array. The "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "values"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " attributes shows the zero-value before the fill and the random value after."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "ipython"
            ],
            "directive_name": "code-block",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "In [ 2] : mrng = MultithreadedRNG ( 10000000, seed=12345) ... : print ( mrng.values [ - 1]) Out [ 2] : 0.0 In [ 3] : mrng.fill ( ) ... : print ( mrng.values [ - 1]) Out [ 3] : 2.4545724517479104 "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "The time required to produce using multiple threads can be compared to the time required to generate using a single thread."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "ipython"
            ],
            "directive_name": "code-block",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "In [ 4] : print ( mrng.threads) ... : %timeit mrng.fill ( ) Out [ 4] : 4 ... : 32.8 ms \u00b1 2.71 ms per loop ( mean \u00b1 std. dev. of 7 runs, 10 loops each) "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "The single threaded call directly uses the BitGenerator."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "ipython"
            ],
            "directive_name": "code-block",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "In [ 5] : values = np.empty ( 10000000) ... : rg = default_rng ( ) ... : %timeit rg.standard_normal ( out=values) Out [ 5] : 99.6 ms \u00b1 222 \u00b5s per loop ( mean \u00b1 std. dev. of 7 runs, 10 loops each) "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "The gains are substantial and the scaling is reasonable even for arrays that are only moderately large. The gains are even larger when compared to a call that does not use an existing array due to array creation overhead."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "ipython"
            ],
            "directive_name": "code-block",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "In [ 6] : rg = default_rng ( ) ... : %timeit rg.standard_normal ( 10000000) Out [ 6] : 125 ms \u00b1 309 \u00b5s per loop ( mean \u00b1 std. dev. of 7 runs, 10 loops each) "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Note that if "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "threads"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " is not set by the user, it will be determined by "
                },
                "type": "Words"
              },
              {
                "data": {
                  "exists": true,
                  "kind": "module",
                  "reference": {
                    "kind": "api",
                    "module": "multiprocessing",
                    "path": "multiprocessing.context.BaseContext.cpu_count",
                    "version": "*"
                  },
                  "value": "multiprocessing.cpu_count()"
                },
                "type": "Link"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "args0": [
              "ipython"
            ],
            "directive_name": "code-block",
            "inner": {
              "inline": [
                {
                  "data": {
                    "value": "In [ 7] : # simulate the behavior for `threads=None`, if the machine had only one thread ... : mrng = MultithreadedRNG ( 10000000, seed=12345, threads=1) ... : print ( mrng.values [ - 1]) Out [ 7] : 1.1800150052158556 "
                  },
                  "type": "Words"
                }
              ],
              "inner": []
            }
          },
          "type": "BlockDirective"
        }
      ],
      "title": "Multithreaded Generation"
    }
  ],
  "example_section_data": {
    "children": [],
    "title": null
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "refs": [],
  "see_also": [],
  "signature": {
    "value": null
  }
}