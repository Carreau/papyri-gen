{
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "data": {
            "placeholder": "target",
            "value": ".. _f2py-examples:"
          },
          "type": "Unimplemented"
        }
      ],
      "level": 0,
      "title": null
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Below are some examples of F2PY usage. This list is not comprehensive, but can be used as a starting point when wrapping your own code."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 0,
      "title": "F2PY examples"
    },
    {
      "children": [],
      "level": 1,
      "title": "F2PY walkthrough: a basic extension module"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Consider the following subroutine, contained in a file named "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "add.f"
                  ]
                },
                "type": "Verbatim"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "./code/add.f",
            "content": "",
            "name": "literalinclude",
            "options": [
              [
                "language",
                "fortran"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "This routine simply adds the elements in two contiguous arrays and places the result in a third. The memory for all three arrays must be provided by the calling routine. A very basic interface to this routine can be automatically generated by f2py:      "
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": "python -m numpy.f2py -m add add.f"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "This command will produce an extension module named "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "addmodule.c"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " in the current directory. This extension module can now be compiled and used from Python just like any other extension module."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 2,
      "title": "Creating source for a basic extension module"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "This usage depends heavily on "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "numpy.distutils"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ", see "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": "ref",
                        "value": "f2py-bldsys"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " for more details."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "You can also get f2py to both compile "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "add.f"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " along with the produced extension module leaving only a shared-library extension file that can be imported from Python:      "
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": "python -m numpy.f2py -c -m add add.f"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "This command produces a Python extension module compatible with your platform. This module may then be imported from Python. It will contain a method for each subroutine in "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "add"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ". The docstring of each method contains information about how the module method may be called:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "python",
            "content": ">>> import add\n>>> print(add.zadd.__doc__)\nzadd(a,b,c,n)\n\nWrapper for ``zadd``.\n\nParameters\n----------\na : input rank-1 array('D') with bounds (*)\nb : input rank-1 array('D') with bounds (*)\nc : input rank-1 array('D') with bounds (*)\nn : input int",
            "name": "code-block",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "level": 2,
      "title": "Creating a compiled extension module"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The default interface is a very literal translation of the Fortran code into Python. The Fortran array arguments are converted to NumPy arrays and the integer argument should be mapped to a "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "C"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " integer. The interface will attempt to convert all arguments to their required types (and shapes) and issue an error if unsuccessful. However, because "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "f2py"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " knows nothing about the semantics of the arguments (such that "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "C"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is an output and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "n"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " should really match the array sizes), it is possible to abuse this function in ways that can cause Python to crash. For example:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "python",
            "content": ">>> add.zadd([1, 2, 3], [1, 2], [3, 4], 1000)",
            "name": "code-block",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "will cause a program crash on most systems. Under the hood, the lists are being converted to arrays but then the underlying "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "add"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " function is told to cycle way beyond the borders of the allocated memory."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "In order to improve the interface, "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "f2py"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " supports directives. This is accomplished by constructing a signature file. It is usually best to start from the interfaces that "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "f2py"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " produces in that file, which correspond to the default behavior. To get "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "f2py"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " to generate the interface file use the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "-h"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " option:      "
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": "python -m numpy.f2py -h add.pyf -m add add.f"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "This command creates the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "add.pyf"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " file in the current directory. The section of this file corresponding to "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "zadd"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "./code/add.pyf",
            "content": "",
            "name": "literalinclude",
            "options": [
              [
                "language",
                "fortran"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "By placing intent directives and checking code, the interface can be cleaned up quite a bit so the Python module method is both easier to use and more robust to malformed inputs."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "./code/add-edited.pyf",
            "content": "",
            "name": "literalinclude",
            "options": [
              [
                "language",
                "fortran"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The intent directive, intent(out) is used to tell f2py that "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "c"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is an output variable and should be created by the interface before being passed to the underlying code. The intent(hide) directive tells f2py to not allow the user to specify the variable, "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "n"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", but instead to get it from the size of "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "a"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ". The depend( "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "a"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ) directive is necessary to tell f2py that the value of n depends on the input a (so that it won't try to create the variable n until the variable a is created)."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "After modifying "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "add.pyf"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", the new Python module file can be generated by compiling both "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "add.f"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "add.pyf"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ":      "
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": "python -m numpy.f2py -c add.pyf add.f"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The new interface's docstring is:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "python",
            "content": ">>> import add\n>>> print(add.zadd.__doc__)\nc = zadd(a,b)\n\nWrapper for ``zadd``.\n\nParameters\n----------\na : input rank-1 array('D') with bounds (n)\nb : input rank-1 array('D') with bounds (n)\n\nReturns\n-------\nc : rank-1 array('D') with bounds (n)",
            "name": "code-block",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Now, the function can be called in a much more robust way:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "",
            "content": ">>> add.zadd([1, 2, 3], [4, 5, 6])\narray([5.+0.j, 7.+0.j, 9.+0.j])",
            "name": "code-block",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Notice the automatic conversion to the correct format that occurred."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 2,
      "title": "Improving the basic interface"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The robust interface of the previous section can also be generated automatically by placing the variable directives as special comments in the original Fortran code."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "For projects where the Fortran code is being actively developed, this may be preferred."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Thus, if the source code is modified to contain:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "./code/add-improved.f",
            "content": "",
            "name": "literalinclude",
            "options": [
              [
                "language",
                "fortran"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Then, one can compile the extension module using:      "
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": "python -m numpy.f2py -c -m add add.f"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The resulting signature for the function add.zadd is exactly the same one that was created previously. If the original source code had contained "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "A(N)"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " instead of "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "A(*)"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " and so forth with "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "B"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "C"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", then nearly the same interface can be obtained by placing the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "INTENT(OUT) :: C"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " comment line in the source code. The only difference is that "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "N"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " would be an optional input that would default to the length of "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "A"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 2,
      "title": "Inserting directives in Fortran source"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "This example shows a function that filters a two-dimensional array of double precision floating-point numbers using a fixed averaging filter. The advantage of using Fortran to index into multi-dimensional arrays should be clear from this example."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "./code/filter.f",
            "content": "",
            "name": "literalinclude",
            "options": [
              [
                "language",
                "fortran"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "This code can be compiled and linked into an extension module named filter using:      "
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": "python -m numpy.f2py -c -m filter filter.f"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "This will produce an extension module in the current directory with a method named "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "dfilter2d"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " that returns a filtered version of the input."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 1,
      "title": "A filtering example"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Consider the following code, saved in the file "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "myroutine.f90"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ":"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "./code/myroutine.f90",
            "content": "",
            "name": "literalinclude",
            "options": [
              [
                "language",
                "fortran"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Wrapping this with "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "python -m numpy.f2py -c myroutine.f90 -m myroutine"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", we can do the following in Python:   "
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> import numpy as np\n>>> import myroutine\n>>> x = myroutine.s(2, 3, np.array([5, 6, 7]))\n>>> x\narray([[5., 0., 0.],\n          [0., 0., 0.]])"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Now, instead of generating the extension module directly, we will create a signature file for this subroutine first. This is a common pattern for multi-step extension module generation. In this case, after running"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "python",
            "content": "python -m numpy.f2py myroutine.f90 -h myroutine.pyf",
            "name": "code-block",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "the following signature file is generated:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "./code/myroutine.pyf",
            "content": "",
            "name": "literalinclude",
            "options": [
              [
                "language",
                "fortran"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Now, if we run "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "python -m numpy.f2py -c myroutine.pyf myroutine.f90"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " we see an error; note that the signature file included a "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "depend(m,n)"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " statement for "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "x"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " which is not necessary. Indeed, editing the file above to read"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "./code/myroutine-edited.pyf",
            "content": "",
            "name": "literalinclude",
            "options": [
              [
                "language",
                "fortran"
              ]
            ]
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "and running "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "f2py -c myroutine.pyf myroutine.f90"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " yields correct results."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 1,
      "title": "``depends`` keyword example"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "target": "https://scipy.github.io/old-wiki/pages/Cookbook/f2py_and_NumPy.html",
                            "value": "Wrapping C codes using f2py"
                          },
                          "type": "ExternalLink"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "target": "https://scipy-cookbook.readthedocs.io/items/F2Py.html",
                            "value": "F2py section on the SciPy Cookbook"
                          },
                          "type": "ExternalLink"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "target": "http://websrv.cs.umt.edu/isis/index.php/F2py_example",
                            "value": "F2py example: Interactive System for Ice sheet Simulation"
                          },
                          "type": "ExternalLink"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "target": "https://scipy-cookbook.readthedocs.io/items/idx_interfacing_with_other_languages.html",
                            "value": "\"Interfacing With Other Languages\" section on the SciPy Cookbook."
                          },
                          "type": "ExternalLink"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              }
            ]
          },
          "type": "BulletList"
        }
      ],
      "level": 1,
      "title": "Read more"
    }
  ],
  "content": {},
  "example_section_data": {
    "children": [],
    "level": 0,
    "title": null
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "see_also": [],
  "signature": {
    "value": null
  }
}