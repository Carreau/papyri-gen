{
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "data": {
            "argument": "numpy",
            "content": "",
            "name": "currentmodule",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": ".. for doctests\n   >>> np.random.seed(1)"
          },
          "type": "Comment"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "Subclassing a "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "numpy.ndarray"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " is possible but if your goal is to create an array with "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": {
                          "value": "modified"
                        }
                      },
                      "type": "Emph"
                    },
                    {
                      "data": {
                        "value": " behavior, as do dask arrays for distributed computation and cupy arrays for GPU-based computation, subclassing is discouraged. Instead, using numpy's "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": "ref",
                        "value": "dispatch mechanism <basics.dispatch>"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " is recommended."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ndarray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " can be inherited from (in Python or in C) if desired. Therefore, it can form a foundation for many useful classes. Often whether to sub-class the array object or to simply use the core array component as an internal part of a new class is a difficult decision, and can be simply a matter of choice. NumPy has several tools for simplifying how your new object interacts with other array objects, and so the choice may not be significant in the end. One way to simplify the question is by asking yourself if the object you are interested in can be replaced as a single array or does it really require two or more arrays at its core."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Note that "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "asarray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " always returns the base-class ndarray. If you are confident that your use of the array object can handle any subclass of an ndarray, then "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "asanyarray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " can be used to allow subclasses to propagate more cleanly through your subroutine. In principal a subclass could redefine any aspect of the array and therefore, under strict guidelines, "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "asanyarray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " would rarely be useful. However, most subclasses of the array object will not redefine certain aspects of the array object such as the buffer interface, or the attributes of the array. One important example, however, of why your subroutine may not be able to handle an arbitrary subclass of an array is that matrices redefine the \"*\" operator to be matrix-multiplication, rather than element-by-element multiplication."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 0,
      "target": "arrays.classes",
      "title": "Standard array subclasses"
    },
    {
      "children": [
        {
          "data": {
            "argument": ":ref:`Subclassing ndarray <basics.subclassing>`",
            "content": "",
            "name": "seealso",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "NumPy provides several hooks that classes can customize:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "class.__array_ufunc__(ufunc, method, *inputs, **kwargs)",
            "content": ".. versionadded:: 1.13\n\nAny class, ndarray subclass or not, can define this method or set it to\nNone in order to override the behavior of NumPy's ufuncs. This works\nquite similarly to Python's ``__mul__`` and other binary operation routines.\n\n- *ufunc* is the ufunc object that was called.\n- *method* is a string indicating which Ufunc method was called\n  (one of ``\"__call__\"``, ``\"reduce\"``, ``\"reduceat\"``,\n  ``\"accumulate\"``, ``\"outer\"``, ``\"inner\"``).\n- *inputs* is a tuple of the input arguments to the ``ufunc``.\n- *kwargs* is a dictionary containing the optional input arguments\n  of the ufunc. If given, any ``out`` arguments, both positional\n  and keyword, are passed as a :obj:`tuple` in *kwargs*. See the\n  discussion in :ref:`ufuncs` for details.\n\nThe method should return either the result of the operation, or\n:obj:`NotImplemented` if the operation requested is not implemented.\n\nIf one of the input or output arguments has a :func:`__array_ufunc__`\nmethod, it is executed *instead* of the ufunc.  If more than one of the\narguments implements :func:`__array_ufunc__`, they are tried in the\norder: subclasses before superclasses, inputs before outputs, otherwise\nleft to right. The first routine returning something other than\n:obj:`NotImplemented` determines the result. If all of the\n:func:`__array_ufunc__` operations return :obj:`NotImplemented`, a\n:exc:`TypeError` is raised.\n\n.. note:: We intend to re-implement numpy functions as (generalized)\n    Ufunc, in which case it will become possible for them to be\n    overridden by the ``__array_ufunc__`` method.  A prime candidate is\n    :func:`~numpy.matmul`, which currently is not a Ufunc, but could be\n    relatively easily be rewritten as a (set of) generalized Ufuncs. The\n    same may happen with functions such as :func:`~numpy.median`,\n    :func:`~numpy.amin`, and :func:`~numpy.argsort`.\n\nLike with some other special methods in python, such as ``__hash__`` and\n``__iter__``, it is possible to indicate that your class does *not*\nsupport ufuncs by setting ``__array_ufunc__ = None``. Ufuncs always raise\n:exc:`TypeError` when called on an object that sets\n``__array_ufunc__ = None``.\n\nThe presence of :func:`__array_ufunc__` also influences how\n:class:`ndarray` handles binary operations like ``arr + obj`` and ``arr\n< obj`` when ``arr`` is an :class:`ndarray` and ``obj`` is an instance\nof a custom class. There are two possibilities. If\n``obj.__array_ufunc__`` is present and not None, then\n``ndarray.__add__`` and friends will delegate to the ufunc machinery,\nmeaning that ``arr + obj`` becomes ``np.add(arr, obj)``, and then\n:func:`~numpy.add` invokes ``obj.__array_ufunc__``. This is useful if you\nwant to define an object that acts like an array.\n\nAlternatively, if ``obj.__array_ufunc__`` is set to None, then as a\nspecial case, special methods like ``ndarray.__add__`` will notice this\nand *unconditionally* raise :exc:`TypeError`. This is useful if you want to\ncreate objects that interact with arrays via binary operations, but\nare not themselves arrays. For example, a units handling system might have\nan object ``m`` representing the \"meters\" unit, and want to support the\nsyntax ``arr * m`` to represent that the array has units of \"meters\", but\nnot want to otherwise interact with arrays via ufuncs or otherwise. This\ncan be done by setting ``__array_ufunc__ = None`` and defining ``__mul__``\nand ``__rmul__`` methods. (Note that this means that writing an\n``__array_ufunc__`` that always returns :obj:`NotImplemented` is not\nquite the same as setting ``__array_ufunc__ = None``: in the former\ncase, ``arr + obj`` will raise :exc:`TypeError`, while in the latter\ncase it is possible to define a ``__radd__`` method to prevent this.)\n\nThe above does not hold for in-place operators, for which :class:`ndarray`\nnever returns :obj:`NotImplemented`.  Hence, ``arr += obj`` would always\nlead to a :exc:`TypeError`.  This is because for arrays in-place operations\ncannot generically be replaced by a simple reverse operation.  (For\ninstance, by default, ``arr += obj`` would be translated to ``arr =\narr + obj``, i.e., ``arr`` would be replaced, contrary to what is expected\nfor in-place array operations.)\n\n.. note:: If you define ``__array_ufunc__``:\n\n   - If you are not a subclass of :class:`ndarray`, we recommend your\n     class define special methods like ``__add__`` and ``__lt__`` that\n     delegate to ufuncs just like ndarray does.  An easy way to do this\n     is to subclass from :class:`~numpy.lib.mixins.NDArrayOperatorsMixin`.\n   - If you subclass :class:`ndarray`, we recommend that you put all your\n     override logic in ``__array_ufunc__`` and not also override special\n     methods. This ensures the class hierarchy is determined in only one\n     place rather than separately by the ufunc machinery and by the binary\n     operation rules (which gives preference to special methods of\n     subclasses; the alternative way to enforce a one-place only hierarchy,\n     of setting :func:`__array_ufunc__` to None, would seem very\n     unexpected and thus confusing, as then the subclass would not work at\n     all with ufuncs).\n   - :class:`ndarray` defines its own :func:`__array_ufunc__`, which,\n     evaluates the ufunc if no arguments have overrides, and returns\n     :obj:`NotImplemented` otherwise. This may be useful for subclasses\n     for which :func:`__array_ufunc__` converts any instances of its own\n     class to :class:`ndarray`: it can then pass these on to its\n     superclass using ``super().__array_ufunc__(*inputs, **kwargs)``,\n     and finally return the results after possible back-conversion. The\n     advantage of this practice is that it ensures that it is possible\n     to have a hierarchy of subclasses that extend the behaviour. See\n     :ref:`Subclassing ndarray <basics.subclassing>` for details.\n\n.. note:: If a class defines the :func:`__array_ufunc__` method,\n   this disables the :func:`__array_wrap__`,\n   :func:`__array_prepare__`, :data:`__array_priority__` mechanism\n   described below for ufuncs (which may eventually be deprecated).",
            "name": "py:method",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "class.__array_function__(func, types, args, kwargs)",
            "content": ".. versionadded:: 1.16\n\n.. note::\n\n    - In NumPy 1.17, the protocol is enabled by default, but can be disabled\n      with ``NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=0``.\n    - In NumPy 1.16, you need to set the environment variable\n      ``NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1`` before importing NumPy to use\n      NumPy function overrides.\n    - Eventually, expect to ``__array_function__`` to always be enabled.\n\n-  ``func`` is an arbitrary callable exposed by NumPy's public API,\n   which was called in the form ``func(*args, **kwargs)``.\n-  ``types`` is a collection :py:class:`collections.abc.Collection`\n   of unique argument types from the original NumPy function call that\n   implement ``__array_function__``.\n-  The tuple ``args`` and dict ``kwargs`` are directly passed on from the\n   original call.\n\nAs a convenience for ``__array_function__`` implementors, ``types``\nprovides all argument types with an ``'__array_function__'`` attribute.\nThis allows implementors to quickly identify cases where they should defer\nto ``__array_function__`` implementations on other arguments.\nImplementations should not rely on the iteration order of ``types``.\n\nMost implementations of ``__array_function__`` will start with two\nchecks:\n\n1.  Is the given function something that we know how to overload?\n2.  Are all arguments of a type that we know how to handle?\n\nIf these conditions hold, ``__array_function__`` should return the result\nfrom calling its implementation for ``func(*args, **kwargs)``.  Otherwise,\nit should return the sentinel value ``NotImplemented``, indicating that the\nfunction is not implemented by these types.\n\nThere are no general requirements on the return value from\n``__array_function__``, although most sensible implementations should\nprobably return array(s) with the same type as one of the function's\narguments.\n\nIt may also be convenient to define a custom decorators (``implements``\nbelow) for registering ``__array_function__`` implementations.\n\n.. code:: python\n\n    HANDLED_FUNCTIONS = {}\n\n    class MyArray:\n        def __array_function__(self, func, types, args, kwargs):\n            if func not in HANDLED_FUNCTIONS:\n                return NotImplemented\n            # Note: this allows subclasses that don't override\n            # __array_function__ to handle MyArray objects\n            if not all(issubclass(t, MyArray) for t in types):\n                return NotImplemented\n            return HANDLED_FUNCTIONS[func](*args, **kwargs)\n\n    def implements(numpy_function):\n        \"\"\"Register an __array_function__ implementation for MyArray objects.\"\"\"\n        def decorator(func):\n            HANDLED_FUNCTIONS[numpy_function] = func\n            return func\n        return decorator\n\n    @implements(np.concatenate)\n    def concatenate(arrays, axis=0, out=None):\n        ...  # implementation of concatenate for MyArray objects\n\n    @implements(np.broadcast_to)\n    def broadcast_to(array, shape):\n        ...  # implementation of broadcast_to for MyArray objects\n\nNote that it is not required for ``__array_function__`` implementations to\ninclude *all* of the corresponding NumPy function's optional arguments\n(e.g., ``broadcast_to`` above omits the irrelevant ``subok`` argument).\nOptional arguments are only passed in to ``__array_function__`` if they\nwere explicitly used in the NumPy function call.\n\nJust like the case for builtin special methods like ``__add__``, properly\nwritten ``__array_function__`` methods should always return\n``NotImplemented`` when an unknown type is encountered. Otherwise, it will\nbe impossible to correctly override NumPy functions from another object\nif the operation also includes one of your objects.\n\nFor the most part, the rules for dispatch with ``__array_function__``\nmatch those for ``__array_ufunc__``. In particular:\n\n-  NumPy will gather implementations of ``__array_function__`` from all\n   specified inputs and call them in order: subclasses before\n   superclasses, and otherwise left to right. Note that in some edge cases\n   involving subclasses, this differs slightly from the\n   `current behavior <https://bugs.python.org/issue30140>`_ of Python.\n-  Implementations of ``__array_function__`` indicate that they can\n   handle the operation by returning any value other than\n   ``NotImplemented``.\n-  If all ``__array_function__`` methods return ``NotImplemented``,\n   NumPy will raise ``TypeError``.\n\nIf no ``__array_function__`` methods exists, NumPy will default to calling\nits own implementation, intended for use on NumPy arrays. This case arises,\nfor example, when all array-like arguments are Python numbers or lists.\n(NumPy arrays do have a ``__array_function__`` method, given below, but it\nalways returns ``NotImplemented`` if any argument other than a NumPy array\nsubclass implements ``__array_function__``.)\n\nOne deviation from the current behavior of ``__array_ufunc__`` is that\nNumPy will only call ``__array_function__`` on the *first* argument of each\nunique type. This matches Python's `rule for calling reflected methods\n<https://docs.python.org/3/reference/datamodel.html#object.__ror__>`_, and\nthis ensures that checking overloads has acceptable performance even when\nthere are a large number of overloaded arguments.",
            "name": "py:method",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "class.__array_finalize__(obj)",
            "content": "This method is called whenever the system internally allocates a\nnew array from *obj*, where *obj* is a subclass (subtype) of the\n:class:`ndarray`. It can be used to change attributes of *self*\nafter construction (so as to ensure a 2-d matrix for example), or\nto update meta-information from the \"parent.\" Subclasses inherit\na default implementation of this method that does nothing.",
            "name": "py:method",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "class.__array_prepare__(array, context=None)",
            "content": "At the beginning of every :ref:`ufunc <ufuncs-output-type>`, this\nmethod is called on the input object with the highest array\npriority, or the output object if one was specified. The output\narray is passed in and whatever is returned is passed to the ufunc.\nSubclasses inherit a default implementation of this method which\nsimply returns the output array unmodified. Subclasses may opt to\nuse this method to transform the output array into an instance of\nthe subclass and update metadata before returning the array to the\nufunc for computation.\n\n.. note:: For ufuncs, it is hoped to eventually deprecate this method in\n          favour of :func:`__array_ufunc__`.",
            "name": "py:method",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "class.__array_wrap__(array, context=None)",
            "content": "At the end of every :ref:`ufunc <ufuncs-output-type>`, this method\nis called on the input object with the highest array priority, or\nthe output object if one was specified. The ufunc-computed array\nis passed in and whatever is returned is passed to the user.\nSubclasses inherit a default implementation of this method, which\ntransforms the array into a new instance of the object's class.\nSubclasses may opt to use this method to transform the output array\ninto an instance of the subclass and update metadata before\nreturning the array to the user.\n\n.. note:: For ufuncs, it is hoped to eventually deprecate this method in\n          favour of :func:`__array_ufunc__`.",
            "name": "py:method",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "class.__array_priority__",
            "content": "The value of this attribute is used to determine what type of\nobject to return in situations where there is more than one\npossibility for the Python type of the returned object. Subclasses\ninherit a default value of 0.0 for this attribute.\n\n.. note:: For ufuncs, it is hoped to eventually deprecate this method in\n          favour of :func:`__array_ufunc__`.",
            "name": "py:attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "class.__array__([dtype])",
            "content": "If a class (ndarray subclass or not) having the :func:`__array__`\nmethod is used as the output object of an :ref:`ufunc\n<ufuncs-output-type>`, results will *not* be written to the object\nreturned by :func:`__array__`. This practice will return ``TypeError``.",
            "name": "py:method",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "level": 1,
      "target": "special-attributes-and-methods",
      "title": "Special attributes and methods"
    },
    {
      "children": [
        {
          "data": {
            "argument": "",
            "content": "single: matrix",
            "name": "index",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "It is strongly advised "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": {
                          "value": "not"
                        }
                      },
                      "type": "Emph"
                    },
                    {
                      "data": {
                        "value": " to use the matrix subclass.  As described below, it makes writing functions that deal consistently with matrices and regular arrays very difficult. Currently, they are mainly used for interacting with "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "scipy.sparse"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ". We hope to provide an alternative for this use, however, and eventually remove the "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "matrix"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " subclass."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": [
                    "matrix"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " objects inherit from the ndarray and therefore, they have the same attributes and methods of ndarrays. There are six important differences of matrix objects, however, that may lead to unexpected results when you use matrices but expect them to act like arrays:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "Matrix objects can be created using a string notation to allow    Matlab-style syntax where spaces separate columns and semicolons    (';') separate rows."
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "Matrix objects are always two-dimensional. This has far-reaching    implications, in that m.ravel() is still two-dimensional (with a 1    in the first dimension) and item selection returns two-dimensional    objects so that sequence behavior is fundamentally different than    arrays."
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "Matrix objects over-ride multiplication to be    matrix-multiplication. "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "content": {
                              "value": "Make sure you understand this for\n   functions that you may want to receive matrices. Especially in\n   light of the fact that asanyarray(m) returns a matrix when m is\n   a matrix."
                            }
                          },
                          "type": "Strong"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "Matrix objects over-ride power to be matrix raised to a power. The    same warning about using power inside a function that uses    asanyarray(...) to get an array object holds for this fact."
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "The default __array_priority\\__ of matrix objects is 10.0, and    therefore mixed operations with ndarrays always produce matrices."
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "Matrices have special attributes which make calculations easier.    These are"
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  },
                  {
                    "data": {
                      "value": ".. autosummary:: \n    :toctree:generated/\n    matrix.T\n       matrix.H\n       matrix.I\n       matrix.A"
                    },
                    "type": "BlockVerbatim"
                  }
                ]
              }
            ]
          },
          "type": "EnumeratedList"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "Matrix objects over-ride multiplication, '"
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": {
                          "value": "', and power, '*"
                        }
                      },
                      "type": "Emph"
                    },
                    {
                      "data": {
                        "value": "', to be matrix-multiplication and matrix power, respectively. If your subroutine can accept sub-classes and you do not convert to base- class arrays, then you must use the ufuncs multiply and power to be sure that you are performing the correct operation for all inputs."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ],
            "kind": "warning",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The matrix class is a Python subclass of the ndarray and can be used as a reference for how to construct your own subclass of the ndarray. Matrices can be created from other matrices, strings, and anything else that can be converted to an "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ndarray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " . The name \"mat \"is an alias for \"matrix \"in NumPy."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    matrix\n    asmatrix\n    bmat"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Example 1: Matrix creation from a string"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> a = np.mat('1 2 3; 4 5 3')\n>>> print((a*a.T).I)\n    [[ 0.29239766 -0.13450292]\n     [-0.13450292  0.08187135]]"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Example 2: Matrix creation from nested sequence"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> np.mat([[1,5,10],[1.0,3,4j]])\nmatrix([[  1.+0.j,   5.+0.j,  10.+0.j],\n        [  1.+0.j,   3.+0.j,   0.+4.j]])"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Example 3: Matrix creation from an array"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> np.mat(np.random.rand(3,3)).T\nmatrix([[4.17022005e-01, 3.02332573e-01, 1.86260211e-01],\n        [7.20324493e-01, 1.46755891e-01, 3.45560727e-01],\n        [1.14374817e-04, 9.23385948e-02, 3.96767474e-01]])"
          },
          "type": "BlockVerbatim"
        }
      ],
      "level": 1,
      "target": "matrix-objects",
      "title": "Matrix objects"
    },
    {
      "children": [
        {
          "data": {
            "argument": "",
            "content": "single: memory maps",
            "name": "index",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "numpy",
            "content": "",
            "name": "currentmodule",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Memory-mapped files are useful for reading and/or modifying small segments of a large file with regular layout, without reading the entire file into memory. A simple subclass of the ndarray uses a memory-mapped file for the data buffer of the array. For small files, the over-head of reading the entire file into memory is typically not significant, however for large files using memory mapping can save considerable resources."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Memory-mapped-file arrays have one additional method (besides those they inherit from the ndarray): "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    ".flush() <memmap.flush>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " which must be called manually by the user to ensure that any changes to the array actually get written to disk."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    memmap\n    memmap.flush"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Example:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> a = np.memmap('newfile.dat', dtype=float, mode='w+', shape=1000)\n>>> a[10] = 10.0\n>>> a[30] = 30.0\n>>> del a\n>>> b = np.fromfile('newfile.dat', dtype=float)\n>>> print(b[10], b[30])\n10.0 30.0\n>>> a = np.memmap('newfile.dat', dtype=float)\n>>> print(a[10], a[30])\n10.0 30.0"
          },
          "type": "BlockVerbatim"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Memory-mapped file arrays"
    },
    {
      "children": [
        {
          "data": {
            "argument": ":ref:`routines.array-creation.char`",
            "content": "",
            "name": "seealso",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "",
            "content": "single: character arrays",
            "name": "index",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "The "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": null,
                        "value": "chararray"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": null,
                        "value": "dtype"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": null,
                        "value": "object_"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": ", "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": null,
                        "value": "bytes_"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " or "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": null,
                        "value": "str_"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": ", and use the free functions in the "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": null,
                        "value": "numpy.char"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " module for fast vectorized string operations."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "These are enhanced arrays of either "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "str_"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " type or "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "bytes_"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " type.  These arrays inherit from the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ndarray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", but specially-define the operations "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "+"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "*"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "%"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " on a (broadcasting) element-by-element basis.  These operations are not available on the standard "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ndarray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " of character type. In addition, the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "chararray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " has all of the standard "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "str"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " (and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "bytes"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ") methods, executing them on an element-by-element basis. Perhaps the easiest way to create a chararray is to use "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "self.view(chararray)\n<ndarray.view>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " where "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "self"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " is an ndarray of str or unicode data-type. However, a chararray can also be created using the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "numpy.chararray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " constructor, or via the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "numpy.char.array <core.defchararray.array>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " function:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    chararray\n    core.defchararray.array"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Another difference with the standard ndarray of str data-type is that the chararray inherits the feature introduced by Numarray that white-space at the end of any element in the array will be ignored on item retrieval and comparison operations."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Character arrays (:mod:`numpy.char`)"
    },
    {
      "children": [
        {
          "data": {
            "argument": ":ref:`routines.array-creation.rec`, :ref:`routines.dtype`,",
            "content": ":ref:`arrays.dtypes`.",
            "name": "seealso",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "NumPy provides the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "recarray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " class which allows accessing the fields of a structured array as attributes, and a corresponding scalar data type object "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "record"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "numpy",
            "content": "",
            "name": "currentmodule",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    recarray\n    record"
          },
          "type": "BlockVerbatim"
        }
      ],
      "level": 1,
      "target": "arrays.classes.rec",
      "title": "Record arrays (:mod:`numpy.rec`)"
    },
    {
      "children": [
        {
          "data": {
            "argument": ":ref:`maskedarray`",
            "content": "",
            "name": "seealso",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Masked arrays (:mod:`numpy.ma`)"
    },
    {
      "children": [
        {
          "data": {
            "argument": "numpy",
            "content": "",
            "name": "currentmodule",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "For backward compatibility and as a standard \"container \"class, the UserArray from Numeric has been brought over to NumPy and named "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "numpy.lib.user_array.container"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " The container class is a Python class whose self.array attribute is an ndarray. Multiple inheritance is probably easier with numpy.lib.user_array.container than with the ndarray itself and so it is included by default. It is not documented here beyond mentioning its existence because you are encouraged to use the ndarray class directly if you can."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    numpy.lib.user_array.container"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "argument": "",
            "content": "single: user_array\nsingle: container class",
            "name": "index",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Standard container class"
    },
    {
      "children": [
        {
          "data": {
            "argument": "numpy",
            "content": "",
            "name": "currentmodule",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "",
            "content": "single: array iterator",
            "name": "index",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Iterators are a powerful concept for array processing. Essentially, iterators implement a generalized for-loop. If "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "myiter"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " is an iterator object, then the Python code:      "
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": "for val in myiter:\n    ...\n    some code involving val\n    ..."
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "calls "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "val = next(myiter)"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " repeatedly until "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "StopIteration"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is raised by the iterator. There are several ways to iterate over an array that may be useful: default iteration, flat iteration, and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "N"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": "-dimensional enumeration."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Array Iterators"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The default iterator of an ndarray object is the default Python iterator of a sequence type. Thus, when the array object itself is used as an iterator. The default behavior is equivalent to:      "
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": "for i in range(arr.shape[0]):\n    val = arr[i]"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "This default iterator selects a sub-array of dimension "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "N-1"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": " from the array. This can be a useful construct for defining recursive algorithms. To loop over the entire array requires "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "N"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": " for-loops."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> a = np.arange(24).reshape(3,2,4)+10\n>>> for val in a:\n...     print('item:', val)\nitem: [[10 11 12 13]\n [14 15 16 17]]\nitem: [[18 19 20 21]\n [22 23 24 25]]\nitem: [[26 27 28 29]\n [30 31 32 33]]"
          },
          "type": "BlockVerbatim"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Default iteration"
    },
    {
      "children": [
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    ndarray.flat"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "As mentioned previously, the flat attribute of ndarray objects returns an iterator that will cycle over the entire array in C-style contiguous order."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> for i, val in enumerate(a.flat):\n...     if i%5 == 0: print(i, val)\n0 10\n5 15\n10 20\n15 25\n20 30"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Here, I've used the built-in enumerate iterator to return the iterator index as well as the value."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Flat iteration"
    },
    {
      "children": [
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    ndenumerate"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Sometimes it may be useful to get the N-dimensional index while iterating. The ndenumerate iterator can achieve this."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> for i, val in np.ndenumerate(a):\n...     if sum(i)%5 == 0: print(i, val)\n(0, 0, 0) 10\n(1, 1, 3) 25\n(2, 0, 3) 29\n(2, 1, 2) 32"
          },
          "type": "BlockVerbatim"
        }
      ],
      "level": 2,
      "target": null,
      "title": "N-dimensional enumeration"
    },
    {
      "children": [
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    broadcast"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The general concept of broadcasting is also available from Python using the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "broadcast"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " iterator. This object takes "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "N"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": " objects as inputs and returns an iterator that returns tuples providing each of the input sequence elements in the broadcasted result."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> for val in np.broadcast([[1,0],[2,3]],[0,1]):\n...     print(val)\n(1, 0)\n(0, 1)\n(2, 0)\n(3, 1)"
          },
          "type": "BlockVerbatim"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Iterator for broadcasting"
    }
  ],
  "content": {},
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "see_also": [],
  "signature": {
    "value": null
  }
}