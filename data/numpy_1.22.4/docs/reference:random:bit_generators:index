{
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "data": {
            "argument": "numpy.random",
            "content": "",
            "name": "currentmodule",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "level": 0,
      "target": null,
      "title": null
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The random values produced by "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "~Generator"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " originate in a BitGenerator.  The BitGenerators do not directly provide random numbers and only contains methods used for seeding, getting or setting the state, jumping or advancing the state, and for accessing low-level wrappers for consumption by code that can efficiently access the functions provided, e.g., "
                },
                "type": "Words"
              },
              {
                "data": {
                  "target": "https://numba.pydata.org",
                  "value": "numba"
                },
                "type": "ExternalLink"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": "Bit Generators"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The included BitGenerators are:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "PCG-64 - The default. A fast generator that can be advanced by an arbitrary   amount. See the documentation for "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": [
                              "~.PCG64.advance"
                            ]
                          },
                          "type": "Verbatim"
                        },
                        {
                          "data": {
                            "value": ". PCG-64 has   a period of "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": "2^{128}"
                          },
                          "type": "Math"
                        },
                        {
                          "data": {
                            "value": ". See the "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "domain": null,
                            "role": null,
                            "value": "PCG author's page"
                          },
                          "type": "Directive"
                        },
                        {
                          "data": {
                            "value": " for more details   about this class of PRNG."
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "PCG-64 DXSM - An upgraded version of PCG-64 with better statistical   properties in parallel contexts. See "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": [
                              "upgrading-pcg64"
                            ]
                          },
                          "type": "Verbatim"
                        },
                        {
                          "data": {
                            "value": " for more   information on these improvements."
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "MT19937 - The standard Python BitGenerator. Adds a "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "domain": null,
                            "role": null,
                            "value": "MT19937.jumped"
                          },
                          "type": "Directive"
                        },
                        {
                          "data": {
                            "value": "   function that returns a new generator with state as-if "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": "2^{128}"
                          },
                          "type": "Math"
                        },
                        {
                          "data": {
                            "value": " draws have   been made."
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "Philox - A counter-based generator capable of being advanced an   arbitrary number of steps or generating independent streams. See the   "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "domain": null,
                            "role": null,
                            "value": "Random123"
                          },
                          "type": "Directive"
                        },
                        {
                          "data": {
                            "value": " page for more details about this class of bit generators."
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "SFC64 - A fast generator based on random invertible mappings. Usually the   fastest generator of the four. See the "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "domain": null,
                            "role": null,
                            "value": "SFC author's page"
                          },
                          "type": "Directive"
                        },
                        {
                          "data": {
                            "value": " for (a little)   more detail."
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              }
            ]
          },
          "type": "BulletList"
        },
        {
          "data": {
            "placeholder": "target",
            "value": ".. _`PCG author's page`: http://www.pcg-random.org/"
          },
          "type": "Unimplemented"
        },
        {
          "data": {
            "placeholder": "target",
            "value": ".. _`Random123`: https://www.deshawresearch.com/resources_random123.html"
          },
          "type": "Unimplemented"
        },
        {
          "data": {
            "placeholder": "target",
            "value": ".. _`SFC author's page`: http://pracrand.sourceforge.net/RNG_engines.txt"
          },
          "type": "Unimplemented"
        },
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    BitGenerator"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "argument": "",
            "content": "MT19937 <mt19937>\nPCG64 <pcg64>\nPCG64DXSM <pcg64dxsm>\nPhilox <philox>\nSFC64 <sfc64>",
            "name": "toctree",
            "options": [
              [
                "maxdepth",
                "1"
              ]
            ]
          },
          "type": "BlockDirective"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Supported BitGenerators"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "A BitGenerator provides a stream of random values. In order to generate reproducible streams, BitGenerators support setting their initial state via a seed. All of the provided BitGenerators will take an arbitrary-sized non-negative integer, or a list of such integers, as a seed. BitGenerators need to take those inputs and process them into a high-quality internal state for the BitGenerator. All of the BitGenerators in numpy delegate that task to "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "SeedSequence"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": ", which uses hashing techniques to ensure that even low-quality seeds generate high-quality initial states."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "python",
            "content": "from numpy.random import PCG64\n\nbg = PCG64(12345678903141592653589793)",
            "name": "code-block",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": ".. end_block"
          },
          "type": "Comment"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "~SeedSequence"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " is designed to be convenient for implementing best practices. We recommend that a stochastic program defaults to using entropy from the OS so that each run is different. The program should print out or log that entropy. In order to reproduce a past value, the program should allow the user to provide that value through some mechanism, a command-line argument is common, so that the user can then re-enter that entropy to reproduce the result. "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "~SeedSequence"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " can take care of everything except for communicating with the user, which is up to you."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "python",
            "content": "from numpy.random import PCG64, SeedSequence\n\n# Get the user's seed somehow, maybe through `argparse`.\n# If the user did not provide a seed, it should return `None`.\nseed = get_user_seed()\nss = SeedSequence(seed)\nprint('seed = {}'.format(ss.entropy))\nbg = PCG64(ss)",
            "name": "code-block",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": ".. end_block"
          },
          "type": "Comment"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "We default to using a 128-bit integer using entropy gathered from the OS. This is a good amount of entropy to initialize all of the generators that we have in numpy. We do not recommend using small seeds below 32 bits for general use. Using just a small set of seeds to instantiate larger state spaces means that there are some initial states that are impossible to reach. This creates some biases if everyone uses such values."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "There will not be anything "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "wrong"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " with the results, per se; even a seed of 0 is perfectly fine thanks to the processing that "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "~SeedSequence"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " does. If you just need "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "some"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " fixed value for unit tests or debugging, feel free to use whatever seed you like. But if you want to make inferences from the results or publish them, drawing from a larger set of seeds is good practice."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "If you need to generate a good seed \"offline\", then "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "SeedSequence().entropy"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " or using "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "secrets.randbits(128)"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " from the standard library are both convenient ways."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "If you need to run several stochastic simulations in parallel, best practice is to construct a random generator instance for each simulation.  To make sure that the random streams have distinct initial states, you can use the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "spawn"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " method of "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "~SeedSequence"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": ". For instance, here we construct a list of 12 instances:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "python",
            "content": "from numpy.random import PCG64, SeedSequence\n\n# High quality initial entropy\nentropy = 0x87351080e25cb0fad77a44a3be03b491\nbase_seq = SeedSequence(entropy)\nchild_seqs = base_seq.spawn(12)    # a list of 12 SeedSequences\ngenerators = [PCG64(seq) for seq in child_seqs]",
            "name": "code-block",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": ".. end_block"
          },
          "type": "Comment"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "An alternative way is to use the fact that a "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "~SeedSequence"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " can be initialized by a tuple of elements. Here we use a base entropy value and an integer "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "worker_id"
                  ]
                },
                "type": "Verbatim"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "python",
            "content": "from numpy.random import PCG64, SeedSequence\n\n# High quality initial entropy\nentropy = 0x87351080e25cb0fad77a44a3be03b491    \nsequences = [SeedSequence((entropy, worker_id)) for worker_id in range(12)]\ngenerators = [PCG64(seq) for seq in sequences]",
            "name": "code-block",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "value": ".. end_block"
          },
          "type": "Comment"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Note that the sequences produced by the latter method will be distinct from those constructed via "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "~SeedSequence.spawn"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    SeedSequence"
          },
          "type": "BlockVerbatim"
        }
      ],
      "level": 0,
      "target": null,
      "title": "Seeding and Entropy"
    }
  ],
  "content": {},
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "see_also": [],
  "signature": {
    "value": null
  }
}