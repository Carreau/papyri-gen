{
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Below are some examples of F2PY usage. This list is not comprehensive, but can be used as a starting point when wrapping your own code."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": "f2py-examples",
      "title": "F2PY examples",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "F2PY walkthrough: a basic extension module",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Consider the following subroutine, contained in a file named "
            },
            {
              "type": "inlineCode",
              "value": "add.f"
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "./code/add.f",
          "children": [],
          "name": "literalinclude",
          "options": {
            "language": "fortran"
          },
          "type": "mystDirective",
          "value": ""
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This routine simply adds the elements in two contiguous arrays and places the result in a third. The memory for all three arrays must be provided by the calling routine. A very basic interface to this routine can be automatically generated by f2py      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": "python -m numpy.f2py -m add add.f"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This command will produce an extension module named "
            },
            {
              "type": "inlineCode",
              "value": "addmodule.c"
            },
            {
              "type": "text",
              "value": " in the current directory. This extension module can now be compiled and used from Python just like any other extension module."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Creating source for a basic extension module",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "note "
                }
              ],
              "type": "admonitionTitle"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "This usage depends heavily on "
                },
                {
                  "type": "inlineCode",
                  "value": "numpy.distutils"
                },
                {
                  "type": "text",
                  "value": ", see "
                },
                {
                  "domain": null,
                  "role": "ref",
                  "type": "Directive",
                  "value": "f2py-bldsys"
                },
                {
                  "type": "text",
                  "value": " for more details."
                }
              ],
              "type": "paragraph"
            }
          ],
          "kind": "note",
          "type": "admonition"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "You can also get f2py to both compile "
            },
            {
              "type": "inlineCode",
              "value": "add.f"
            },
            {
              "type": "text",
              "value": " along with the produced extension module leaving only a shared-library extension file that can be imported from Python      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": "python -m numpy.f2py -c -m add add.f"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This command produces a Python extension module compatible with your platform. This module may then be imported from Python. It will contain a method for each subroutine in "
            },
            {
              "type": "inlineCode",
              "value": "add"
            },
            {
              "type": "text",
              "value": ". The docstring of each method contains information about how the module method may be called:"
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "python",
          "children": [],
          "name": "code-block",
          "options": {},
          "type": "mystDirective",
          "value": ">>> import add\n>>> print(add.zadd.__doc__)\nzadd(a,b,c,n)\n\nWrapper for ``zadd``.\n\nParameters\n----------\na : input rank-1 array('D') with bounds (*)\nb : input rank-1 array('D') with bounds (*)\nc : input rank-1 array('D') with bounds (*)\nn : input int"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Creating a compiled extension module",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The default interface is a very literal translation of the Fortran code into Python. The Fortran array arguments are converted to NumPy arrays and the integer argument should be mapped to a "
            },
            {
              "type": "inlineCode",
              "value": "C"
            },
            {
              "type": "text",
              "value": " integer. The interface will attempt to convert all arguments to their required types (and shapes) and issue an error if unsuccessful. However, because "
            },
            {
              "type": "inlineCode",
              "value": "f2py"
            },
            {
              "type": "text",
              "value": " knows nothing about the semantics of the arguments (such that "
            },
            {
              "type": "inlineCode",
              "value": "C"
            },
            {
              "type": "text",
              "value": " is an output and "
            },
            {
              "type": "inlineCode",
              "value": "n"
            },
            {
              "type": "text",
              "value": " should really match the array sizes), it is possible to abuse this function in ways that can cause Python to crash. For example:"
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "python",
          "children": [],
          "name": "code-block",
          "options": {},
          "type": "mystDirective",
          "value": ">>> add.zadd([1, 2, 3], [1, 2], [3, 4], 1000)"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "will cause a program crash on most systems. Under the hood, the lists are being converted to arrays but then the underlying "
            },
            {
              "type": "inlineCode",
              "value": "add"
            },
            {
              "type": "text",
              "value": " function is told to cycle way beyond the borders of the allocated memory."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In order to improve the interface, "
            },
            {
              "type": "inlineCode",
              "value": "f2py"
            },
            {
              "type": "text",
              "value": " supports directives. This is accomplished by constructing a signature file. It is usually best to start from the interfaces that "
            },
            {
              "type": "inlineCode",
              "value": "f2py"
            },
            {
              "type": "text",
              "value": " produces in that file, which correspond to the default behavior. To get "
            },
            {
              "type": "inlineCode",
              "value": "f2py"
            },
            {
              "type": "text",
              "value": " to generate the interface file use the "
            },
            {
              "type": "inlineCode",
              "value": "-h"
            },
            {
              "type": "text",
              "value": " option      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": "python -m numpy.f2py -h add.pyf -m add add.f"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This command creates the "
            },
            {
              "type": "inlineCode",
              "value": "add.pyf"
            },
            {
              "type": "text",
              "value": " file in the current directory. The section of this file corresponding to "
            },
            {
              "type": "inlineCode",
              "value": "zadd"
            },
            {
              "type": "text",
              "value": " is:"
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "./code/add.pyf",
          "children": [],
          "name": "literalinclude",
          "options": {
            "language": "fortran"
          },
          "type": "mystDirective",
          "value": ""
        },
        {
          "children": [
            {
              "type": "text",
              "value": "By placing intent directives and checking code, the interface can be cleaned up quite a bit so the Python module method is both easier to use and more robust to malformed inputs."
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "./code/add-edited.pyf",
          "children": [],
          "name": "literalinclude",
          "options": {
            "language": "fortran"
          },
          "type": "mystDirective",
          "value": ""
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The intent directive, intent(out) is used to tell f2py that "
            },
            {
              "type": "inlineCode",
              "value": "c"
            },
            {
              "type": "text",
              "value": " is an output variable and should be created by the interface before being passed to the underlying code. The intent(hide) directive tells f2py to not allow the user to specify the variable, "
            },
            {
              "type": "inlineCode",
              "value": "n"
            },
            {
              "type": "text",
              "value": ", but instead to get it from the size of "
            },
            {
              "type": "inlineCode",
              "value": "a"
            },
            {
              "type": "text",
              "value": ". The depend( "
            },
            {
              "type": "inlineCode",
              "value": "a"
            },
            {
              "type": "text",
              "value": " ) directive is necessary to tell f2py that the value of n depends on the input a (so that it won't try to create the variable n until the variable a is created)."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "After modifying "
            },
            {
              "type": "inlineCode",
              "value": "add.pyf"
            },
            {
              "type": "text",
              "value": ", the new Python module file can be generated by compiling both "
            },
            {
              "type": "inlineCode",
              "value": "add.f"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "add.pyf"
            },
            {
              "type": "text",
              "value": "      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": "python -m numpy.f2py -c add.pyf add.f"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The new interface's docstring is:"
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "python",
          "children": [],
          "name": "code-block",
          "options": {},
          "type": "mystDirective",
          "value": ">>> import add\n>>> print(add.zadd.__doc__)\nc = zadd(a,b)\n\nWrapper for ``zadd``.\n\nParameters\n----------\na : input rank-1 array('D') with bounds (n)\nb : input rank-1 array('D') with bounds (n)\n\nReturns\n-------\nc : rank-1 array('D') with bounds (n)"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Now, the function can be called in a much more robust way:"
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "",
          "children": [],
          "name": "code-block",
          "options": {},
          "type": "mystDirective",
          "value": ">>> add.zadd([1, 2, 3], [4, 5, 6])\narray([5.+0.j, 7.+0.j, 9.+0.j])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Notice the automatic conversion to the correct format that occurred."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Improving the basic interface",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The robust interface of the previous section can also be generated automatically by placing the variable directives as special comments in the original Fortran code."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "note "
                }
              ],
              "type": "admonitionTitle"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "For projects where the Fortran code is being actively developed, this may be preferred."
                }
              ],
              "type": "paragraph"
            }
          ],
          "kind": "note",
          "type": "admonition"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Thus, if the source code is modified to contain:"
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "./code/add-improved.f",
          "children": [],
          "name": "literalinclude",
          "options": {
            "language": "fortran"
          },
          "type": "mystDirective",
          "value": ""
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Then, one can compile the extension module using      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": "python -m numpy.f2py -c -m add add.f"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The resulting signature for the function add.zadd is exactly the same one that was created previously. If the original source code had contained "
            },
            {
              "type": "inlineCode",
              "value": "A(N)"
            },
            {
              "type": "text",
              "value": " instead of "
            },
            {
              "type": "inlineCode",
              "value": "A(*)"
            },
            {
              "type": "text",
              "value": " and so forth with "
            },
            {
              "type": "inlineCode",
              "value": "B"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "C"
            },
            {
              "type": "text",
              "value": ", then nearly the same interface can be obtained by placing the "
            },
            {
              "type": "inlineCode",
              "value": "INTENT(OUT) :: C"
            },
            {
              "type": "text",
              "value": " comment line in the source code. The only difference is that "
            },
            {
              "type": "inlineCode",
              "value": "N"
            },
            {
              "type": "text",
              "value": " would be an optional input that would default to the length of "
            },
            {
              "type": "inlineCode",
              "value": "A"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Inserting directives in Fortran source",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "This example shows a function that filters a two-dimensional array of double precision floating-point numbers using a fixed averaging filter. The advantage of using Fortran to index into multi-dimensional arrays should be clear from this example."
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "./code/filter.f",
          "children": [],
          "name": "literalinclude",
          "options": {
            "language": "fortran"
          },
          "type": "mystDirective",
          "value": ""
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This code can be compiled and linked into an extension module named filter using      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": "python -m numpy.f2py -c -m filter filter.f"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This will produce an extension module in the current directory with a method named "
            },
            {
              "type": "inlineCode",
              "value": "dfilter2d"
            },
            {
              "type": "text",
              "value": " that returns a filtered version of the input."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "A filtering example",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Consider the following code, saved in the file "
            },
            {
              "type": "inlineCode",
              "value": "myroutine.f90"
            },
            {
              "type": "text",
              "value": ":"
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "./code/myroutine.f90",
          "children": [],
          "name": "literalinclude",
          "options": {
            "language": "fortran"
          },
          "type": "mystDirective",
          "value": ""
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Wrapping this with "
            },
            {
              "type": "inlineCode",
              "value": "python -m numpy.f2py -c myroutine.f90 -m myroutine"
            },
            {
              "type": "text",
              "value": ", we can do the following in Python   "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": " >>> import numpy as np\n\t>>> import myroutine\n\t>>> x = myroutine.s(2, 3, np.array([5, 6, 7]))\n\t>>> x\n\tarray([[5., 0., 0.],\n           [0., 0., 0.]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Now, instead of generating the extension module directly, we will create a signature file for this subroutine first. This is a common pattern for multi-step extension module generation. In this case, after running"
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "python",
          "children": [],
          "name": "code-block",
          "options": {},
          "type": "mystDirective",
          "value": "python -m numpy.f2py myroutine.f90 -h myroutine.pyf"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "the following signature file is generated:"
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "./code/myroutine.pyf",
          "children": [],
          "name": "literalinclude",
          "options": {
            "language": "fortran"
          },
          "type": "mystDirective",
          "value": ""
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Now, if we run "
            },
            {
              "type": "inlineCode",
              "value": "python -m numpy.f2py -c myroutine.pyf myroutine.f90"
            },
            {
              "type": "text",
              "value": " we see an error; note that the signature file included a "
            },
            {
              "type": "inlineCode",
              "value": "depend(m,n)"
            },
            {
              "type": "text",
              "value": " statement for "
            },
            {
              "type": "inlineCode",
              "value": "x"
            },
            {
              "type": "text",
              "value": " which is not necessary. Indeed, editing the file above to read"
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "./code/myroutine-edited.pyf",
          "children": [],
          "name": "literalinclude",
          "options": {
            "language": "fortran"
          },
          "type": "mystDirective",
          "value": ""
        },
        {
          "children": [
            {
              "type": "text",
              "value": "and running "
            },
            {
              "type": "inlineCode",
              "value": "f2py -c myroutine.pyf myroutine.f90"
            },
            {
              "type": "text",
              "value": " yields correct results."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "``depends`` keyword example",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "Wrapping C codes using f2py"
                        }
                      ],
                      "title": "",
                      "type": "link",
                      "url": "https://scipy.github.io/old-wiki/pages/Cookbook/f2py_and_NumPy.html"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "F2py section on the SciPy Cookbook"
                        }
                      ],
                      "title": "",
                      "type": "link",
                      "url": "https://scipy-cookbook.readthedocs.io/items/F2Py.html"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "F2py example: Interactive System for Ice sheet Simulation"
                        }
                      ],
                      "title": "",
                      "type": "link",
                      "url": "http://websrv.cs.umt.edu/isis/index.php/F2py_example"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "\"Interfacing With Other Languages\" section on the SciPy Cookbook."
                        }
                      ],
                      "title": "",
                      "type": "link",
                      "url": "https://scipy-cookbook.readthedocs.io/items/idx_interfacing_with_other_languages.html"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Read more",
      "type": "Section"
    }
  ],
  "content": {},
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null,
    "type": "Section"
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "see_also": [],
  "signature": {
    "type": "Signature",
    "value": null
  },
  "type": "DocBlob"
}