{
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "args": "Mark Wiebe",
          "children": [],
          "name": "sectionauthor",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "args": "",
          "children": [],
          "name": "index",
          "options": {},
          "type": "mystDirective",
          "value": "pair: iterator; C-API\npair: C-API; iterator"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "versionadded 1.6"
                }
              ],
              "type": "admonitionTitle"
            }
          ],
          "kind": "note",
          "type": "admonition"
        }
      ],
      "level": 0,
      "target": null,
      "title": "Array Iterator API",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The array iterator encapsulates many of the key features in ufuncs, allowing user code to support features like output parameters, preservation of memory layouts, and buffering of data with the wrong alignment or type, without requiring difficult coding."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This page documents the API for the iterator. The iterator is named "
            },
            {
              "type": "inlineCode",
              "value": "NpyIter"
            },
            {
              "type": "text",
              "value": " and functions are named "
            },
            {
              "type": "inlineCode",
              "value": "NpyIter_*"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "There is an "
            },
            {
              "type": "inlineCode",
              "value": "introductory guide to array iteration <arrays.nditer>"
            },
            {
              "type": "text",
              "value": " which may be of interest for those using this C API. In many instances, testing out ideas by creating the iterator in Python is a good idea before writing the C iteration code."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Array Iterator",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The best way to become familiar with the iterator is to look at its usage within the NumPy codebase itself. For example, here is a slightly tweaked version of the code for "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_CountNonzero"
            },
            {
              "type": "text",
              "value": ", which counts the number of non-zero elements in an array."
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "c",
          "children": [],
          "name": "code-block",
          "options": {},
          "type": "mystDirective",
          "value": "npy_intp PyArray_CountNonzero(PyArrayObject* self)\n{\n    /* Nonzero boolean function */\n    PyArray_NonzeroFunc* nonzero = PyArray_DESCR(self)->f->nonzero;\n\n    NpyIter* iter;\n    NpyIter_IterNextFunc *iternext;\n    char** dataptr;\n    npy_intp nonzero_count;\n    npy_intp* strideptr,* innersizeptr;\n\n    /* Handle zero-sized arrays specially */\n    if (PyArray_SIZE(self) == 0) {\n        return 0;\n    }\n\n    /*\n     * Create and use an iterator to count the nonzeros.\n     *   flag NPY_ITER_READONLY\n     *     - The array is never written to.\n     *   flag NPY_ITER_EXTERNAL_LOOP\n     *     - Inner loop is done outside the iterator for efficiency.\n     *   flag NPY_ITER_NPY_ITER_REFS_OK\n     *     - Reference types are acceptable.\n     *   order NPY_KEEPORDER\n     *     - Visit elements in memory order, regardless of strides.\n     *       This is good for performance when the specific order\n     *       elements are visited is unimportant.\n     *   casting NPY_NO_CASTING\n     *     - No casting is required for this operation.\n     */\n    iter = NpyIter_New(self, NPY_ITER_READONLY|\n                             NPY_ITER_EXTERNAL_LOOP|\n                             NPY_ITER_REFS_OK,\n                        NPY_KEEPORDER, NPY_NO_CASTING,\n                        NULL);\n    if (iter == NULL) {\n        return -1;\n    }\n\n    /*\n     * The iternext function gets stored in a local variable\n     * so it can be called repeatedly in an efficient manner.\n     */\n    iternext = NpyIter_GetIterNext(iter, NULL);\n    if (iternext == NULL) {\n        NpyIter_Deallocate(iter);\n        return -1;\n    }\n    /* The location of the data pointer which the iterator may update */\n    dataptr = NpyIter_GetDataPtrArray(iter);\n    /* The location of the stride which the iterator may update */\n    strideptr = NpyIter_GetInnerStrideArray(iter);\n    /* The location of the inner loop size which the iterator may update */\n    innersizeptr = NpyIter_GetInnerLoopSizePtr(iter);\n\n    nonzero_count = 0;\n    do {\n        /* Get the inner loop data/stride/count values */\n        char* data = *dataptr;\n        npy_intp stride = *strideptr;\n        npy_intp count = *innersizeptr;\n\n        /* This is a typical inner loop for NPY_ITER_EXTERNAL_LOOP */\n        while (count--) {\n            if (nonzero(data, self)) {\n                ++nonzero_count;\n            }\n            data += stride;\n        }\n\n        /* Increment the iterator to the next inner loop */\n    } while(iternext(iter));\n\n    NpyIter_Deallocate(iter);\n\n    return nonzero_count;\n}"
        }
      ],
      "level": 1,
      "target": "iteration-example",
      "title": "Iteration Example",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Here is a copy function using the iterator.  The "
            },
            {
              "type": "inlineCode",
              "value": "order"
            },
            {
              "type": "text",
              "value": " parameter is used to control the memory layout of the allocated result, typically "
            },
            {
              "type": "inlineCode",
              "value": "NPY_KEEPORDER"
            },
            {
              "type": "text",
              "value": " is desired."
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "c",
          "children": [],
          "name": "code-block",
          "options": {},
          "type": "mystDirective",
          "value": "PyObject *CopyArray(PyObject *arr, NPY_ORDER order)\n{\n    NpyIter *iter;\n    NpyIter_IterNextFunc *iternext;\n    PyObject *op[2], *ret;\n    npy_uint32 flags;\n    npy_uint32 op_flags[2];\n    npy_intp itemsize, *innersizeptr, innerstride;\n    char **dataptrarray;\n\n    /*\n     * No inner iteration - inner loop is handled by CopyArray code\n     */\n    flags = NPY_ITER_EXTERNAL_LOOP;\n    /*\n     * Tell the constructor to automatically allocate the output.\n     * The data type of the output will match that of the input.\n     */\n    op[0] = arr;\n    op[1] = NULL;\n    op_flags[0] = NPY_ITER_READONLY;\n    op_flags[1] = NPY_ITER_WRITEONLY | NPY_ITER_ALLOCATE;\n\n    /* Construct the iterator */\n    iter = NpyIter_MultiNew(2, op, flags, order, NPY_NO_CASTING,\n                            op_flags, NULL);\n    if (iter == NULL) {\n        return NULL;\n    }\n\n    /*\n     * Make a copy of the iternext function pointer and\n     * a few other variables the inner loop needs.\n     */\n    iternext = NpyIter_GetIterNext(iter, NULL);\n    innerstride = NpyIter_GetInnerStrideArray(iter)[0];\n    itemsize = NpyIter_GetDescrArray(iter)[0]->elsize;\n    /*\n     * The inner loop size and data pointers may change during the\n     * loop, so just cache the addresses.\n     */\n    innersizeptr = NpyIter_GetInnerLoopSizePtr(iter);\n    dataptrarray = NpyIter_GetDataPtrArray(iter);\n\n    /*\n     * Note that because the iterator allocated the output,\n     * it matches the iteration order and is packed tightly,\n     * so we don't need to check it like the input.\n     */\n    if (innerstride == itemsize) {\n        do {\n            memcpy(dataptrarray[1], dataptrarray[0],\n                                    itemsize * (*innersizeptr));\n        } while (iternext(iter));\n    } else {\n        /* For efficiency, should specialize this based on item size... */\n        npy_intp i;\n        do {\n            npy_intp size = *innersizeptr;\n            char *src = dataptrarray[0], *dst = dataptrarray[1];\n            for(i = 0; i < size; i++, src += innerstride, dst += itemsize) {\n                memcpy(dst, src, itemsize);\n            }\n        } while (iternext(iter));\n    }\n\n    /* Get the result from the iterator object array */\n    ret = NpyIter_GetOperandArray(iter)[1];\n    Py_INCREF(ret);\n\n    if (NpyIter_Deallocate(iter) != NPY_SUCCEED) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n\n    return ret;\n}"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Multi-Iteration Example",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "This example shows you how to work with the "
            },
            {
              "type": "inlineCode",
              "value": "NPY_ITER_MULTI_INDEX"
            },
            {
              "type": "text",
              "value": " flag. For simplicity, we assume the argument is a two-dimensional array."
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "c",
          "children": [],
          "name": "code-block",
          "options": {},
          "type": "mystDirective",
          "value": "int PrintMultiIndex(PyArrayObject *arr) {\n    NpyIter *iter;\n    NpyIter_IterNextFunc *iternext;\n    npy_intp multi_index[2];\n\n    iter = NpyIter_New(\n        arr, NPY_ITER_READONLY | NPY_ITER_MULTI_INDEX | NPY_ITER_REFS_OK,\n        NPY_KEEPORDER, NPY_NO_CASTING, NULL);\n    if (iter == NULL) {\n        return -1;\n    }\n    if (NpyIter_GetNDim(iter) != 2) {\n        NpyIter_Deallocate(iter);\n        PyErr_SetString(PyExc_ValueError, \"Array must be 2-D\");\n        return -1;\n    }\n    if (NpyIter_GetIterSize(iter) != 0) {\n        iternext = NpyIter_GetIterNext(iter, NULL);\n        if (iternext == NULL) {\n            NpyIter_Deallocate(iter);\n            return -1;\n        }\n        NpyIter_GetMultiIndexFunc *get_multi_index =\n            NpyIter_GetGetMultiIndex(iter, NULL);\n        if (get_multi_index == NULL) {\n            NpyIter_Deallocate(iter);\n            return -1;\n        }\n\n        do {\n            get_multi_index(iter, multi_index);\n            printf(\"multi_index is [%\" NPY_INTP_FMT \", %\" NPY_INTP_FMT \"]\\n\",\n                   multi_index[0], multi_index[1]);\n        } while (iternext(iter));\n    }\n    if (!NpyIter_Deallocate(iter)) {\n        return -1;\n    }\n    return 0;\n}"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "When called with a 2x3 array, the above example prints:"
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "sh",
          "children": [],
          "name": "code-block",
          "options": {},
          "type": "mystDirective",
          "value": "multi_index is [0, 0]\nmulti_index is [0, 1]\nmulti_index is [0, 2]\nmulti_index is [1, 0]\nmulti_index is [1, 1]\nmulti_index is [1, 2]"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Multi Index Tracking Example",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The iterator layout is an internal detail, and user code only sees an incomplete struct."
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "NpyIter",
          "children": [],
          "name": "c:type",
          "options": {},
          "type": "mystDirective",
          "value": "This is an opaque pointer type for the iterator. Access to its contents\ncan only be done through the iterator API."
        },
        {
          "args": "NpyIter_Type",
          "children": [],
          "name": "c:type",
          "options": {},
          "type": "mystDirective",
          "value": "This is the type which exposes the iterator to Python. Currently, no\nAPI is exposed which provides access to the values of a Python-created\niterator. If an iterator is created in Python, it must be used in Python\nand vice versa. Such an API will likely be created in a future version."
        },
        {
          "args": "NpyIter_IterNextFunc",
          "children": [],
          "name": "c:type",
          "options": {},
          "type": "mystDirective",
          "value": "This is a function pointer for the iteration loop, returned by\n:c:func:`NpyIter_GetIterNext`."
        },
        {
          "args": "NpyIter_GetMultiIndexFunc",
          "children": [],
          "name": "c:type",
          "options": {},
          "type": "mystDirective",
          "value": "This is a function pointer for getting the current iterator multi-index,\nreturned by :c:func:`NpyIter_GetGetMultiIndex`."
        }
      ],
      "level": 1,
      "target": null,
      "title": "Iterator Data Types",
      "type": "Section"
    },
    {
      "children": [
        {
          "args": "NpyIter* NpyIter_New( \\",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "PyArrayObject* op, npy_uint32 flags, NPY_ORDER order, \\\nNPY_CASTING casting, PyArray_Descr* dtype)"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "Creates an iterator for the given numpy array object "
                },
                {
                  "type": "inlineCode",
                  "value": "op"
                },
                {
                  "type": "text",
                  "value": "."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Flags that may be passed in "
                },
                {
                  "type": "inlineCode",
                  "value": "flags"
                },
                {
                  "type": "text",
                  "value": " are any combination     of the global and per-operand flags documented in     "
                },
                {
                  "type": "inlineCode",
                  "value": "NpyIter_MultiNew"
                },
                {
                  "type": "text",
                  "value": ", except for "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_ITER_ALLOCATE"
                },
                {
                  "type": "text",
                  "value": "."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Any of the "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_ORDER"
                },
                {
                  "type": "text",
                  "value": " enum values may be passed to "
                },
                {
                  "type": "inlineCode",
                  "value": "order"
                },
                {
                  "type": "text",
                  "value": ".  For     efficient iteration, "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_KEEPORDER"
                },
                {
                  "type": "text",
                  "value": " is the best option, and     the other orders enforce the particular iteration pattern."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Any of the "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_CASTING"
                },
                {
                  "type": "text",
                  "value": " enum values may be passed to "
                },
                {
                  "type": "inlineCode",
                  "value": "casting"
                },
                {
                  "type": "text",
                  "value": ".     The values include "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_NO_CASTING"
                },
                {
                  "type": "text",
                  "value": ", "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_EQUIV_CASTING"
                },
                {
                  "type": "text",
                  "value": ",     "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_SAFE_CASTING"
                },
                {
                  "type": "text",
                  "value": ", "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_SAME_KIND_CASTING"
                },
                {
                  "type": "text",
                  "value": ", and     "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_UNSAFE_CASTING"
                },
                {
                  "type": "text",
                  "value": ".  To allow the casts to occur, copying or     buffering must also be enabled."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "If "
                },
                {
                  "type": "inlineCode",
                  "value": "dtype"
                },
                {
                  "type": "text",
                  "value": " isn't "
                },
                {
                  "type": "inlineCode",
                  "value": "NULL"
                },
                {
                  "type": "text",
                  "value": ", then it requires that data type.     If copying is allowed, it will make a temporary copy if the data     is castable.  If "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_ITER_UPDATEIFCOPY"
                },
                {
                  "type": "text",
                  "value": " is enabled, it will     also copy the data back with another cast upon iterator destruction."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Returns NULL if there is an error, otherwise returns the allocated     iterator."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "To make an iterator similar to the old iterator, this should work."
                }
              ],
              "type": "paragraph"
            },
            {
              "args": "c",
              "children": [],
              "name": "code-block",
              "options": {},
              "type": "mystDirective",
              "value": "iter = NpyIter_New(op, NPY_ITER_READWRITE,\n                        NPY_CORDER, NPY_NO_CASTING, NULL);"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "If you want to edit an array with aligned "
                },
                {
                  "type": "inlineCode",
                  "value": "double"
                },
                {
                  "type": "text",
                  "value": " code,     but the order doesn't matter, you would use this."
                }
              ],
              "type": "paragraph"
            },
            {
              "args": "c",
              "children": [],
              "name": "code-block",
              "options": {},
              "type": "mystDirective",
              "value": "dtype = PyArray_DescrFromType(NPY_DOUBLE);\n    iter = NpyIter_New(op, NPY_ITER_READWRITE|\n                        NPY_ITER_BUFFERED|\n                        NPY_ITER_NBO|\n                        NPY_ITER_ALIGNED,\n                        NPY_KEEPORDER,\n                        NPY_SAME_KIND_CASTING,\n                        dtype);\n    Py_DECREF(dtype);"
            }
          ],
          "type": "blockquote"
        },
        {
          "args": "NpyIter* NpyIter_MultiNew( \\",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "npy_intp nop, PyArrayObject** op, npy_uint32 flags, NPY_ORDER order, \\\nNPY_CASTING casting, npy_uint32* op_flags, PyArray_Descr** op_dtypes)"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "Creates an iterator for broadcasting the "
                },
                {
                  "type": "inlineCode",
                  "value": "nop"
                },
                {
                  "type": "text",
                  "value": " array objects provided     in "
                },
                {
                  "type": "inlineCode",
                  "value": "op"
                },
                {
                  "type": "text",
                  "value": ", using regular NumPy broadcasting rules."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Any of the "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_ORDER"
                },
                {
                  "type": "text",
                  "value": " enum values may be passed to "
                },
                {
                  "type": "inlineCode",
                  "value": "order"
                },
                {
                  "type": "text",
                  "value": ".  For     efficient iteration, "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_KEEPORDER"
                },
                {
                  "type": "text",
                  "value": " is the best option, and the     other orders enforce the particular iteration pattern.  When using     "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_KEEPORDER"
                },
                {
                  "type": "text",
                  "value": ", if you also want to ensure that the iteration is     not reversed along an axis, you should pass the flag     "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_ITER_DONT_NEGATE_STRIDES"
                },
                {
                  "type": "text",
                  "value": "."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Any of the "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_CASTING"
                },
                {
                  "type": "text",
                  "value": " enum values may be passed to "
                },
                {
                  "type": "inlineCode",
                  "value": "casting"
                },
                {
                  "type": "text",
                  "value": ".     The values include "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_NO_CASTING"
                },
                {
                  "type": "text",
                  "value": ", "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_EQUIV_CASTING"
                },
                {
                  "type": "text",
                  "value": ",     "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_SAFE_CASTING"
                },
                {
                  "type": "text",
                  "value": ", "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_SAME_KIND_CASTING"
                },
                {
                  "type": "text",
                  "value": ", and     "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_UNSAFE_CASTING"
                },
                {
                  "type": "text",
                  "value": ".  To allow the casts to occur, copying or     buffering must also be enabled."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "If "
                },
                {
                  "type": "inlineCode",
                  "value": "op_dtypes"
                },
                {
                  "type": "text",
                  "value": " isn't "
                },
                {
                  "type": "inlineCode",
                  "value": "NULL"
                },
                {
                  "type": "text",
                  "value": ", it specifies a data type or "
                },
                {
                  "type": "inlineCode",
                  "value": "NULL"
                },
                {
                  "type": "text",
                  "value": "     for each "
                },
                {
                  "type": "inlineCode",
                  "value": "op[i]"
                },
                {
                  "type": "text",
                  "value": "."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Returns NULL if there is an error, otherwise returns the allocated     iterator."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Flags that may be passed in "
                },
                {
                  "type": "inlineCode",
                  "value": "flags"
                },
                {
                  "type": "text",
                  "value": ", applying to the whole     iterator, are:"
                }
              ],
              "type": "paragraph"
            }
          ],
          "type": "blockquote"
        },
        {
          "type": "mystComment",
          "value": "..\n    dedent the enumeration of flags to avoid missing references sphinx warnings"
        },
        {
          "args": "NPY_ITER_C_INDEX",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "Causes the iterator to track a raveled flat index matching C\norder. This option cannot be used with :c:data:`NPY_ITER_F_INDEX`."
        },
        {
          "args": "NPY_ITER_F_INDEX",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "Causes the iterator to track a raveled flat index matching Fortran\norder. This option cannot be used with :c:data:`NPY_ITER_C_INDEX`."
        },
        {
          "args": "NPY_ITER_MULTI_INDEX",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "Causes the iterator to track a multi-index.\nThis prevents the iterator from coalescing axes to\nproduce bigger inner loops. If the loop is also not buffered\nand no index is being tracked (`NpyIter_RemoveAxis` can be called),\nthen the iterator size can be ``-1`` to indicate that the iterator\nis too large. This can happen due to complex broadcasting and\nwill result in errors being created when the setting the iterator\nrange, removing the multi index, or getting the next function.\nHowever, it is possible to remove axes again and use the iterator\nnormally if the size is small enough after removal."
        },
        {
          "args": "NPY_ITER_EXTERNAL_LOOP",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "Causes the iterator to skip iteration of the innermost\nloop, requiring the user of the iterator to handle it.\n\nThis flag is incompatible with :c:data:`NPY_ITER_C_INDEX`,\n:c:data:`NPY_ITER_F_INDEX`, and :c:data:`NPY_ITER_MULTI_INDEX`."
        },
        {
          "args": "NPY_ITER_DONT_NEGATE_STRIDES",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "This only affects the iterator when :c:type:`NPY_KEEPORDER` is\nspecified for the order parameter.  By default with\n:c:type:`NPY_KEEPORDER`, the iterator reverses axes which have\nnegative strides, so that memory is traversed in a forward\ndirection.  This disables this step.  Use this flag if you\nwant to use the underlying memory-ordering of the axes,\nbut don't want an axis reversed. This is the behavior of\n``numpy.ravel(a, order='K')``, for instance."
        },
        {
          "args": "NPY_ITER_COMMON_DTYPE",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "Causes the iterator to convert all the operands to a common\ndata type, calculated based on the ufunc type promotion rules.\nCopying or buffering must be enabled.\n\nIf the common data type is known ahead of time, don't use this\nflag.  Instead, set the requested dtype for all the operands."
        },
        {
          "args": "NPY_ITER_REFS_OK",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "Indicates that arrays with reference types (object\narrays or structured arrays containing an object type)\nmay be accepted and used in the iterator.  If this flag\nis enabled, the caller must be sure to check whether\n:c:expr:`NpyIter_IterationNeedsAPI(iter)` is true, in which case\nit may not release the GIL during iteration."
        },
        {
          "args": "NPY_ITER_ZEROSIZE_OK",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "Indicates that arrays with a size of zero should be permitted.\nSince the typical iteration loop does not naturally work with\nzero-sized arrays, you must check that the IterSize is larger\nthan zero before entering the iteration loop.\nCurrently only the operands are checked, not a forced shape."
        },
        {
          "args": "NPY_ITER_REDUCE_OK",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "Permits writeable operands with a dimension with zero\nstride and size greater than one.  Note that such operands\nmust be read/write.\n\nWhen buffering is enabled, this also switches to a special\nbuffering mode which reduces the loop length as necessary to\nnot trample on values being reduced.\n\nNote that if you want to do a reduction on an automatically\nallocated output, you must use :c:func:`NpyIter_GetOperandArray`\nto get its reference, then set every value to the reduction\nunit before doing the iteration loop.  In the case of a\nbuffered reduction, this means you must also specify the\nflag :c:data:`NPY_ITER_DELAY_BUFALLOC`, then reset the iterator\nafter initializing the allocated operand to prepare the\nbuffers."
        },
        {
          "args": "NPY_ITER_RANGED",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "Enables support for iteration of sub-ranges of the full\n``iterindex`` range ``[0, NpyIter_IterSize(iter))``.  Use\nthe function :c:func:`NpyIter_ResetToIterIndexRange` to specify\na range for iteration.\n\nThis flag can only be used with :c:data:`NPY_ITER_EXTERNAL_LOOP`\nwhen :c:data:`NPY_ITER_BUFFERED` is enabled.  This is because\nwithout buffering, the inner loop is always the size of the\ninnermost iteration dimension, and allowing it to get cut up\nwould require special handling, effectively making it more\nlike the buffered version."
        },
        {
          "args": "NPY_ITER_BUFFERED",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "Causes the iterator to store buffering data, and use buffering\nto satisfy data type, alignment, and byte-order requirements.\nTo buffer an operand, do not specify the :c:data:`NPY_ITER_COPY`\nor :c:data:`NPY_ITER_UPDATEIFCOPY` flags, because they will\noverride buffering.  Buffering is especially useful for Python\ncode using the iterator, allowing for larger chunks\nof data at once to amortize the Python interpreter overhead.\n\nIf used with :c:data:`NPY_ITER_EXTERNAL_LOOP`, the inner loop\nfor the caller may get larger chunks than would be possible\nwithout buffering, because of how the strides are laid out.\n\nNote that if an operand is given the flag :c:data:`NPY_ITER_COPY`\nor :c:data:`NPY_ITER_UPDATEIFCOPY`, a copy will be made in preference\nto buffering.  Buffering will still occur when the array was\nbroadcast so elements need to be duplicated to get a constant\nstride.\n\nIn normal buffering, the size of each inner loop is equal\nto the buffer size, or possibly larger if\n:c:data:`NPY_ITER_GROWINNER` is specified.  If\n:c:data:`NPY_ITER_REDUCE_OK` is enabled and a reduction occurs,\nthe inner loops may become smaller depending\non the structure of the reduction."
        },
        {
          "args": "NPY_ITER_GROWINNER",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "When buffering is enabled, this allows the size of the inner\nloop to grow when buffering isn't necessary.  This option\nis best used if you're doing a straight pass through all the\ndata, rather than anything with small cache-friendly arrays\nof temporary values for each inner loop."
        },
        {
          "args": "NPY_ITER_DELAY_BUFALLOC",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "When buffering is enabled, this delays allocation of the\nbuffers until :c:func:`NpyIter_Reset` or another reset function is\ncalled.  This flag exists to avoid wasteful copying of\nbuffer data when making multiple copies of a buffered\niterator for multi-threaded iteration.\n\nAnother use of this flag is for setting up reduction operations.\nAfter the iterator is created, and a reduction output\nis allocated automatically by the iterator (be sure to use\nREADWRITE access), its value may be initialized to the reduction\nunit.  Use :c:func:`NpyIter_GetOperandArray` to get the object.\nThen, call :c:func:`NpyIter_Reset` to allocate and fill the buffers\nwith their initial values."
        },
        {
          "args": "NPY_ITER_COPY_IF_OVERLAP",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "If any write operand has overlap with any read operand, eliminate all\noverlap by making temporary copies (enabling UPDATEIFCOPY for write\noperands, if necessary). A pair of operands has overlap if there is\na memory address that contains data common to both arrays.\n\nBecause exact overlap detection has exponential runtime\nin the number of dimensions, the decision is made based\non heuristics, which has false positives (needless copies in unusual\ncases) but has no false negatives.\n\nIf any read/write overlap exists, this flag ensures the result of the\noperation is the same as if all operands were copied.\nIn cases where copies would need to be made, **the result of the\ncomputation may be undefined without this flag!**\n\nFlags that may be passed in ``op_flags[i]``, where ``0 <= i < nop``:"
        },
        {
          "type": "mystComment",
          "value": "..\n    dedent the enumeration of flags to avoid missing references sphinx warnings"
        },
        {
          "args": "NPY_ITER_READWRITE",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "args": "NPY_ITER_READONLY",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "args": "NPY_ITER_WRITEONLY",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "Indicate how the user of the iterator will read or write\nto ``op[i]``.  Exactly one of these flags must be specified\nper operand. Using ``NPY_ITER_READWRITE`` or ``NPY_ITER_WRITEONLY``\nfor a user-provided operand may trigger `WRITEBACKIFCOPY``\nsemantics. The data will be written back to the original array\nwhen ``NpyIter_Deallocate`` is called."
        },
        {
          "args": "NPY_ITER_COPY",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "Allow a copy of ``op[i]`` to be made if it does not\nmeet the data type or alignment requirements as specified\nby the constructor flags and parameters."
        },
        {
          "args": "NPY_ITER_UPDATEIFCOPY",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "Triggers :c:data:`NPY_ITER_COPY`, and when an array operand\nis flagged for writing and is copied, causes the data\nin a copy to be copied back to ``op[i]`` when\n``NpyIter_Deallocate`` is called.\n\nIf the operand is flagged as write-only and a copy is needed,\nan uninitialized temporary array will be created and then copied\nto back to ``op[i]`` on calling ``NpyIter_Deallocate``, instead of\ndoing the unnecessary copy operation."
        },
        {
          "args": "NPY_ITER_NBO",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "args": "NPY_ITER_ALIGNED",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "args": "NPY_ITER_CONTIG",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "Causes the iterator to provide data for ``op[i]``\nthat is in native byte order, aligned according to\nthe dtype requirements, contiguous, or any combination.\n\nBy default, the iterator produces pointers into the\narrays provided, which may be aligned or unaligned, and\nwith any byte order.  If copying or buffering is not\nenabled and the operand data doesn't satisfy the constraints,\nan error will be raised.\n\nThe contiguous constraint applies only to the inner loop,\nsuccessive inner loops may have arbitrary pointer changes.\n\nIf the requested data type is in non-native byte order,\nthe NBO flag overrides it and the requested data type is\nconverted to be in native byte order."
        },
        {
          "args": "NPY_ITER_ALLOCATE",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "This is for output arrays, and requires that the flag\n:c:data:`NPY_ITER_WRITEONLY` or :c:data:`NPY_ITER_READWRITE`\nbe set.  If ``op[i]`` is NULL, creates a new array with\nthe final broadcast dimensions, and a layout matching\nthe iteration order of the iterator.\n\nWhen ``op[i]`` is NULL, the requested data type\n``op_dtypes[i]`` may be NULL as well, in which case it is\nautomatically generated from the dtypes of the arrays which\nare flagged as readable.  The rules for generating the dtype\nare the same is for UFuncs.  Of special note is handling\nof byte order in the selected dtype.  If there is exactly\none input, the input's dtype is used as is.  Otherwise,\nif more than one input dtypes are combined together, the\noutput will be in native byte order.\n\nAfter being allocated with this flag, the caller may retrieve\nthe new array by calling :c:func:`NpyIter_GetOperandArray` and\ngetting the i-th object in the returned C array.  The caller\nmust call Py_INCREF on it to claim a reference to the array."
        },
        {
          "args": "NPY_ITER_NO_SUBTYPE",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "For use with :c:data:`NPY_ITER_ALLOCATE`, this flag disables\nallocating an array subtype for the output, forcing\nit to be a straight ndarray.\n\nTODO: Maybe it would be better to introduce a function\n``NpyIter_GetWrappedOutput`` and remove this flag?"
        },
        {
          "args": "NPY_ITER_NO_BROADCAST",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "Ensures that the input or output matches the iteration\ndimensions exactly."
        },
        {
          "args": "NPY_ITER_ARRAYMASK",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": ".. versionadded:: 1.7\n\nIndicates that this operand is the mask to use for\nselecting elements when writing to operands which have\nthe :c:data:`NPY_ITER_WRITEMASKED` flag applied to them.\nOnly one operand may have :c:data:`NPY_ITER_ARRAYMASK` flag\napplied to it.\n\nThe data type of an operand with this flag should be either\n:c:data:`NPY_BOOL`, :c:data:`NPY_MASK`, or a struct dtype\nwhose fields are all valid mask dtypes. In the latter case,\nit must match up with a struct operand being WRITEMASKED,\nas it is specifying a mask for each field of that array.\n\nThis flag only affects writing from the buffer back to\nthe array. This means that if the operand is also\n:c:data:`NPY_ITER_READWRITE` or :c:data:`NPY_ITER_WRITEONLY`,\ncode doing iteration can write to this operand to\ncontrol which elements will be untouched and which ones will be\nmodified. This is useful when the mask should be a combination\nof input masks."
        },
        {
          "args": "NPY_ITER_WRITEMASKED",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": ".. versionadded:: 1.7\n\nThis array is the mask for all `writemasked <numpy.nditer>`\noperands. Code uses the ``writemasked`` flag which indicates \nthat only elements where the chosen ARRAYMASK operand is True\nwill be written to. In general, the iterator does not enforce\nthis, it is up to the code doing the iteration to follow that\npromise.\n\nWhen ``writemasked`` flag is used, and this operand is buffered,\nthis changes how data is copied from the buffer into the array.\nA masked copying routine is used, which only copies the\nelements in the buffer for which ``writemasked``\nreturns true from the corresponding element in the ARRAYMASK\noperand."
        },
        {
          "args": "NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE",
          "children": [],
          "name": "c:macro",
          "options": {},
          "type": "mystDirective",
          "value": "In memory overlap checks, assume that operands with\n``NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE`` enabled are accessed only\nin the iterator order.\n\nThis enables the iterator to reason about data dependency,\npossibly avoiding unnecessary copies.\n\nThis flag has effect only if ``NPY_ITER_COPY_IF_OVERLAP`` is enabled\non the iterator."
        },
        {
          "args": "NpyIter* NpyIter_AdvancedNew( \\",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "npy_intp nop, PyArrayObject** op, npy_uint32 flags, NPY_ORDER order, \\\nNPY_CASTING casting, npy_uint32* op_flags, PyArray_Descr** op_dtypes, \\\nint oa_ndim, int** op_axes, npy_intp const* itershape, npy_intp buffersize)"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "Extends "
                },
                {
                  "type": "inlineCode",
                  "value": "NpyIter_MultiNew"
                },
                {
                  "type": "text",
                  "value": " with several advanced options providing     more control over broadcasting and buffering."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "If -1/NULL values are passed to "
                },
                {
                  "type": "inlineCode",
                  "value": "oa_ndim"
                },
                {
                  "type": "text",
                  "value": ", "
                },
                {
                  "type": "inlineCode",
                  "value": "op_axes"
                },
                {
                  "type": "text",
                  "value": ", "
                },
                {
                  "type": "inlineCode",
                  "value": "itershape"
                },
                {
                  "type": "text",
                  "value": ",     and "
                },
                {
                  "type": "inlineCode",
                  "value": "buffersize"
                },
                {
                  "type": "text",
                  "value": ", it is equivalent to "
                },
                {
                  "type": "inlineCode",
                  "value": "NpyIter_MultiNew"
                },
                {
                  "type": "text",
                  "value": "."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "The parameter "
                },
                {
                  "type": "inlineCode",
                  "value": "oa_ndim"
                },
                {
                  "type": "text",
                  "value": ", when not zero or -1, specifies the number of     dimensions that will be iterated with customized broadcasting.     If it is provided, "
                },
                {
                  "type": "inlineCode",
                  "value": "op_axes"
                },
                {
                  "type": "text",
                  "value": " must and "
                },
                {
                  "type": "inlineCode",
                  "value": "itershape"
                },
                {
                  "type": "text",
                  "value": " can also be provided.     The "
                },
                {
                  "type": "inlineCode",
                  "value": "op_axes"
                },
                {
                  "type": "text",
                  "value": " parameter let you control in detail how the     axes of the operand arrays get matched together and iterated.     In "
                },
                {
                  "type": "inlineCode",
                  "value": "op_axes"
                },
                {
                  "type": "text",
                  "value": ", you must provide an array of "
                },
                {
                  "type": "inlineCode",
                  "value": "nop"
                },
                {
                  "type": "text",
                  "value": " pointers     to "
                },
                {
                  "type": "inlineCode",
                  "value": "oa_ndim"
                },
                {
                  "type": "text",
                  "value": "-sized arrays of type "
                },
                {
                  "type": "inlineCode",
                  "value": "npy_intp"
                },
                {
                  "type": "text",
                  "value": ".  If an entry     in "
                },
                {
                  "type": "inlineCode",
                  "value": "op_axes"
                },
                {
                  "type": "text",
                  "value": " is NULL, normal broadcasting rules will apply.     In "
                },
                {
                  "type": "inlineCode",
                  "value": "op_axes[j][i]"
                },
                {
                  "type": "text",
                  "value": " is stored either a valid axis of "
                },
                {
                  "type": "inlineCode",
                  "value": "op[j]"
                },
                {
                  "type": "text",
                  "value": ", or     -1 which means "
                },
                {
                  "type": "inlineCode",
                  "value": "newaxis"
                },
                {
                  "type": "text",
                  "value": ".  Within each "
                },
                {
                  "type": "inlineCode",
                  "value": "op_axes[j]"
                },
                {
                  "type": "text",
                  "value": " array, axes     may not be repeated.  The following example is how normal broadcasting     applies to a 3-D array, a 2-D array, a 1-D array and a scalar."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Note"
                    }
                  ],
                  "type": "strong"
                },
                {
                  "type": "text",
                  "value": ": Before NumPy 1.8 "
                },
                {
                  "type": "inlineCode",
                  "value": "oa_ndim == 0` was used for signalling\n    that ``op_axes"
                },
                {
                  "type": "text",
                  "value": " and "
                },
                {
                  "type": "inlineCode",
                  "value": "itershape"
                },
                {
                  "type": "text",
                  "value": " are unused. This is deprecated and     should be replaced with -1. Better backward compatibility may be     achieved by using "
                },
                {
                  "type": "inlineCode",
                  "value": "NpyIter_MultiNew"
                },
                {
                  "type": "text",
                  "value": " for this case."
                }
              ],
              "type": "paragraph"
            },
            {
              "args": "c",
              "children": [],
              "name": "code-block",
              "options": {},
              "type": "mystDirective",
              "value": "int oa_ndim = 3;               /* # iteration axes */\n    int op0_axes[] = {0, 1, 2};    /* 3-D operand */\n    int op1_axes[] = {-1, 0, 1};   /* 2-D operand */\n    int op2_axes[] = {-1, -1, 0};  /* 1-D operand */\n    int op3_axes[] = {-1, -1, -1}  /* 0-D (scalar) operand */\n    int* op_axes[] = {op0_axes, op1_axes, op2_axes, op3_axes};"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "The "
                },
                {
                  "type": "inlineCode",
                  "value": "itershape"
                },
                {
                  "type": "text",
                  "value": " parameter allows you to force the iterator     to have a specific iteration shape. It is an array of length     "
                },
                {
                  "type": "inlineCode",
                  "value": "oa_ndim"
                },
                {
                  "type": "text",
                  "value": ". When an entry is negative, its value is determined     from the operands. This parameter allows automatically allocated     outputs to get additional dimensions which don't match up with     any dimension of an input."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "If "
                },
                {
                  "type": "inlineCode",
                  "value": "buffersize"
                },
                {
                  "type": "text",
                  "value": " is zero, a default buffer size is used,     otherwise it specifies how big of a buffer to use.  Buffers     which are powers of 2 such as 4096 or 8192 are recommended."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Returns NULL if there is an error, otherwise returns the allocated     iterator."
                }
              ],
              "type": "paragraph"
            }
          ],
          "type": "blockquote"
        },
        {
          "args": "NpyIter* NpyIter_Copy(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Makes a copy of the given iterator.  This function is provided\nprimarily to enable multi-threaded iteration of the data.\n\n*TODO*: Move this to a section about multithreaded iteration.\n\nThe recommended approach to multithreaded iteration is to\nfirst create an iterator with the flags\n:c:data:`NPY_ITER_EXTERNAL_LOOP`, :c:data:`NPY_ITER_RANGED`,\n:c:data:`NPY_ITER_BUFFERED`, :c:data:`NPY_ITER_DELAY_BUFALLOC`, and\npossibly :c:data:`NPY_ITER_GROWINNER`.  Create a copy of this iterator\nfor each thread (minus one for the first iterator).  Then, take\nthe iteration index range ``[0, NpyIter_GetIterSize(iter))`` and\nsplit it up into tasks, for example using a TBB parallel_for loop.\nWhen a thread gets a task to execute, it then uses its copy of\nthe iterator by calling :c:func:`NpyIter_ResetToIterIndexRange` and\niterating over the full range.\n\nWhen using the iterator in multi-threaded code or in code not\nholding the Python GIL, care must be taken to only call functions\nwhich are safe in that context.  :c:func:`NpyIter_Copy` cannot be safely\ncalled without the Python GIL, because it increments Python\nreferences.  The ``Reset*`` and some other functions may be safely\ncalled by passing in the ``errmsg`` parameter as non-NULL, so that\nthe functions will pass back errors through it instead of setting\na Python exception.\n\n:c:func:`NpyIter_Deallocate` must be called for each copy."
        },
        {
          "args": "int NpyIter_RemoveAxis(NpyIter* iter, int axis)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Removes an axis from iteration.  This requires that\n:c:data:`NPY_ITER_MULTI_INDEX` was set for iterator creation, and does\nnot work if buffering is enabled or an index is being tracked. This\nfunction also resets the iterator to its initial state.\n\nThis is useful for setting up an accumulation loop, for example.\nThe iterator can first be created with all the dimensions, including\nthe accumulation axis, so that the output gets created correctly.\nThen, the accumulation axis can be removed, and the calculation\ndone in a nested fashion.\n\n**WARNING**: This function may change the internal memory layout of\nthe iterator.  Any cached functions or pointers from the iterator\nmust be retrieved again! The iterator range will be reset as well.\n\nReturns ``NPY_SUCCEED`` or ``NPY_FAIL``."
        },
        {
          "args": "int NpyIter_RemoveMultiIndex(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "If the iterator is tracking a multi-index, this strips support for them,\nand does further iterator optimizations that are possible if multi-indices\nare not needed.  This function also resets the iterator to its initial\nstate.\n\n**WARNING**: This function may change the internal memory layout of\nthe iterator.  Any cached functions or pointers from the iterator\nmust be retrieved again!\n\nAfter calling this function, :c:expr:`NpyIter_HasMultiIndex(iter)` will\nreturn false.\n\nReturns ``NPY_SUCCEED`` or ``NPY_FAIL``."
        },
        {
          "args": "int NpyIter_EnableExternalLoop(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "If :c:func:`NpyIter_RemoveMultiIndex` was called, you may want to enable the\nflag :c:data:`NPY_ITER_EXTERNAL_LOOP`.  This flag is not permitted\ntogether with :c:data:`NPY_ITER_MULTI_INDEX`, so this function is provided\nto enable the feature after :c:func:`NpyIter_RemoveMultiIndex` is called.\nThis function also resets the iterator to its initial state.\n\n**WARNING**: This function changes the internal logic of the iterator.\nAny cached functions or pointers from the iterator must be retrieved\nagain!\n\nReturns ``NPY_SUCCEED`` or ``NPY_FAIL``."
        },
        {
          "args": "int NpyIter_Deallocate(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Deallocates the iterator object and resolves any needed writebacks.\n\nReturns ``NPY_SUCCEED`` or ``NPY_FAIL``."
        },
        {
          "args": "int NpyIter_Reset(NpyIter* iter, char** errmsg)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Resets the iterator back to its initial state, at the beginning\nof the iteration range.\n\nReturns ``NPY_SUCCEED`` or ``NPY_FAIL``.  If errmsg is non-NULL,\nno Python exception is set when ``NPY_FAIL`` is returned.\nInstead, \\*errmsg is set to an error message.  When errmsg is\nnon-NULL, the function may be safely called without holding\nthe Python GIL."
        },
        {
          "args": "int NpyIter_ResetToIterIndexRange( \\",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "NpyIter* iter, npy_intp istart, npy_intp iend, char** errmsg)"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "Resets the iterator and restricts it to the "
                },
                {
                  "type": "inlineCode",
                  "value": "iterindex"
                },
                {
                  "type": "text",
                  "value": " range     "
                },
                {
                  "type": "inlineCode",
                  "value": "[istart, iend)"
                },
                {
                  "type": "text",
                  "value": ".  See "
                },
                {
                  "type": "inlineCode",
                  "value": "NpyIter_Copy"
                },
                {
                  "type": "text",
                  "value": " for an explanation of     how to use this for multi-threaded iteration.  This requires that     the flag "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_ITER_RANGED"
                },
                {
                  "type": "text",
                  "value": " was passed to the iterator constructor."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "If you want to reset both the "
                },
                {
                  "type": "inlineCode",
                  "value": "iterindex"
                },
                {
                  "type": "text",
                  "value": " range and the base     pointers at the same time, you can do the following to avoid     extra buffer copying (be sure to add the return code error checks     when you copy this code)."
                }
              ],
              "type": "paragraph"
            },
            {
              "args": "c",
              "children": [],
              "name": "code-block",
              "options": {},
              "type": "mystDirective",
              "value": "/* Set to a trivial empty range */\n    NpyIter_ResetToIterIndexRange(iter, 0, 0);\n    /* Set the base pointers */\n    NpyIter_ResetBasePointers(iter, baseptrs);\n    /* Set to the desired range */\n    NpyIter_ResetToIterIndexRange(iter, istart, iend);"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Returns "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_SUCCEED"
                },
                {
                  "type": "text",
                  "value": " or "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_FAIL"
                },
                {
                  "type": "text",
                  "value": ".  If errmsg is non-NULL,     no Python exception is set when "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_FAIL"
                },
                {
                  "type": "text",
                  "value": " is returned.     Instead, \\*errmsg is set to an error message.  When errmsg is     non-NULL, the function may be safely called without holding     the Python GIL."
                }
              ],
              "type": "paragraph"
            }
          ],
          "type": "blockquote"
        },
        {
          "args": "int NpyIter_ResetBasePointers( \\",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "NpyIter *iter, char** baseptrs, char** errmsg)"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "Resets the iterator back to its initial state, but using the values     in "
                },
                {
                  "type": "inlineCode",
                  "value": "baseptrs"
                },
                {
                  "type": "text",
                  "value": " for the data instead of the pointers from the arrays     being iterated.  This functions is intended to be used, together with     the "
                },
                {
                  "type": "inlineCode",
                  "value": "op_axes"
                },
                {
                  "type": "text",
                  "value": " parameter, by nested iteration code with two or more     iterators."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Returns "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_SUCCEED"
                },
                {
                  "type": "text",
                  "value": " or "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_FAIL"
                },
                {
                  "type": "text",
                  "value": ".  If errmsg is non-NULL,     no Python exception is set when "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_FAIL"
                },
                {
                  "type": "text",
                  "value": " is returned.     Instead, \\*errmsg is set to an error message.  When errmsg is     non-NULL, the function may be safely called without holding     the Python GIL."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "TODO"
                    }
                  ],
                  "type": "emphasis"
                },
                {
                  "type": "text",
                  "value": ": Move the following into a special section on nested iterators."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Creating iterators for nested iteration requires some care.  All     the iterator operands must match exactly, or the calls to     "
                },
                {
                  "type": "inlineCode",
                  "value": "NpyIter_ResetBasePointers"
                },
                {
                  "type": "text",
                  "value": " will be invalid.  This means that     automatic copies and output allocation should not be used haphazardly.     It is possible to still use the automatic data conversion and casting     features of the iterator by creating one of the iterators with     all the conversion parameters enabled, then grabbing the allocated     operands with the "
                },
                {
                  "type": "inlineCode",
                  "value": "NpyIter_GetOperandArray"
                },
                {
                  "type": "text",
                  "value": " function and passing     them into the constructors for the rest of the iterators."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "WARNING"
                    }
                  ],
                  "type": "strong"
                },
                {
                  "type": "text",
                  "value": ": When creating iterators for nested iteration,     the code must not use a dimension more than once in the different     iterators.  If this is done, nested iteration will produce     out-of-bounds pointers during iteration."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "WARNING"
                    }
                  ],
                  "type": "strong"
                },
                {
                  "type": "text",
                  "value": ": When creating iterators for nested iteration, buffering     can only be applied to the innermost iterator.  If a buffered iterator     is used as the source for "
                },
                {
                  "type": "inlineCode",
                  "value": "baseptrs"
                },
                {
                  "type": "text",
                  "value": ", it will point into a small buffer     instead of the array and the inner iteration will be invalid."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "The pattern for using nested iterators is as follows."
                }
              ],
              "type": "paragraph"
            },
            {
              "args": "c",
              "children": [],
              "name": "code-block",
              "options": {},
              "type": "mystDirective",
              "value": "NpyIter *iter1, *iter1;\n    NpyIter_IterNextFunc *iternext1, *iternext2;\n    char **dataptrs1;\n\n    /*\n     * With the exact same operands, no copies allowed, and\n     * no axis in op_axes used both in iter1 and iter2.\n     * Buffering may be enabled for iter2, but not for iter1.\n     */\n    iter1 = ...; iter2 = ...;\n\n    iternext1 = NpyIter_GetIterNext(iter1);\n    iternext2 = NpyIter_GetIterNext(iter2);\n    dataptrs1 = NpyIter_GetDataPtrArray(iter1);\n\n    do {\n        NpyIter_ResetBasePointers(iter2, dataptrs1);\n        do {\n            /* Use the iter2 values */\n        } while (iternext2(iter2));\n    } while (iternext1(iter1));"
            }
          ],
          "type": "blockquote"
        },
        {
          "args": "int NpyIter_GotoMultiIndex(NpyIter* iter, npy_intp const* multi_index)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Adjusts the iterator to point to the ``ndim`` indices\npointed to by ``multi_index``.  Returns an error if a multi-index\nis not being tracked, the indices are out of bounds,\nor inner loop iteration is disabled.\n\nReturns ``NPY_SUCCEED`` or ``NPY_FAIL``."
        },
        {
          "args": "int NpyIter_GotoIndex(NpyIter* iter, npy_intp index)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Adjusts the iterator to point to the ``index`` specified.\nIf the iterator was constructed with the flag\n:c:data:`NPY_ITER_C_INDEX`, ``index`` is the C-order index,\nand if the iterator was constructed with the flag\n:c:data:`NPY_ITER_F_INDEX`, ``index`` is the Fortran-order\nindex.  Returns an error if there is no index being tracked,\nthe index is out of bounds, or inner loop iteration is disabled.\n\nReturns ``NPY_SUCCEED`` or ``NPY_FAIL``."
        },
        {
          "args": "npy_intp NpyIter_GetIterSize(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Returns the number of elements being iterated.  This is the product\nof all the dimensions in the shape.  When a multi index is being tracked\n(and `NpyIter_RemoveAxis` may be called) the size may be ``-1`` to\nindicate an iterator is too large.  Such an iterator is invalid, but\nmay become valid after `NpyIter_RemoveAxis` is called. It is not\nnecessary to check for this case."
        },
        {
          "args": "npy_intp NpyIter_GetIterIndex(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Gets the ``iterindex`` of the iterator, which is an index matching\nthe iteration order of the iterator."
        },
        {
          "args": "void NpyIter_GetIterIndexRange( \\",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "NpyIter* iter, npy_intp* istart, npy_intp* iend)"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "Gets the "
                },
                {
                  "type": "inlineCode",
                  "value": "iterindex"
                },
                {
                  "type": "text",
                  "value": " sub-range that is being iterated.  If     "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_ITER_RANGED"
                },
                {
                  "type": "text",
                  "value": " was not specified, this always returns the     range "
                },
                {
                  "type": "inlineCode",
                  "value": "[0, NpyIter_IterSize(iter))"
                },
                {
                  "type": "text",
                  "value": "."
                }
              ],
              "type": "paragraph"
            }
          ],
          "type": "blockquote"
        },
        {
          "args": "int NpyIter_GotoIterIndex(NpyIter* iter, npy_intp iterindex)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Adjusts the iterator to point to the ``iterindex`` specified.\nThe IterIndex is an index matching the iteration order of the iterator.\nReturns an error if the ``iterindex`` is out of bounds,\nbuffering is enabled, or inner loop iteration is disabled.\n\nReturns ``NPY_SUCCEED`` or ``NPY_FAIL``."
        },
        {
          "args": "npy_bool NpyIter_HasDelayedBufAlloc(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Returns 1 if the flag :c:data:`NPY_ITER_DELAY_BUFALLOC` was passed\nto the iterator constructor, and no call to one of the Reset\nfunctions has been done yet, 0 otherwise."
        },
        {
          "args": "npy_bool NpyIter_HasExternalLoop(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Returns 1 if the caller needs to handle the inner-most 1-dimensional\nloop, or 0 if the iterator handles all looping. This is controlled\nby the constructor flag :c:data:`NPY_ITER_EXTERNAL_LOOP` or\n:c:func:`NpyIter_EnableExternalLoop`."
        },
        {
          "args": "npy_bool NpyIter_HasMultiIndex(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Returns 1 if the iterator was created with the\n:c:data:`NPY_ITER_MULTI_INDEX` flag, 0 otherwise."
        },
        {
          "args": "npy_bool NpyIter_HasIndex(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Returns 1 if the iterator was created with the\n:c:data:`NPY_ITER_C_INDEX` or :c:data:`NPY_ITER_F_INDEX`\nflag, 0 otherwise."
        },
        {
          "args": "npy_bool NpyIter_RequiresBuffering(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Returns 1 if the iterator requires buffering, which occurs\nwhen an operand needs conversion or alignment and so cannot\nbe used directly."
        },
        {
          "args": "npy_bool NpyIter_IsBuffered(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Returns 1 if the iterator was created with the\n:c:data:`NPY_ITER_BUFFERED` flag, 0 otherwise."
        },
        {
          "args": "npy_bool NpyIter_IsGrowInner(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Returns 1 if the iterator was created with the\n:c:data:`NPY_ITER_GROWINNER` flag, 0 otherwise."
        },
        {
          "args": "npy_intp NpyIter_GetBufferSize(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "If the iterator is buffered, returns the size of the buffer\nbeing used, otherwise returns 0."
        },
        {
          "args": "int NpyIter_GetNDim(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Returns the number of dimensions being iterated.  If a multi-index\nwas not requested in the iterator constructor, this value\nmay be smaller than the number of dimensions in the original\nobjects."
        },
        {
          "args": "int NpyIter_GetNOp(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Returns the number of operands in the iterator."
        },
        {
          "args": "npy_intp* NpyIter_GetAxisStrideArray(NpyIter* iter, int axis)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Gets the array of strides for the specified axis. Requires that\nthe iterator be tracking a multi-index, and that buffering not\nbe enabled.\n\nThis may be used when you want to match up operand axes in\nsome fashion, then remove them with :c:func:`NpyIter_RemoveAxis` to\nhandle their processing manually.  By calling this function\nbefore removing the axes, you can get the strides for the\nmanual processing.\n\nReturns ``NULL`` on error."
        },
        {
          "args": "int NpyIter_GetShape(NpyIter* iter, npy_intp* outshape)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Returns the broadcast shape of the iterator in ``outshape``.\nThis can only be called on an iterator which is tracking a multi-index.\n\nReturns ``NPY_SUCCEED`` or ``NPY_FAIL``."
        },
        {
          "args": "PyArray_Descr** NpyIter_GetDescrArray(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "This gives back a pointer to the ``nop`` data type Descrs for\nthe objects being iterated.  The result points into ``iter``,\nso the caller does not gain any references to the Descrs.\n\nThis pointer may be cached before the iteration loop, calling\n``iternext`` will not change it."
        },
        {
          "args": "PyObject** NpyIter_GetOperandArray(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "This gives back a pointer to the ``nop`` operand PyObjects\nthat are being iterated.  The result points into ``iter``,\nso the caller does not gain any references to the PyObjects."
        },
        {
          "args": "PyObject* NpyIter_GetIterView(NpyIter* iter, npy_intp i)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "This gives back a reference to a new ndarray view, which is a view\ninto the i-th object in the array :c:func:`NpyIter_GetOperandArray()`,\nwhose dimensions and strides match the internal optimized\niteration pattern.  A C-order iteration of this view is equivalent\nto the iterator's iteration order.\n\nFor example, if an iterator was created with a single array as its\ninput, and it was possible to rearrange all its axes and then\ncollapse it into a single strided iteration, this would return\na view that is a one-dimensional array."
        },
        {
          "args": "void NpyIter_GetReadFlags(NpyIter* iter, char* outreadflags)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Fills ``nop`` flags. Sets ``outreadflags[i]`` to 1 if\n``op[i]`` can be read from, and to 0 if not."
        },
        {
          "args": "void NpyIter_GetWriteFlags(NpyIter* iter, char* outwriteflags)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Fills ``nop`` flags. Sets ``outwriteflags[i]`` to 1 if\n``op[i]`` can be written to, and to 0 if not."
        },
        {
          "args": "int NpyIter_CreateCompatibleStrides( \\",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "NpyIter* iter, npy_intp itemsize, npy_intp* outstrides)"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "Builds a set of strides which are the same as the strides of an     output array created using the "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_ITER_ALLOCATE"
                },
                {
                  "type": "text",
                  "value": " flag, where NULL     was passed for op_axes.  This is for data packed contiguously,     but not necessarily in C or Fortran order. This should be used     together with "
                },
                {
                  "type": "inlineCode",
                  "value": "NpyIter_GetShape"
                },
                {
                  "type": "text",
                  "value": " and "
                },
                {
                  "type": "inlineCode",
                  "value": "NpyIter_GetNDim"
                },
                {
                  "type": "text",
                  "value": "     with the flag "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_ITER_MULTI_INDEX"
                },
                {
                  "type": "text",
                  "value": " passed into the constructor."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "A use case for this function is to match the shape and layout of     the iterator and tack on one or more dimensions.  For example,     in order to generate a vector per input value for a numerical gradient,     you pass in ndim*itemsize for itemsize, then add another dimension to     the end with size ndim and stride itemsize.  To do the Hessian matrix,     you do the same thing but add two dimensions, or take advantage of     the symmetry and pack it into 1 dimension with a particular encoding."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "This function may only be called if the iterator is tracking a multi-index     and if "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_ITER_DONT_NEGATE_STRIDES"
                },
                {
                  "type": "text",
                  "value": " was used to prevent an axis     from being iterated in reverse order."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "If an array is created with this method, simply adding 'itemsize'     for each iteration will traverse the new array matching the     iterator."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Returns "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_SUCCEED"
                },
                {
                  "type": "text",
                  "value": " or "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_FAIL"
                },
                {
                  "type": "text",
                  "value": "."
                }
              ],
              "type": "paragraph"
            }
          ],
          "type": "blockquote"
        },
        {
          "args": "npy_bool NpyIter_IsFirstVisit(NpyIter* iter, int iop)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": ".. versionadded:: 1.7\n\nChecks to see whether this is the first time the elements of the\nspecified reduction operand which the iterator points at are being\nseen for the first time. The function returns a reasonable answer\nfor reduction operands and when buffering is disabled. The answer\nmay be incorrect for buffered non-reduction operands.\n\nThis function is intended to be used in EXTERNAL_LOOP mode only,\nand will produce some wrong answers when that mode is not enabled.\n\nIf this function returns true, the caller should also check the inner\nloop stride of the operand, because if that stride is 0, then only\nthe first element of the innermost external loop is being visited\nfor the first time.\n\n*WARNING*: For performance reasons, 'iop' is not bounds-checked,\nit is not confirmed that 'iop' is actually a reduction operand,\nand it is not confirmed that EXTERNAL_LOOP mode is enabled. These\nchecks are the responsibility of the caller, and should be done\noutside of any inner loops."
        }
      ],
      "level": 1,
      "target": null,
      "title": "Construction and Destruction",
      "type": "Section"
    },
    {
      "children": [
        {
          "args": "NpyIter_IterNextFunc* NpyIter_GetIterNext( \\",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "NpyIter* iter, char** errmsg)"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "Returns a function pointer for iteration.  A specialized version     of the function pointer may be calculated by this function     instead of being stored in the iterator structure. Thus, to     get good performance, it is required that the function pointer     be saved in a variable rather than retrieved for each loop iteration."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Returns NULL if there is an error.  If errmsg is non-NULL,     no Python exception is set when "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_FAIL"
                },
                {
                  "type": "text",
                  "value": " is returned.     Instead, \\*errmsg is set to an error message.  When errmsg is     non-NULL, the function may be safely called without holding     the Python GIL."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "The typical looping construct is as follows."
                }
              ],
              "type": "paragraph"
            },
            {
              "args": "c",
              "children": [],
              "name": "code-block",
              "options": {},
              "type": "mystDirective",
              "value": "NpyIter_IterNextFunc *iternext = NpyIter_GetIterNext(iter, NULL);\n    char** dataptr = NpyIter_GetDataPtrArray(iter);\n\n    do {\n        /* use the addresses dataptr[0], ... dataptr[nop-1] */\n    } while(iternext(iter));"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "When "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_ITER_EXTERNAL_LOOP"
                },
                {
                  "type": "text",
                  "value": " is specified, the typical     inner loop construct is as follows."
                }
              ],
              "type": "paragraph"
            },
            {
              "args": "c",
              "children": [],
              "name": "code-block",
              "options": {},
              "type": "mystDirective",
              "value": "NpyIter_IterNextFunc *iternext = NpyIter_GetIterNext(iter, NULL);\n    char** dataptr = NpyIter_GetDataPtrArray(iter);\n    npy_intp* stride = NpyIter_GetInnerStrideArray(iter);\n    npy_intp* size_ptr = NpyIter_GetInnerLoopSizePtr(iter), size;\n    npy_intp iop, nop = NpyIter_GetNOp(iter);\n\n    do {\n        size = *size_ptr;\n        while (size--) {\n            /* use the addresses dataptr[0], ... dataptr[nop-1] */\n            for (iop = 0; iop < nop; ++iop) {\n                dataptr[iop] += stride[iop];\n            }\n        }\n    } while (iternext());"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Observe that we are using the dataptr array inside the iterator, not     copying the values to a local temporary.  This is possible because     when "
                },
                {
                  "type": "inlineCode",
                  "value": "iternext()"
                },
                {
                  "type": "text",
                  "value": " is called, these pointers will be overwritten     with fresh values, not incrementally updated."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "If a compile-time fixed buffer is being used (both flags     "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_ITER_BUFFERED"
                },
                {
                  "type": "text",
                  "value": " and "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_ITER_EXTERNAL_LOOP"
                },
                {
                  "type": "text",
                  "value": "), the     inner size may be used as a signal as well.  The size is guaranteed     to become zero when "
                },
                {
                  "type": "inlineCode",
                  "value": "iternext()"
                },
                {
                  "type": "text",
                  "value": " returns false, enabling the     following loop construct.  Note that if you use this construct,     you should not pass "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_ITER_GROWINNER"
                },
                {
                  "type": "text",
                  "value": " as a flag, because it     will cause larger sizes under some circumstances."
                }
              ],
              "type": "paragraph"
            },
            {
              "args": "c",
              "children": [],
              "name": "code-block",
              "options": {},
              "type": "mystDirective",
              "value": "/* The constructor should have buffersize passed as this value */\n    #define FIXED_BUFFER_SIZE 1024\n\n    NpyIter_IterNextFunc *iternext = NpyIter_GetIterNext(iter, NULL);\n    char **dataptr = NpyIter_GetDataPtrArray(iter);\n    npy_intp *stride = NpyIter_GetInnerStrideArray(iter);\n    npy_intp *size_ptr = NpyIter_GetInnerLoopSizePtr(iter), size;\n    npy_intp i, iop, nop = NpyIter_GetNOp(iter);\n\n    /* One loop with a fixed inner size */\n    size = *size_ptr;\n    while (size == FIXED_BUFFER_SIZE) {\n        /*\n         * This loop could be manually unrolled by a factor\n         * which divides into FIXED_BUFFER_SIZE\n         */\n        for (i = 0; i < FIXED_BUFFER_SIZE; ++i) {\n            /* use the addresses dataptr[0], ... dataptr[nop-1] */\n            for (iop = 0; iop < nop; ++iop) {\n                dataptr[iop] += stride[iop];\n            }\n        }\n        iternext();\n        size = *size_ptr;\n    }\n\n    /* Finish-up loop with variable inner size */\n    if (size > 0) do {\n        size = *size_ptr;\n        while (size--) {\n            /* use the addresses dataptr[0], ... dataptr[nop-1] */\n            for (iop = 0; iop < nop; ++iop) {\n                dataptr[iop] += stride[iop];\n            }\n        }\n    } while (iternext());"
            }
          ],
          "type": "blockquote"
        },
        {
          "args": "NpyIter_GetMultiIndexFunc *NpyIter_GetGetMultiIndex( \\",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "NpyIter* iter, char** errmsg)"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "Returns a function pointer for getting the current multi-index     of the iterator.  Returns NULL if the iterator is not tracking     a multi-index.  It is recommended that this function     pointer be cached in a local variable before the iteration     loop."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Returns NULL if there is an error.  If errmsg is non-NULL,     no Python exception is set when "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_FAIL"
                },
                {
                  "type": "text",
                  "value": " is returned.     Instead, \\*errmsg is set to an error message.  When errmsg is     non-NULL, the function may be safely called without holding     the Python GIL."
                }
              ],
              "type": "paragraph"
            }
          ],
          "type": "blockquote"
        },
        {
          "args": "char** NpyIter_GetDataPtrArray(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "This gives back a pointer to the ``nop`` data pointers.  If\n:c:data:`NPY_ITER_EXTERNAL_LOOP` was not specified, each data\npointer points to the current data item of the iterator.  If\nno inner iteration was specified, it points to the first data\nitem of the inner loop.\n\nThis pointer may be cached before the iteration loop, calling\n``iternext`` will not change it.  This function may be safely\ncalled without holding the Python GIL."
        },
        {
          "args": "char** NpyIter_GetInitialDataPtrArray(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Gets the array of data pointers directly into the arrays (never\ninto the buffers), corresponding to iteration index 0.\n\nThese pointers are different from the pointers accepted by\n``NpyIter_ResetBasePointers``, because the direction along\nsome axes may have been reversed.\n\nThis function may be safely called without holding the Python GIL."
        },
        {
          "args": "npy_intp* NpyIter_GetIndexPtr(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "This gives back a pointer to the index being tracked, or NULL\nif no index is being tracked.  It is only usable if one of\nthe flags :c:data:`NPY_ITER_C_INDEX` or :c:data:`NPY_ITER_F_INDEX`\nwere specified during construction."
        },
        {
          "children": [
            {
              "type": "text",
              "value": "When the flag "
            },
            {
              "type": "inlineCode",
              "value": "NPY_ITER_EXTERNAL_LOOP"
            },
            {
              "type": "text",
              "value": " is used, the code needs to know the parameters for doing the inner loop.  These functions provide that information."
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "npy_intp* NpyIter_GetInnerStrideArray(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Returns a pointer to an array of the ``nop`` strides,\none for each iterated object, to be used by the inner loop.\n\nThis pointer may be cached before the iteration loop, calling\n``iternext`` will not change it. This function may be safely\ncalled without holding the Python GIL.\n\n**WARNING**: While the pointer may be cached, its values may\nchange if the iterator is buffered."
        },
        {
          "args": "npy_intp* NpyIter_GetInnerLoopSizePtr(NpyIter* iter)",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "Returns a pointer to the number of iterations the\ninner loop should execute.\n\nThis address may be cached before the iteration loop, calling\n``iternext`` will not change it.  The value itself may change during\niteration, in particular if buffering is enabled.  This function\nmay be safely called without holding the Python GIL."
        },
        {
          "args": "void NpyIter_GetInnerFixedStrideArray( \\",
          "children": [],
          "name": "c:function",
          "options": {},
          "type": "mystDirective",
          "value": "NpyIter* iter, npy_intp* out_strides)"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "Gets an array of strides which are fixed, or will not change during     the entire iteration.  For strides that may change, the value     NPY_MAX_INTP is placed in the stride."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Once the iterator is prepared for iteration (after a reset if     "
                },
                {
                  "type": "inlineCode",
                  "value": "NPY_ITER_DELAY_BUFALLOC"
                },
                {
                  "type": "text",
                  "value": " was used), call this to get the strides     which may be used to select a fast inner loop function.  For example,     if the stride is 0, that means the inner loop can always load its     value into a variable once, then use the variable throughout the loop,     or if the stride equals the itemsize, a contiguous version for that     operand may be used."
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "This function may be safely called without holding the Python GIL."
                }
              ],
              "type": "paragraph"
            }
          ],
          "type": "blockquote"
        },
        {
          "args": "",
          "children": [],
          "name": "index",
          "options": {},
          "type": "mystDirective",
          "value": "pair: iterator; C-API"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Functions For Iteration",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The old iterator API includes functions like PyArrayIter_Check, PyArray_Iter* and PyArray_ITER_*.  The multi-iterator array includes PyArray_MultiIter*, PyArray_Broadcast, and PyArray_RemoveSmallest.  The new iterator design replaces all of this functionality with a single object and associated API.  One goal of the new API is that all uses of the existing iterator should be replaceable with the new iterator without significant effort. In 1.6, the major exception to this is the neighborhood iterator, which does not have corresponding features in this iterator."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Here is a conversion table for which functions to use with the new iterator:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "=====================================  =================================================== "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Iterator Functions"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_IterNew"
            },
            {
              "type": "text",
              "value": "              "
            },
            {
              "type": "inlineCode",
              "value": "NpyIter_New"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_IterAllButAxis"
            },
            {
              "type": "text",
              "value": "       "
            },
            {
              "type": "inlineCode",
              "value": "NpyIter_New"
            },
            {
              "type": "text",
              "value": " + "
            },
            {
              "type": "inlineCode",
              "value": "axes"
            },
            {
              "type": "text",
              "value": " parameter "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "or"
                }
              ],
              "type": "strong"
            },
            {
              "type": "text",
              "value": "                                        Iterator flag "
            },
            {
              "type": "inlineCode",
              "value": "NPY_ITER_EXTERNAL_LOOP"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_BroadcastToShape"
            },
            {
              "type": "text",
              "value": "     "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "NOT SUPPORTED"
                }
              ],
              "type": "strong"
            },
            {
              "type": "text",
              "value": " (Use the support for                                        multiple operands instead.) "
            },
            {
              "type": "inlineCode",
              "value": "PyArrayIter_Check"
            },
            {
              "type": "text",
              "value": "            Will need to add this in Python exposure "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_ITER_RESET"
            },
            {
              "type": "text",
              "value": "           "
            },
            {
              "type": "inlineCode",
              "value": "NpyIter_Reset"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_ITER_NEXT"
            },
            {
              "type": "text",
              "value": "            Function pointer from "
            },
            {
              "type": "inlineCode",
              "value": "NpyIter_GetIterNext"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_ITER_DATA"
            },
            {
              "type": "text",
              "value": "            "
            },
            {
              "type": "inlineCode",
              "value": "NpyIter_GetDataPtrArray"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_ITER_GOTO"
            },
            {
              "type": "text",
              "value": "            "
            },
            {
              "type": "inlineCode",
              "value": "NpyIter_GotoMultiIndex"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_ITER_GOTO1D"
            },
            {
              "type": "text",
              "value": "          "
            },
            {
              "type": "inlineCode",
              "value": "NpyIter_GotoIndex"
            },
            {
              "type": "text",
              "value": " or                                        "
            },
            {
              "type": "inlineCode",
              "value": "NpyIter_GotoIterIndex"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_ITER_NOTDONE"
            },
            {
              "type": "text",
              "value": "         Return value of "
            },
            {
              "type": "inlineCode",
              "value": "iternext"
            },
            {
              "type": "text",
              "value": " function pointer "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Multi-iterator Functions"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_MultiIterNew"
            },
            {
              "type": "text",
              "value": "         "
            },
            {
              "type": "inlineCode",
              "value": "NpyIter_MultiNew"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_MultiIter_RESET"
            },
            {
              "type": "text",
              "value": "      "
            },
            {
              "type": "inlineCode",
              "value": "NpyIter_Reset"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_MultiIter_NEXT"
            },
            {
              "type": "text",
              "value": "       Function pointer from "
            },
            {
              "type": "inlineCode",
              "value": "NpyIter_GetIterNext"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_MultiIter_DATA"
            },
            {
              "type": "text",
              "value": "       "
            },
            {
              "type": "inlineCode",
              "value": "NpyIter_GetDataPtrArray"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_MultiIter_NEXTi"
            },
            {
              "type": "text",
              "value": "      "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "NOT SUPPORTED"
                }
              ],
              "type": "strong"
            },
            {
              "type": "text",
              "value": " (always lock-step iteration) "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_MultiIter_GOTO"
            },
            {
              "type": "text",
              "value": "       "
            },
            {
              "type": "inlineCode",
              "value": "NpyIter_GotoMultiIndex"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_MultiIter_GOTO1D"
            },
            {
              "type": "text",
              "value": "     "
            },
            {
              "type": "inlineCode",
              "value": "NpyIter_GotoIndex"
            },
            {
              "type": "text",
              "value": " or                                        "
            },
            {
              "type": "inlineCode",
              "value": "NpyIter_GotoIterIndex"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_MultiIter_NOTDONE"
            },
            {
              "type": "text",
              "value": "    Return value of "
            },
            {
              "type": "inlineCode",
              "value": "iternext"
            },
            {
              "type": "text",
              "value": " function pointer "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_Broadcast"
            },
            {
              "type": "text",
              "value": "            Handled by "
            },
            {
              "type": "inlineCode",
              "value": "NpyIter_MultiNew"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_RemoveSmallest"
            },
            {
              "type": "text",
              "value": "       Iterator flag "
            },
            {
              "type": "inlineCode",
              "value": "NPY_ITER_EXTERNAL_LOOP"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Other Functions"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_ConvertToCommonType"
            },
            {
              "type": "text",
              "value": "  Iterator flag "
            },
            {
              "type": "inlineCode",
              "value": "NPY_ITER_COMMON_DTYPE"
            },
            {
              "type": "text",
              "value": " =====================================  ==================================================="
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Converting from Previous NumPy Iterators",
      "type": "Section"
    }
  ],
  "content": {},
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null,
    "type": "Section"
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "see_also": [],
  "signature": {
    "type": "Signature",
    "value": null
  },
  "type": "DocBlob"
}