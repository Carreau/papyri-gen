{
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "args": "numpy.distutils",
          "children": [],
          "name": "module",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "warning "
                }
              ],
              "type": "admonitionTitle"
            },
            {
              "children": [
                {
                  "type": "inlineCode",
                  "value": "numpy.distutils"
                },
                {
                  "type": "text",
                  "value": " is deprecated, and will be removed for Python >= 3.12. For more details, see "
                },
                {
                  "domain": null,
                  "role": "ref",
                  "type": "Directive",
                  "value": "distutils-status-migration"
                }
              ],
              "type": "paragraph"
            }
          ],
          "kind": "note",
          "type": "admonition"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "warning "
                }
              ],
              "type": "admonitionTitle"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Note that "
                },
                {
                  "type": "inlineCode",
                  "value": "setuptools"
                },
                {
                  "type": "text",
                  "value": " does major releases often and those may contain changes that break "
                },
                {
                  "type": "inlineCode",
                  "value": "numpy.distutils"
                },
                {
                  "type": "text",
                  "value": ", which will "
                },
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "not"
                    }
                  ],
                  "type": "emphasis"
                },
                {
                  "type": "text",
                  "value": " be updated anymore for new "
                },
                {
                  "type": "inlineCode",
                  "value": "setuptools"
                },
                {
                  "type": "text",
                  "value": " versions. It is therefore recommended to set an upper version bound in your build configuration for the last known version of "
                },
                {
                  "type": "inlineCode",
                  "value": "setuptools"
                },
                {
                  "type": "text",
                  "value": " that works with your build."
                }
              ],
              "type": "paragraph"
            }
          ],
          "kind": "note",
          "type": "admonition"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "NumPy provides enhanced distutils functionality to make it easier to build and install sub-packages, auto-generate code, and extension modules that use Fortran-compiled libraries. To use features of NumPy distutils, use the "
            },
            {
              "type": "inlineCode",
              "value": "setup <core.setup>"
            },
            {
              "type": "text",
              "value": " command from "
            },
            {
              "type": "inlineCode",
              "value": "numpy.distutils.core"
            },
            {
              "type": "text",
              "value": ". A useful "
            },
            {
              "type": "inlineCode",
              "value": "Configuration\n<misc_util.Configuration>"
            },
            {
              "type": "text",
              "value": " class is also provided in "
            },
            {
              "type": "inlineCode",
              "value": "numpy.distutils.misc_util"
            },
            {
              "type": "text",
              "value": " that can make it easier to construct keyword arguments to pass to the setup function (by passing the dictionary obtained from the todict() method of the class). More information is available in the "
            },
            {
              "type": "inlineCode",
              "value": "distutils-user-guide"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The choice and location of linked libraries such as BLAS and LAPACK as well as include paths and other such build options can be specified in a "
            },
            {
              "type": "inlineCode",
              "value": "site.cfg"
            },
            {
              "type": "text",
              "value": " file located in the NumPy root repository or a "
            },
            {
              "type": "inlineCode",
              "value": ".numpy-site.cfg"
            },
            {
              "type": "text",
              "value": " file in your home directory. See the "
            },
            {
              "type": "inlineCode",
              "value": "site.cfg.example"
            },
            {
              "type": "text",
              "value": " example file included in the NumPy repository or sdist for documentation."
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "",
          "children": [],
          "name": "index",
          "options": {},
          "type": "mystDirective",
          "value": "single: distutils"
        }
      ],
      "level": 0,
      "target": null,
      "title": "Packaging (:mod:`numpy.distutils`)",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "exists",
                      "reference": {
                        "kind": "?",
                        "module": "",
                        "path": "distutils/misc_util",
                        "type": "RefInfo",
                        "version": ""
                      },
                      "type": "Link",
                      "value": "distutils/misc_util"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "args": "numpy.distutils",
          "children": [],
          "name": "currentmodule",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "type": "code",
          "value": ".. autosummary:: \n    :toctree:generated/\n    ccompiler\n    ccompiler_opt\n    cpuinfo.cpu\n    core.Extension\n    exec_command\n    log.set_verbosity\n    system_info.get_info\n    system_info.get_standard_file"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Modules in :mod:`numpy.distutils`",
      "type": "Section"
    },
    {
      "children": [
        {
          "args": "numpy.distutils.misc_util",
          "children": [],
          "name": "currentmodule",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "args": "Configuration(package_name=None, parent_name=None, top_path=None, package_path=None, **attrs)",
          "children": [],
          "name": "class",
          "options": {},
          "type": "mystDirective",
          "value": "Construct a configuration instance for the given package name. If\n*parent_name* is not None, then construct the package as a\nsub-package of the *parent_name* package. If *top_path* and\n*package_path* are None then they are assumed equal to\nthe path of the file this instance was created in. The setup.py\nfiles in the numpy distribution are good examples of how to use\nthe :class:`Configuration` instance.\n\n.. automethod:: todict\n\n.. automethod:: get_distribution\n\n.. automethod:: get_subpackage\n\n.. automethod:: add_subpackage\n\n.. automethod:: add_data_files\n\n.. automethod:: add_data_dir\n\n.. automethod:: add_include_dirs\n\n.. automethod:: add_headers\n\n.. automethod:: add_extension\n\n.. automethod:: add_library\n\n.. automethod:: add_scripts\n\n.. automethod:: add_installed_library\n\n.. automethod:: add_npy_pkg_config\n\n.. automethod:: paths\n\n.. automethod:: get_config_cmd\n\n.. automethod:: get_build_temp_dir\n\n.. automethod:: have_f77c\n\n.. automethod:: have_f90c\n\n.. automethod:: get_version\n\n.. automethod:: make_svn_version_py\n\n.. automethod:: make_config_py\n\n.. automethod:: get_info"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Configuration class",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Conventional C libraries (installed through "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "add_library"
            },
            {
              "type": "text",
              "value": ") are not installed, and are just used during the build (they are statically linked).  An installable C library is a pure C library, which does not depend on the python C runtime, and is installed such that it may be used by third-party packages. To build and install the C library, you just use the method "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "add_installed_library"
            },
            {
              "type": "text",
              "value": " instead of "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "add_library"
            },
            {
              "type": "text",
              "value": ", which takes the same arguments except for an additional "
            },
            {
              "type": "inlineCode",
              "value": "install_dir"
            },
            {
              "type": "text",
              "value": " argument    "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ".. hidden in a comment so as to be included in refguide but not rendered documentation\n  >>> import numpy.distutils.misc_util\n  >>> config = np.distutils.misc_util.Configuration(None, '', '.')\n  >>> with open('foo.c', 'w') as f: pass\n\n>>> config.add_installed_library('foo', sources=['foo.c'], install_dir='lib')"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Building Installable C libraries",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "To make the necessary build options available to third parties, you could use the "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "npy-pkg-config"
            },
            {
              "type": "text",
              "value": " mechanism implemented in "
            },
            {
              "anchor": null,
              "exists": true,
              "kind": "module",
              "reference": {
                "kind": "api",
                "module": "numpy",
                "path": "numpy.distutils",
                "type": "RefInfo",
                "version": "*"
              },
              "type": "Link",
              "value": "numpy.distutils"
            },
            {
              "type": "text",
              "value": ". This mechanism is based on a .ini file which contains all the options. A .ini file is very similar to .pc files as used by the pkg-config unix utility    "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": "[meta]\nName: foo\nVersion: 1.0\nDescription: foo library\n\n[variables]\nprefix = /home/user/local\nlibdir = ${prefix}/lib\nincludedir = ${prefix}/include\n\n[default]\ncflags = -I${includedir}\nlibs = -L${libdir} -lfoo"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Generally, the file needs to be generated during the build, since it needs some information known at build time only (e.g. prefix). This is mostly automatic if one uses the "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "Configuration"
            },
            {
              "type": "text",
              "value": " method "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "add_npy_pkg_config"
            },
            {
              "type": "text",
              "value": ". Assuming we have a template file foo.ini.in as follows    "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": "[meta]\nName: foo\nVersion: @version@\nDescription: foo library\n\n[variables]\nprefix = @prefix@\nlibdir = ${prefix}/lib\nincludedir = ${prefix}/include\n\n[default]\ncflags = -I${includedir}\nlibs = -L${libdir} -lfoo"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "and the following code in setup.py    "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> config.add_installed_library('foo', sources=['foo.c'], install_dir='lib')\n>>> subst = {'version': '1.0'}\n>>> config.add_npy_pkg_config('foo.ini.in', 'lib', subst_dict=subst)"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This will install the file foo.ini into the directory package_dir/lib, and the foo.ini file will be generated from foo.ini.in, where each "
            },
            {
              "type": "inlineCode",
              "value": "@version@"
            },
            {
              "type": "text",
              "value": " will be replaced by "
            },
            {
              "type": "inlineCode",
              "value": "subst_dict['version']"
            },
            {
              "type": "text",
              "value": ". The dictionary has an additional prefix substitution rule automatically added, which contains the install prefix (since this is not easy to get from setup.py).  npy-pkg-config files can also be installed at the same location as used for numpy, using the path returned from "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "get_npy_pkg_dir"
            },
            {
              "type": "text",
              "value": " function."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "npy-pkg-config files",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Info are easily retrieved from the "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "get_info"
            },
            {
              "type": "text",
              "value": " function in "
            },
            {
              "anchor": null,
              "exists": true,
              "kind": "module",
              "reference": {
                "kind": "api",
                "module": "numpy",
                "path": "numpy.distutils.misc_util",
                "type": "RefInfo",
                "version": "*"
              },
              "type": "Link",
              "value": "numpy.distutils.misc_util"
            },
            {
              "type": "text",
              "value": ":    "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> info = np.distutils.misc_util.get_info('npymath')\n>>> config.add_extension('foo', sources=['foo.c'], extra_info=info)\n<numpy.distutils.extension.Extension('foo') at 0x...>"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "An additional list of paths to look for .ini files can be given to "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "get_info"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Reusing a C library from another package",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "NumPy distutils supports automatic conversion of source files named <somefile>.src. This facility can be used to maintain very similar code blocks requiring only simple changes between blocks. During the build phase of setup, if a template file named <somefile>.src is encountered, a new file named <somefile> is constructed from the template and placed in the build directory to be used instead. Two forms of template conversion are supported. The first form occurs for files named <file>.ext.src where ext is a recognized Fortran extension (f, f90, f95, f77, for, ftn, pyf). The second form is used for all other cases. See "
            },
            {
              "type": "inlineCode",
              "value": "templating"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Conversion of ``.src`` files",
      "type": "Section"
    }
  ],
  "content": {},
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null,
    "type": "Section"
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "see_also": [],
  "signature": {
    "type": "Signature",
    "value": null
  },
  "type": "DocBlob"
}