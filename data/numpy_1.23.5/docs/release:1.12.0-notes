{
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "This release supports Python 2.7 and 3.4 - 3.6."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": "NumPy 1.12.0 Release Notes",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The NumPy 1.12.0 release contains a large number of fixes and improvements, but few that stand out above all others. That makes picking out the highlights somewhat arbitrary but the following may be of particular interest or indicate areas likely to have future consequences."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Order of operations in "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.einsum"
                    },
                    {
                      "type": "text",
                      "value": " can now be optimized for large speed improvements."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "New "
                    },
                    {
                      "type": "inlineCode",
                      "value": "signature"
                    },
                    {
                      "type": "text",
                      "value": " argument to "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.vectorize"
                    },
                    {
                      "type": "text",
                      "value": " for vectorizing with core dimensions."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The "
                    },
                    {
                      "type": "inlineCode",
                      "value": "keepdims"
                    },
                    {
                      "type": "text",
                      "value": " argument was added to many functions."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "New context manager for testing warnings"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Support for BLIS in numpy.distutils"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Much improved support for PyPy (not yet finished)"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Highlights",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Support for Python 2.6, 3.2, and 3.3 has been dropped."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Dropped Support",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Support for PyPy 2.7 v5.6.0 has been added. While not complete (nditer   "
                    },
                    {
                      "type": "inlineCode",
                      "value": "updateifcopy"
                    },
                    {
                      "type": "text",
                      "value": " is not supported yet), this is a milestone for PyPy's   C-API compatibility layer."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Added Support",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Library order is preserved, instead of being reordered to match that of   the directories."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Build System Changes",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "Deprecations",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Assigning the 'data' attribute is an inherently unsafe operation as pointed out in gh-7083. Such a capability will be removed in the future."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Assignment of ndarray object's ``data`` attribute",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "np.linspace"
            },
            {
              "type": "text",
              "value": " now raises DeprecationWarning when num cannot be safely interpreted as an integer."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Unsafe int casting of the num attribute in ``linspace``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "If a 'width' parameter is passed into "
            },
            {
              "type": "inlineCode",
              "value": "binary_repr"
            },
            {
              "type": "text",
              "value": " that is insufficient to represent the number in base 2 (positive) or 2's complement (negative) form, the function used to silently ignore the parameter and return a representation using the minimal number of bits needed for the form in question. Such behavior is now considered unsafe from a user perspective and will raise an error in the future."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Insufficient bit width parameter to ``binary_repr``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "In 1.13 NAT will always compare False except for "
                    },
                    {
                      "type": "inlineCode",
                      "value": "NAT != NAT"
                    },
                    {
                      "type": "text",
                      "value": ",   which will be True.  In short, NAT will behave like NaN"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "In 1.13 "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.average"
                    },
                    {
                      "type": "text",
                      "value": " will preserve subclasses, to match the behavior of most   other numpy functions such as np.mean. In particular, this means calls which   returned a scalar may return a 0-d subclass object instead."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Future Changes",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "In 1.13 the behavior of structured arrays involving multiple fields will change in two ways:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "First, indexing a structured array with multiple fields (eg, "
            },
            {
              "type": "inlineCode",
              "value": "arr[['f1', 'f3']]"
            },
            {
              "type": "text",
              "value": ") will return a view into the original array in 1.13, instead of a copy. Note the returned view will have extra padding bytes corresponding to intervening fields in the original array, unlike the copy in 1.12, which will affect code such as "
            },
            {
              "type": "inlineCode",
              "value": "arr[['f1', 'f3']].view(newdtype)"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Second, for numpy versions 1.6 to 1.12 assignment between structured arrays occurs \"by field name\": Fields in the destination array are set to the identically-named field in the source array or to 0 if the source does not have a field      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> a = np.array([(1,2),(3,4)], dtype=[('x', 'i4'), ('y', 'i4')])\n>>> b = np.ones(2, dtype=[('z', 'i4'), ('y', 'i4'), ('x', 'i4')])\n>>> b[:] = a\n>>> b\narray([(0, 2, 1), (0, 4, 3)],\n      dtype=[('z', '<i4'), ('y', '<i4'), ('x', '<i4')])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In 1.13 assignment will instead occur \"by position\": The Nth field of the destination will be set to the Nth field of the source regardless of field name. The old behavior can be obtained by using indexing to reorder the fields before assignment, e.g., "
            },
            {
              "type": "inlineCode",
              "value": "b[['x', 'y']] = a[['y', 'x']]"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Multiple-field manipulation of structured arrays",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "Compatibility notes",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Indexing with floats raises "
                    },
                    {
                      "type": "inlineCode",
                      "value": "IndexError"
                    },
                    {
                      "type": "text",
                      "value": ",   e.g., a[0, 0.0]."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Indexing with non-integer array_like raises "
                    },
                    {
                      "type": "inlineCode",
                      "value": "IndexError"
                    },
                    {
                      "type": "text",
                      "value": ",   e.g., "
                    },
                    {
                      "type": "inlineCode",
                      "value": "a['1', '2']"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Indexing with multiple ellipsis raises "
                    },
                    {
                      "type": "inlineCode",
                      "value": "IndexError"
                    },
                    {
                      "type": "text",
                      "value": ",   e.g., "
                    },
                    {
                      "type": "inlineCode",
                      "value": "a[..., ...]"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Non-integers used as index values raise "
                    },
                    {
                      "type": "inlineCode",
                      "value": "TypeError"
                    },
                    {
                      "type": "text",
                      "value": ",   e.g., in "
                    },
                    {
                      "type": "inlineCode",
                      "value": "reshape"
                    },
                    {
                      "type": "text",
                      "value": ", "
                    },
                    {
                      "type": "inlineCode",
                      "value": "take"
                    },
                    {
                      "type": "text",
                      "value": ", and specifying reduce axis."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 2,
      "target": null,
      "title": "DeprecationWarning to error",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "np.full"
                    },
                    {
                      "type": "text",
                      "value": " now returns an array of the fill-value's dtype if no dtype is   given, instead of defaulting to float."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "np.average"
                    },
                    {
                      "type": "text",
                      "value": " will emit a warning if the argument is a subclass of ndarray,   as the subclass will be preserved starting in 1.13. (see Future Changes)"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 2,
      "target": null,
      "title": "FutureWarning to changed behavior",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The previous behavior depended on whether numpy scalar integers or numpy integer arrays were involved."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "For arrays"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Zero to negative integer powers returned least integral value."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Both 1, -1 to negative integer powers returned correct values."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The remaining integers returned zero when raised to negative integer powers."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "For scalars"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Zero to negative integer powers returned least integral value."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Both 1, -1 to negative integer powers returned correct values."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The remaining integers sometimes returned zero, sometimes the   correct float depending on the integer type combination."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "All of these cases now raise a "
            },
            {
              "type": "inlineCode",
              "value": "ValueError"
            },
            {
              "type": "text",
              "value": " except for those integer combinations whose common type is float, for instance uint64 and int8. It was felt that a simple rule was the best way to go rather than have special exceptions for the integer units. If you need negative powers, use an inexact type."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``power`` and ``**`` raise errors for integer to negative integer powers",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "This will have some impact on code that assumed that "
            },
            {
              "type": "inlineCode",
              "value": "F_CONTIGUOUS"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "C_CONTIGUOUS"
            },
            {
              "type": "text",
              "value": " were mutually exclusive and could be set to determine the default order for arrays that are now both."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Relaxed stride checking is the default",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The 'midpoint' interpolator now gives the same result as 'lower' and 'higher' when the two coincide. Previous behavior of 'lower' + 0.5 is fixed."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "The ``np.percentile`` 'midpoint' interpolation method fixed for exact indices",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "numpy functions that take a "
            },
            {
              "type": "inlineCode",
              "value": "keepdims"
            },
            {
              "type": "text",
              "value": " kwarg now pass the value through to the corresponding methods on ndarray sub-classes.  Previously the "
            },
            {
              "type": "inlineCode",
              "value": "keepdims"
            },
            {
              "type": "text",
              "value": " keyword would be silently dropped.  These functions now have the following behavior:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "If user does not provide "
                    },
                    {
                      "type": "inlineCode",
                      "value": "keepdims"
                    },
                    {
                      "type": "text",
                      "value": ", no keyword is passed to the underlying    method."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Any user-provided value of "
                    },
                    {
                      "type": "inlineCode",
                      "value": "keepdims"
                    },
                    {
                      "type": "text",
                      "value": " is passed through as a keyword    argument to the method."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": true,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This will raise in the case where the method does not support a "
            },
            {
              "type": "inlineCode",
              "value": "keepdims"
            },
            {
              "type": "text",
              "value": " kwarg and the user explicitly passes in "
            },
            {
              "type": "inlineCode",
              "value": "keepdims"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The following functions are changed: "
            },
            {
              "type": "inlineCode",
              "value": "sum"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "product"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "sometrue"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "alltrue"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "any"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "all"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "amax"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "amin"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "prod"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "mean"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "std"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "var"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "nanmin"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "nanmax"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "nansum"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "nanprod"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "nanmean"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "nanmedian"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "nanvar"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "nanstd"
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``keepdims`` kwarg is passed through to user-class methods",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The previous identity was 1, it is now -1. See entry in Improvements for more explanation."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``bitwise_and`` identity changed",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Similar to unmasked median the masked median "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "ma.median"
            },
            {
              "type": "text",
              "value": " now emits a Runtime warning and returns "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "NaN"
            },
            {
              "type": "text",
              "value": " in slices where an unmasked "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "NaN"
            },
            {
              "type": "text",
              "value": " is present."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "ma.median warns and returns nan when unmasked invalid values are encountered",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The precision check for scalars has been changed to match that for arrays. It is now      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": "abs(actual - desired) < 1.5 * 10**(-decimal)"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Note that this is looser than previously documented, but agrees with the previous implementation used in "
            },
            {
              "type": "inlineCode",
              "value": "assert_array_almost_equal"
            },
            {
              "type": "text",
              "value": ". Due to the change in implementation some very delicate tests may fail that did not fail before."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Greater consistency in ``assert_almost_equal``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "When "
            },
            {
              "type": "inlineCode",
              "value": "raise_warnings=\"develop\""
            },
            {
              "type": "text",
              "value": " is given, all uncaught warnings will now be considered a test failure. Previously only selected ones were raised. Warnings which are not caught or raised (mostly when in release mode) will be shown once during the test cycle similar to the default python settings."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``NoseTester`` behaviour of warnings during testing",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The "
            },
            {
              "type": "inlineCode",
              "value": "assert_warns"
            },
            {
              "type": "text",
              "value": " function and context manager are now more specific to the given warning category. This increased specificity leads to them being handled according to the outer warning settings. This means that no warning may be raised in cases where a wrong category warning is given and ignored outside the context. Alternatively the increased specificity may mean that warnings that were incorrectly ignored will now be shown or raised. See also the new "
            },
            {
              "type": "inlineCode",
              "value": "suppress_warnings"
            },
            {
              "type": "text",
              "value": " context manager. The same is true for the "
            },
            {
              "type": "inlineCode",
              "value": "deprecated"
            },
            {
              "type": "text",
              "value": " decorator."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``assert_warns`` and ``deprecated`` decorator more specific",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "No changes."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "C API",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "New Features",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "np.lib.stride_tricks.as_strided"
            },
            {
              "type": "text",
              "value": " now has a "
            },
            {
              "type": "inlineCode",
              "value": "writeable"
            },
            {
              "type": "text",
              "value": " keyword argument. It can be set to False when no write operation to the returned array is expected to avoid accidental unpredictable writes."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Writeable keyword argument for ``as_strided``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The "
            },
            {
              "type": "inlineCode",
              "value": "axes"
            },
            {
              "type": "text",
              "value": " keyword argument in "
            },
            {
              "type": "inlineCode",
              "value": "rot90"
            },
            {
              "type": "text",
              "value": " determines the plane in which the array is rotated. It defaults to "
            },
            {
              "type": "inlineCode",
              "value": "axes=(0,1)"
            },
            {
              "type": "text",
              "value": " as in the original function."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``axes`` keyword argument for ``rot90``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "flipud"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "fliplr"
            },
            {
              "type": "text",
              "value": " reverse the elements of an array along axis=0 and axis=1 respectively. The newly added "
            },
            {
              "type": "inlineCode",
              "value": "flip"
            },
            {
              "type": "text",
              "value": " function reverses the elements of an array along any given axis."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "np.count_nonzero"
                    },
                    {
                      "type": "text",
                      "value": " now has an "
                    },
                    {
                      "type": "inlineCode",
                      "value": "axis"
                    },
                    {
                      "type": "text",
                      "value": " parameter, allowing   non-zero counts to be generated on more than just a flattened   array object."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Generalized ``flip``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Building against the BLAS implementation provided by the BLIS library is now supported.  See the "
            },
            {
              "type": "inlineCode",
              "value": "[blis]"
            },
            {
              "type": "text",
              "value": " section in "
            },
            {
              "type": "inlineCode",
              "value": "site.cfg.example"
            },
            {
              "type": "text",
              "value": " (in the root of the numpy repo or source distribution)."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "BLIS support in ``numpy.distutils``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Binary distributions of numpy may need to run specific hardware checks or load specific libraries during numpy initialization.  For example, if we are distributing numpy with a BLAS library that requires SSE2 instructions, we would like to check the machine on which numpy is running does have SSE2 in order to give an informative error."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Add a hook in "
            },
            {
              "type": "inlineCode",
              "value": "numpy/__init__.py"
            },
            {
              "type": "text",
              "value": " to import a "
            },
            {
              "type": "inlineCode",
              "value": "numpy/_distributor_init.py"
            },
            {
              "type": "text",
              "value": " file that will remain empty (bar a docstring) in the standard numpy source, but that can be overwritten by people making binary distributions of numpy."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Hook in ``numpy/__init__.py`` to run distribution-specific checks",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Nan-functions "
            },
            {
              "type": "inlineCode",
              "value": "nancumsum"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "nancumprod"
            },
            {
              "type": "text",
              "value": " have been added to compute "
            },
            {
              "type": "inlineCode",
              "value": "cumsum"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "cumprod"
            },
            {
              "type": "text",
              "value": " by ignoring nans."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "New nanfunctions ``nancumsum`` and ``nancumprod`` added",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "np.lib.interp(x, xp, fp)"
            },
            {
              "type": "text",
              "value": " now allows the interpolated array "
            },
            {
              "type": "inlineCode",
              "value": "fp"
            },
            {
              "type": "text",
              "value": " to be complex and will interpolate at "
            },
            {
              "type": "inlineCode",
              "value": "complex128"
            },
            {
              "type": "text",
              "value": " precision."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``np.interp`` can now interpolate complex values",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The new function "
            },
            {
              "type": "inlineCode",
              "value": "polyvalfromroots"
            },
            {
              "type": "text",
              "value": " evaluates a polynomial at given points from the roots of the polynomial. This is useful for higher order polynomials, where expansion into polynomial coefficients is inaccurate at machine precision."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "New polynomial evaluation function ``polyvalfromroots`` added",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The new function "
            },
            {
              "type": "inlineCode",
              "value": "geomspace"
            },
            {
              "type": "text",
              "value": " generates a geometric sequence.  It is similar to "
            },
            {
              "type": "inlineCode",
              "value": "logspace"
            },
            {
              "type": "text",
              "value": ", but with start and stop specified directly: "
            },
            {
              "type": "inlineCode",
              "value": "geomspace(start, stop)"
            },
            {
              "type": "text",
              "value": " behaves the same as "
            },
            {
              "type": "inlineCode",
              "value": "logspace(log10(start), log10(stop))"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "New array creation function ``geomspace`` added",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "A new context manager "
            },
            {
              "type": "inlineCode",
              "value": "suppress_warnings"
            },
            {
              "type": "text",
              "value": " has been added to the testing utils. This context manager is designed to help reliably test warnings. Specifically to reliably filter/ignore warnings. Ignoring warnings by using an \"ignore\" filter in Python versions before 3.4.x can quickly result in these (or similar) warnings not being tested reliably."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The context manager allows to filter (as well as record) warnings similar to the "
            },
            {
              "type": "inlineCode",
              "value": "catch_warnings"
            },
            {
              "type": "text",
              "value": " context, but allows for easier specificity. Also printing warnings that have not been filtered or nesting the context manager will work as expected. Additionally, it is possible to use the context manager as a decorator which can be useful when multiple tests give need to hide the same warning."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "New context manager for testing warnings",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "These functions wrapped the non-masked versions, but propagate through masked values. There are two different propagation modes. The default causes masked values to contaminate the result with masks, but the other mode only outputs masks if there is no alternative."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "New masked array functions ``ma.convolve`` and ``ma.correlate`` added",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The new "
            },
            {
              "type": "inlineCode",
              "value": "float_power"
            },
            {
              "type": "text",
              "value": " ufunc is like the "
            },
            {
              "type": "inlineCode",
              "value": "power"
            },
            {
              "type": "text",
              "value": " function except all computation is done in a minimum precision of float64. There was a long discussion on the numpy mailing list of how to treat integers to negative integer powers and a popular proposal was that the "
            },
            {
              "type": "inlineCode",
              "value": "__pow__"
            },
            {
              "type": "text",
              "value": " operator should always return results of at least float64 precision. The "
            },
            {
              "type": "inlineCode",
              "value": "float_power"
            },
            {
              "type": "text",
              "value": " function implements that option. Note that it does not support object arrays."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "New ``float_power`` ufunc",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Instead of using "
            },
            {
              "type": "inlineCode",
              "value": "usecol=(n,)"
            },
            {
              "type": "text",
              "value": " to read the nth column of a file it is now allowed to use "
            },
            {
              "type": "inlineCode",
              "value": "usecol=n"
            },
            {
              "type": "text",
              "value": ". Also the error message is more user friendly when a non-integer is passed as a column index."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``np.loadtxt`` now supports a single integer as ``usecol`` argument",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Added 'doane' and 'sqrt' estimators to "
            },
            {
              "type": "inlineCode",
              "value": "histogram"
            },
            {
              "type": "text",
              "value": " via the "
            },
            {
              "type": "inlineCode",
              "value": "bins"
            },
            {
              "type": "text",
              "value": " argument. Added support for range-restricted histograms with automated bin estimation."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Improved automated bin estimators for ``histogram``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The "
            },
            {
              "type": "inlineCode",
              "value": "shift"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "axis"
            },
            {
              "type": "text",
              "value": " arguments to "
            },
            {
              "type": "inlineCode",
              "value": "roll"
            },
            {
              "type": "text",
              "value": " are now broadcast against each other, and each specified axis is shifted accordingly."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``np.roll`` can now roll multiple axes at the same time",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Calling "
            },
            {
              "type": "inlineCode",
              "value": "complex()"
            },
            {
              "type": "text",
              "value": " on a size 1 array will now cast to a python complex."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "The ``__complex__`` method has been implemented for the ndarrays",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The standard "
            },
            {
              "type": "inlineCode",
              "value": "np.load"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "np.save"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "np.loadtxt"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "np.savez"
            },
            {
              "type": "text",
              "value": ", and similar functions can now take "
            },
            {
              "type": "inlineCode",
              "value": "pathlib.Path"
            },
            {
              "type": "text",
              "value": " objects as an argument instead of a filename or open file object."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``pathlib.Path`` objects now supported",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "This makes "
            },
            {
              "type": "inlineCode",
              "value": "np.finfo"
            },
            {
              "type": "text",
              "value": " consistent with "
            },
            {
              "type": "inlineCode",
              "value": "np.iinfo"
            },
            {
              "type": "text",
              "value": " which already has that attribute."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "New ``bits`` attribute for ``np.finfo``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "This argument allows for vectorizing user defined functions with core dimensions, in the style of NumPy's "
            },
            {
              "type": "inlineCode",
              "value": "generalized universal functions<c-api.generalized-ufuncs>"
            },
            {
              "type": "text",
              "value": ". This allows for vectorizing a much broader class of functions. For example, an arbitrary distance metric that combines two vectors to produce a scalar could be vectorized with "
            },
            {
              "type": "inlineCode",
              "value": "signature='(n),(n)->()'"
            },
            {
              "type": "text",
              "value": ". See "
            },
            {
              "type": "inlineCode",
              "value": "np.vectorize"
            },
            {
              "type": "text",
              "value": " for full details."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "New ``signature`` argument to ``np.vectorize``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "To help people migrate their code bases from Python 2 to Python 3, the python interpreter has a handy option -3, which issues warnings at runtime. One of its warnings is for integer division      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": "$ python -3 -c \"2/3\"\n\n-c:1: DeprecationWarning: classic int division"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In Python 3, the new integer division semantics also apply to numpy arrays. With this version, numpy will emit a similar warning      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": "$ python -3 -c \"import numpy as np; np.array(2)/np.array(3)\"\n\n-c:1: DeprecationWarning: numpy: classic int division"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Emit py3kwarnings for division of integer arrays",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Previously, it included str (bytes) and unicode on Python2, but only str (unicode) on Python3."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "numpy.sctypes now includes bytes on Python3 too",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "Improvements",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The previous identity was 1 with the result that all bits except the LSB were masked out when the reduce method was used.  The new identity is -1, which should work properly on twos complement machines as all bits will be set to one."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``bitwise_and`` identity changed",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Generalized Ufuncs, including most of the linalg module, will now unlock the Python global interpreter lock."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Generalized Ufuncs will now unlock the GIL",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The caches in "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "np.fft"
            },
            {
              "type": "text",
              "value": " that speed up successive FFTs of the same length can no longer grow without bounds. They have been replaced with LRU (least recently used) caches that automatically evict no longer needed items if either the memory size or item count limit has been reached."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Caches in `np.fft` are now bounded in total size and item count",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Fixed several interfaces that explicitly disallowed arrays with zero-width string dtypes (i.e. "
            },
            {
              "type": "inlineCode",
              "value": "dtype('S0')"
            },
            {
              "type": "text",
              "value": " or "
            },
            {
              "type": "inlineCode",
              "value": "dtype('U0')"
            },
            {
              "type": "text",
              "value": ", and fixed several bugs where such dtypes were not handled properly.  In particular, changed "
            },
            {
              "type": "inlineCode",
              "value": "ndarray.__new__"
            },
            {
              "type": "text",
              "value": " to not implicitly convert "
            },
            {
              "type": "inlineCode",
              "value": "dtype('S0')"
            },
            {
              "type": "text",
              "value": " to "
            },
            {
              "type": "inlineCode",
              "value": "dtype('S1')"
            },
            {
              "type": "text",
              "value": " (and likewise for unicode) when creating new arrays."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Improved handling of zero-width string/unicode dtypes",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "If the cpu supports it at runtime the basic integer ufuncs now use AVX2 instructions. This feature is currently only available when compiled with GCC."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Integer ufuncs vectorized with AVX2",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "np.einsum"
            },
            {
              "type": "text",
              "value": " now supports the "
            },
            {
              "type": "inlineCode",
              "value": "optimize"
            },
            {
              "type": "text",
              "value": " argument which will optimize the order of contraction. For example, "
            },
            {
              "type": "inlineCode",
              "value": "np.einsum"
            },
            {
              "type": "text",
              "value": " would complete the chain dot example "
            },
            {
              "type": "inlineCode",
              "value": "np.einsum(\u2018ij,jk,kl->il\u2019, a, b, c)"
            },
            {
              "type": "text",
              "value": " in a single pass which would scale like "
            },
            {
              "type": "inlineCode",
              "value": "N^4"
            },
            {
              "type": "text",
              "value": "; however, when "
            },
            {
              "type": "inlineCode",
              "value": "optimize=True"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "np.einsum"
            },
            {
              "type": "text",
              "value": " will create an intermediate array to reduce this scaling to "
            },
            {
              "type": "inlineCode",
              "value": "N^3"
            },
            {
              "type": "text",
              "value": " or effectively "
            },
            {
              "type": "inlineCode",
              "value": "np.dot(a, b).dot(c)"
            },
            {
              "type": "text",
              "value": ". Usage of intermediate tensors to reduce scaling has been applied to the general einsum summation notation. See "
            },
            {
              "type": "inlineCode",
              "value": "np.einsum_path"
            },
            {
              "type": "text",
              "value": " for more details."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Order of operations optimization in ``np.einsum``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The quicksort kind of "
            },
            {
              "type": "inlineCode",
              "value": "np.sort"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "np.argsort"
            },
            {
              "type": "text",
              "value": " is now an introsort which is regular quicksort but changing to a heapsort when not enough progress is made. This retains the good quicksort performance while changing the worst case runtime from "
            },
            {
              "type": "inlineCode",
              "value": "O(N^2)"
            },
            {
              "type": "text",
              "value": " to "
            },
            {
              "type": "inlineCode",
              "value": "O(N*log(N))"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "quicksort has been changed to an introsort",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The ediff1d function uses an array instead on a flat iterator for the subtraction.  When to_begin or to_end is not None, the subtraction is performed in place to eliminate a copy operation.  A side effect is that certain subclasses are handled better, namely astropy.Quantity, since the complete array is created, wrapped, and then begin and end values are set, instead of using concatenate."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``ediff1d`` improved performance and subclass handling",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The computation of the mean of float16 arrays is now carried out in float32 for improved precision. This should be useful in packages such as Theano where the precision of float16 is adequate and its smaller footprint is desirable."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Improved precision of ``ndarray.mean`` for float16 arrays",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "Changes",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Internally, many array-like methods in fromnumeric.py were being called with positional arguments instead of keyword arguments as their external signatures were doing. This caused a complication in the downstream 'pandas' library that encountered an issue with 'numpy' compatibility. Now, all array-like methods in this module are called with keyword arguments instead."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "All array-like methods are now called with keyword arguments in fromnumeric.py",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Previously operations on a memmap object would misleadingly return a memmap instance even if the result was actually not memmapped.  For example, "
            },
            {
              "type": "inlineCode",
              "value": "arr + 1"
            },
            {
              "type": "text",
              "value": " or "
            },
            {
              "type": "inlineCode",
              "value": "arr + arr"
            },
            {
              "type": "text",
              "value": " would return memmap instances, although no memory from the output array is memmapped. Version 1.12 returns ordinary numpy arrays from these operations."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Also, reduction of a memmap (e.g.  "
            },
            {
              "type": "inlineCode",
              "value": ".sum(axis=None"
            },
            {
              "type": "text",
              "value": ") now returns a numpy scalar instead of a 0d memmap."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Operations on np.memmap objects return numpy arrays in most cases",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The stacklevel for python based warnings was increased so that most warnings will report the offending line of the user code instead of the line the warning itself is given. Passing of stacklevel is now tested to ensure that new warnings will receive the "
            },
            {
              "type": "inlineCode",
              "value": "stacklevel"
            },
            {
              "type": "text",
              "value": " argument."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This causes warnings with the \"default\" or \"module\" filter to be shown once for every offending user code line or user module instead of only once. On python versions before 3.4, this can cause warnings to appear that were falsely ignored before, which may be surprising especially in test suits."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "stacklevel of warnings increased",
      "type": "Section"
    }
  ],
  "content": {},
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null,
    "type": "Section"
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "see_also": [],
  "signature": {
    "type": "Signature",
    "value": null
  },
  "type": "DocBlob"
}