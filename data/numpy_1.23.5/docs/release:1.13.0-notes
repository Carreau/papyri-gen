{
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "This release supports Python 2.7 and 3.4 - 3.6."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": "NumPy 1.13.0 Release Notes",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "Operations like "
                        },
                        {
                          "type": "inlineCode",
                          "value": "a + b + c"
                        },
                        {
                          "type": "text",
                          "value": " will reuse temporaries on some platforms,    resulting in less memory use and faster execution."
                        }
                      ],
                      "type": "paragraph"
                    }
                  ],
                  "spread": false,
                  "type": "listItem"
                },
                {
                  "children": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "Inplace operations check if inputs overlap outputs and create temporaries    to avoid problems."
                        }
                      ],
                      "type": "paragraph"
                    }
                  ],
                  "spread": false,
                  "type": "listItem"
                },
                {
                  "children": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "New "
                        },
                        {
                          "type": "inlineCode",
                          "value": "__array_ufunc__"
                        },
                        {
                          "type": "text",
                          "value": " attribute provides improved ability for classes to    override default ufunc behavior."
                        }
                      ],
                      "type": "paragraph"
                    }
                  ],
                  "spread": false,
                  "type": "listItem"
                },
                {
                  "children": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "New "
                        },
                        {
                          "type": "inlineCode",
                          "value": "np.block"
                        },
                        {
                          "type": "text",
                          "value": " function for creating blocked arrays."
                        }
                      ],
                      "type": "paragraph"
                    }
                  ],
                  "spread": false,
                  "type": "listItem"
                }
              ],
              "ordered": false,
              "spread": false,
              "start": 1,
              "type": "list"
            }
          ],
          "type": "blockquote"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Highlights",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "New "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.positive"
                    },
                    {
                      "type": "text",
                      "value": " ufunc."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "New "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.divmod"
                    },
                    {
                      "type": "text",
                      "value": " ufunc provides more efficient divmod."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "New "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.isnat"
                    },
                    {
                      "type": "text",
                      "value": " ufunc tests for NaT special values."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "New "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.heaviside"
                    },
                    {
                      "type": "text",
                      "value": " ufunc computes the Heaviside function."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "New "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.isin"
                    },
                    {
                      "type": "text",
                      "value": " function, improves on "
                    },
                    {
                      "type": "inlineCode",
                      "value": "in1d"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "New "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.block"
                    },
                    {
                      "type": "text",
                      "value": " function for creating blocked arrays."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "New "
                    },
                    {
                      "type": "inlineCode",
                      "value": "PyArray_MapIterArrayCopyIfOverlap"
                    },
                    {
                      "type": "text",
                      "value": " added to NumPy C-API."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "See below for details."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "New functions",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Calling "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.fix"
                    },
                    {
                      "type": "text",
                      "value": ", "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.isposinf"
                    },
                    {
                      "type": "text",
                      "value": ", and "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.isneginf"
                    },
                    {
                      "type": "text",
                      "value": " with "
                    },
                    {
                      "type": "inlineCode",
                      "value": "f(x, y=out)"
                    },
                    {
                      "type": "text",
                      "value": "   is deprecated - the argument should be passed as "
                    },
                    {
                      "type": "inlineCode",
                      "value": "f(x, out=out)"
                    },
                    {
                      "type": "text",
                      "value": ", which   matches other ufunc-like interfaces."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Use of the C-API "
                    },
                    {
                      "type": "inlineCode",
                      "value": "NPY_CHAR"
                    },
                    {
                      "type": "text",
                      "value": " type number deprecated since version 1.7 will   now raise deprecation warnings at runtime. Extensions built with older f2py   versions need to be recompiled to remove the warning."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "np.ma.argsort"
                    },
                    {
                      "type": "text",
                      "value": ", "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.ma.minimum.reduce"
                    },
                    {
                      "type": "text",
                      "value": ", and "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.ma.maximum.reduce"
                    },
                    {
                      "type": "text",
                      "value": "   should be called with an explicit "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "axis"
                    },
                    {
                      "type": "text",
                      "value": " argument when applied to arrays with   more than 2 dimensions, as the default value of this argument ("
                    },
                    {
                      "type": "inlineCode",
                      "value": "None"
                    },
                    {
                      "type": "text",
                      "value": ") is   inconsistent with the rest of numpy ("
                    },
                    {
                      "type": "inlineCode",
                      "value": "-1"
                    },
                    {
                      "type": "text",
                      "value": ", "
                    },
                    {
                      "type": "inlineCode",
                      "value": "0"
                    },
                    {
                      "type": "text",
                      "value": ", and "
                    },
                    {
                      "type": "inlineCode",
                      "value": "0"
                    },
                    {
                      "type": "text",
                      "value": ", respectively)."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "np.ma.MaskedArray.mini"
                    },
                    {
                      "type": "text",
                      "value": " is deprecated, as it almost duplicates the   functionality of "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.MaskedArray.min"
                    },
                    {
                      "type": "text",
                      "value": ". Exactly equivalent behaviour   can be obtained with "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.ma.minimum.reduce"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The single-argument form of "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.ma.minimum"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.ma.maximum"
                    },
                    {
                      "type": "text",
                      "value": " is   deprecated. "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.maximum"
                    },
                    {
                      "type": "text",
                      "value": ". "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.ma.minimum(x)"
                    },
                    {
                      "type": "text",
                      "value": " should now be spelt   "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.ma.minimum.reduce(x)"
                    },
                    {
                      "type": "text",
                      "value": ", which is consistent with how this would be done   with "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.minimum"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Calling "
                    },
                    {
                      "type": "inlineCode",
                      "value": "ndarray.conjugate"
                    },
                    {
                      "type": "text",
                      "value": " on non-numeric dtypes is deprecated (it   should match the behavior of "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.conjugate"
                    },
                    {
                      "type": "text",
                      "value": ", which throws an error)."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Calling "
                    },
                    {
                      "type": "inlineCode",
                      "value": "expand_dims"
                    },
                    {
                      "type": "text",
                      "value": " when the "
                    },
                    {
                      "type": "inlineCode",
                      "value": "axis"
                    },
                    {
                      "type": "text",
                      "value": " keyword does not satisfy   "
                    },
                    {
                      "type": "inlineCode",
                      "value": "-a.ndim - 1 <= axis <= a.ndim"
                    },
                    {
                      "type": "text",
                      "value": ", where "
                    },
                    {
                      "type": "inlineCode",
                      "value": "a"
                    },
                    {
                      "type": "text",
                      "value": " is the array being reshaped,   is deprecated."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Deprecations",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Assignment between structured arrays with different field names will change   in NumPy 1.14. Previously, fields in the dst would be set to the value of the   identically-named field in the src. In numpy 1.14 fields will instead be   assigned 'by position': The n-th field of the dst will be set to the n-th   field of the src array. Note that the "
                    },
                    {
                      "type": "inlineCode",
                      "value": "FutureWarning"
                    },
                    {
                      "type": "text",
                      "value": " raised in NumPy 1.12   incorrectly reported this change as scheduled for NumPy 1.13 rather than   NumPy 1.14."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Future Changes",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "numpy.distutils"
                    },
                    {
                      "type": "text",
                      "value": " now automatically determines C-file dependencies with   GCC compatible compilers."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Build System Changes",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "Compatibility notes",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "numpy.hstack()"
                    },
                    {
                      "type": "text",
                      "value": " now throws "
                    },
                    {
                      "type": "inlineCode",
                      "value": "ValueError"
                    },
                    {
                      "type": "text",
                      "value": " instead of "
                    },
                    {
                      "type": "inlineCode",
                      "value": "IndexError"
                    },
                    {
                      "type": "text",
                      "value": " when   input is empty."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Functions taking an axis argument, when that argument is out of range, now   throw "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.AxisError"
                    },
                    {
                      "type": "text",
                      "value": " instead of a mixture of "
                    },
                    {
                      "type": "inlineCode",
                      "value": "IndexError"
                    },
                    {
                      "type": "text",
                      "value": " and   "
                    },
                    {
                      "type": "inlineCode",
                      "value": "ValueError"
                    },
                    {
                      "type": "text",
                      "value": ". For backwards compatibility, "
                    },
                    {
                      "type": "inlineCode",
                      "value": "AxisError"
                    },
                    {
                      "type": "text",
                      "value": " subclasses both of   these."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Error type changes",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Support has been removed for certain obscure dtypes that were unintentionally allowed, of the form "
            },
            {
              "type": "inlineCode",
              "value": "(old_dtype, new_dtype)"
            },
            {
              "type": "text",
              "value": ", where either of the dtypes is or contains the "
            },
            {
              "type": "inlineCode",
              "value": "object"
            },
            {
              "type": "text",
              "value": " dtype. As an exception, dtypes of the form "
            },
            {
              "type": "inlineCode",
              "value": "(object, [('name', object)])"
            },
            {
              "type": "text",
              "value": " are still supported due to evidence of existing use."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Tuple object dtypes",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "See Changes section for more detail."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "partition"
                    },
                    {
                      "type": "text",
                      "value": ", TypeError when non-integer partition index is used."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "NpyIter_AdvancedNew"
                    },
                    {
                      "type": "text",
                      "value": ", ValueError when "
                    },
                    {
                      "type": "inlineCode",
                      "value": "oa_ndim == 0"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "type": "inlineCode",
                      "value": "op_axes"
                    },
                    {
                      "type": "text",
                      "value": " is NULL"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "negative(bool_)"
                    },
                    {
                      "type": "text",
                      "value": ", TypeError when negative applied to booleans."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "subtract(bool_, bool_)"
                    },
                    {
                      "type": "text",
                      "value": ", TypeError when subtracting boolean from boolean."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "np.equal, np.not_equal"
                    },
                    {
                      "type": "text",
                      "value": ", object identity doesn't override failed comparison."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "np.equal, np.not_equal"
                    },
                    {
                      "type": "text",
                      "value": ", object identity doesn't override non-boolean comparison."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Deprecated boolean indexing behavior dropped. See Changes below for details."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Deprecated "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.alterdot()"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.restoredot()"
                    },
                    {
                      "type": "text",
                      "value": " removed."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 2,
      "target": null,
      "title": "DeprecationWarning to error",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "See Changes section for more detail."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "numpy.average"
                    },
                    {
                      "type": "text",
                      "value": " preserves subclasses"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "array == None"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "type": "inlineCode",
                      "value": "array != None"
                    },
                    {
                      "type": "text",
                      "value": " do element-wise comparison."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "np.equal, np.not_equal"
                    },
                    {
                      "type": "text",
                      "value": ", object identity doesn't override comparison result."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 2,
      "target": null,
      "title": "FutureWarning to changed behavior",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Previously "
            },
            {
              "type": "inlineCode",
              "value": "bool(dtype)"
            },
            {
              "type": "text",
              "value": " would fall back to the default python implementation, which checked if "
            },
            {
              "type": "inlineCode",
              "value": "len(dtype) > 0"
            },
            {
              "type": "text",
              "value": ". Since "
            },
            {
              "type": "inlineCode",
              "value": "dtype"
            },
            {
              "type": "text",
              "value": " objects implement "
            },
            {
              "type": "inlineCode",
              "value": "__len__"
            },
            {
              "type": "text",
              "value": " as the number of record fields, "
            },
            {
              "type": "inlineCode",
              "value": "bool"
            },
            {
              "type": "text",
              "value": " of scalar dtypes would evaluate to "
            },
            {
              "type": "inlineCode",
              "value": "False"
            },
            {
              "type": "text",
              "value": ", which was unintuitive. Now "
            },
            {
              "type": "inlineCode",
              "value": "bool(dtype) == True"
            },
            {
              "type": "text",
              "value": " for all dtypes."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "dtypes are now always true",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "When subclassing np.ndarray in Python 2.7, it is no longer _necessary_ to implement "
            },
            {
              "type": "inlineCode",
              "value": "__*slice__"
            },
            {
              "type": "text",
              "value": " on the derived class, as "
            },
            {
              "type": "inlineCode",
              "value": "__*item__"
            },
            {
              "type": "text",
              "value": " will intercept these calls correctly."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Any code that did implement these will work exactly as before. Code that invokes``ndarray.__getslice__`` (e.g. through "
            },
            {
              "type": "inlineCode",
              "value": "super(...).__getslice__"
            },
            {
              "type": "text",
              "value": ") will now issue a DeprecationWarning - "
            },
            {
              "type": "inlineCode",
              "value": ".__getitem__(slice(start, end))"
            },
            {
              "type": "text",
              "value": " should be used instead."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``__getslice__`` and ``__setslice__`` are no longer needed in ``ndarray`` subclasses",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "This behavior mirrors that of np.ndarray, and accounts for nested arrays in MaskedArrays of object dtype, and ellipsis combined with other forms of indexing."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Indexing MaskedArrays/Constants with ``...`` (ellipsis) now returns MaskedArray",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "C API changes",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "It is now allowed to remove a zero-sized axis from NpyIter. Which may mean that code removing axes from NpyIter has to add an additional check when accessing the removed dimensions later on."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The largest followup change is that gufuncs are now allowed to have zero-sized inner dimensions. This means that a gufunc now has to anticipate an empty inner dimension, while this was never possible and an error raised instead."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "For most gufuncs no change should be necessary. However, it is now possible for gufuncs with a signature such as "
            },
            {
              "type": "inlineCode",
              "value": "(..., N, M) -> (..., M)"
            },
            {
              "type": "text",
              "value": " to return a valid result if "
            },
            {
              "type": "inlineCode",
              "value": "N=0"
            },
            {
              "type": "text",
              "value": " without further wrapping code."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "GUfuncs on empty arrays and NpyIter axis removal",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Similar to "
            },
            {
              "type": "inlineCode",
              "value": "PyArray_MapIterArray"
            },
            {
              "type": "text",
              "value": " but with an additional "
            },
            {
              "type": "inlineCode",
              "value": "copy_if_overlap"
            },
            {
              "type": "text",
              "value": " argument. If "
            },
            {
              "type": "inlineCode",
              "value": "copy_if_overlap != 0"
            },
            {
              "type": "text",
              "value": ",  checks if input has memory overlap with any of the other arrays and make copies as appropriate to avoid problems if the input is modified during the iteration. See the documentation for more complete documentation."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``PyArray_MapIterArrayCopyIfOverlap`` added to NumPy C-API",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "New Features",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "This is the renamed and redesigned "
            },
            {
              "type": "inlineCode",
              "value": "__numpy_ufunc__"
            },
            {
              "type": "text",
              "value": ". Any class, ndarray subclass or not, can define this method or set it to "
            },
            {
              "type": "inlineCode",
              "value": "None"
            },
            {
              "type": "text",
              "value": " in order to override the behavior of NumPy's ufuncs. This works quite similarly to Python's "
            },
            {
              "type": "inlineCode",
              "value": "__mul__"
            },
            {
              "type": "text",
              "value": " and other binary operation routines. See the documentation for a more detailed description of the implementation and behavior of this new option. The API is provisional, we do not yet guarantee backward compatibility as modifications may be made pending feedback. See "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "NEP 13"
            },
            {
              "type": "text",
              "value": "  and "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "documentation_"
            },
            {
              "type": "text",
              "value": " for more details."
            }
          ],
          "type": "paragraph"
        },
        {
          "placeholder": "target",
          "type": "Unimplemented",
          "value": ".. _`NEP 13`: http://www.numpy.org/neps/nep-0013-ufunc-overrides.html"
        },
        {
          "placeholder": "target",
          "type": "Unimplemented",
          "value": ".. _documentation: https://github.com/numpy/numpy/blob/master/doc/source/reference/arrays.classes.rst"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``__array_ufunc__`` added",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "This ufunc corresponds to unary "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "+"
            },
            {
              "type": "text",
              "value": ", but unlike "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "+"
            },
            {
              "type": "text",
              "value": " on an ndarray it will raise an error if array values do not support numeric operations."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "New ``positive`` ufunc",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "This ufunc corresponds to the Python builtin "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "divmod"
            },
            {
              "type": "text",
              "value": ", and is used to implement "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "divmod"
            },
            {
              "type": "text",
              "value": " when called on numpy arrays. "
            },
            {
              "type": "inlineCode",
              "value": "np.divmod(x, y)"
            },
            {
              "type": "text",
              "value": " calculates a result equivalent to "
            },
            {
              "type": "inlineCode",
              "value": "(np.floor_divide(x, y), np.remainder(x, y))"
            },
            {
              "type": "text",
              "value": " but is approximately twice as fast as calling the functions separately."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "New ``divmod`` ufunc",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The new ufunc "
            },
            {
              "type": "inlineCode",
              "value": "np.isnat"
            },
            {
              "type": "text",
              "value": " finds the positions of special NaT values within datetime and timedelta arrays. This is analogous to "
            },
            {
              "type": "inlineCode",
              "value": "np.isnan"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``np.isnat`` ufunc tests for NaT special datetime and timedelta values",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The new function "
            },
            {
              "type": "inlineCode",
              "value": "np.heaviside(x, h0)"
            },
            {
              "type": "text",
              "value": " (a ufunc) computes the Heaviside function:"
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": "{ 0   if x < 0,"
        },
        {
          "children": [
            {
              "dd": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "{ 1   if x > 0."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "dt": {
                "children": [
                  {
                    "type": "text",
                    "value": "heaviside(x, h0) = { h0  if x == 0,"
                  }
                ],
                "type": "paragraph"
              },
              "type": "DefListItem"
            }
          ],
          "type": "DefList"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``np.heaviside`` ufunc computes the Heaviside function",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Add a new "
            },
            {
              "type": "inlineCode",
              "value": "block"
            },
            {
              "type": "text",
              "value": " function to the current stacking functions "
            },
            {
              "type": "inlineCode",
              "value": "vstack"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "hstack"
            },
            {
              "type": "text",
              "value": ", and "
            },
            {
              "type": "inlineCode",
              "value": "stack"
            },
            {
              "type": "text",
              "value": ". This allows concatenation across multiple axes simultaneously, with a similar syntax to array creation, but where elements can themselves be arrays. For instance      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> A = np.eye(2) * 2\n>>> B = np.eye(3) * 3\n>>> np.block([\n...     [A,               np.zeros((2, 3))],\n...     [np.ones((3, 2)), B               ]\n... ])\narray([[ 2.,  0.,  0.,  0.,  0.],\n       [ 0.,  2.,  0.,  0.,  0.],\n       [ 1.,  1.,  3.,  0.,  0.],\n       [ 1.,  1.,  0.,  3.,  0.],\n       [ 1.,  1.,  0.,  0.,  3.]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "While primarily useful for block matrices, this works for arbitrary dimensions of arrays."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "It is similar to Matlab's square bracket notation for creating block matrices."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``np.block`` function for creating blocked arrays",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The new function "
            },
            {
              "type": "inlineCode",
              "value": "isin"
            },
            {
              "type": "text",
              "value": " tests whether each element of an N-dimensional array is present anywhere within a second array. It is an enhancement of "
            },
            {
              "type": "inlineCode",
              "value": "in1d"
            },
            {
              "type": "text",
              "value": " that preserves the shape of the first array."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``isin`` function, improving on ``in1d``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "On platforms providing the "
            },
            {
              "type": "inlineCode",
              "value": "backtrace"
            },
            {
              "type": "text",
              "value": " function NumPy will try to avoid creating temporaries in expression involving basic numeric types. For example "
            },
            {
              "type": "inlineCode",
              "value": "d = a + b + c"
            },
            {
              "type": "text",
              "value": " is transformed to "
            },
            {
              "type": "inlineCode",
              "value": "d = a + b; d += c"
            },
            {
              "type": "text",
              "value": " which can improve performance for large arrays as less memory bandwidth is required to perform the operation."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Temporary elision",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "In an N-dimensional array, the user can now choose the axis along which to look for duplicate N-1-dimensional elements using "
            },
            {
              "type": "inlineCode",
              "value": "numpy.unique"
            },
            {
              "type": "text",
              "value": ". The original behaviour is recovered if "
            },
            {
              "type": "inlineCode",
              "value": "axis=None"
            },
            {
              "type": "text",
              "value": " (default)."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``axes`` argument for ``unique``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Users can now specify a not-constant spacing for data. In particular "
            },
            {
              "type": "inlineCode",
              "value": "np.gradient"
            },
            {
              "type": "text",
              "value": " can now take:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "A single scalar to specify a sample distance for all dimensions."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "N scalars to specify a constant sample distance for each dimension.    i.e. "
                    },
                    {
                      "type": "inlineCode",
                      "value": "dx"
                    },
                    {
                      "type": "text",
                      "value": ", "
                    },
                    {
                      "type": "inlineCode",
                      "value": "dy"
                    },
                    {
                      "type": "text",
                      "value": ", "
                    },
                    {
                      "type": "inlineCode",
                      "value": "dz"
                    },
                    {
                      "type": "text",
                      "value": ", ..."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "N arrays to specify the coordinates of the values along each dimension of F.    The length of the array must match the size of the corresponding dimension"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Any combination of N scalars/arrays with the meaning of 2. and 3."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": true,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This means that, e.g., it is now possible to do the following      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> f = np.array([[1, 2, 6], [3, 4, 5]], dtype=np.float_)\n>>> dx = 2.\n>>> y = [1., 1.5, 3.5]\n>>> np.gradient(f, dx, y)\n[array([[ 1. ,  1. , -0.5], [ 1. ,  1. , -0.5]]),\n array([[ 2. ,  2. ,  2. ], [ 2. ,  1.7,  0.5]])]"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``np.gradient`` now supports unevenly spaced data",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Previously, only scalars or 1D arrays could be returned by the function passed to "
            },
            {
              "type": "inlineCode",
              "value": "apply_along_axis"
            },
            {
              "type": "text",
              "value": ". Now, it can return an array of any dimensionality (including 0D), and the shape of this array replaces the axis of the array being iterated over."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Support for returning arrays of arbitrary dimensions in ``apply_along_axis``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "For consistency with "
            },
            {
              "type": "inlineCode",
              "value": "ndarray"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "broadcast"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "d.ndim"
            },
            {
              "type": "text",
              "value": " is a shorthand for "
            },
            {
              "type": "inlineCode",
              "value": "len(d.shape)"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``.ndim`` property added to ``dtype`` to complement ``.shape``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "NumPy now supports memory tracing with "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "tracemalloc_"
            },
            {
              "type": "text",
              "value": " module of Python 3.6 or newer. Memory allocations from NumPy are placed into the domain defined by "
            },
            {
              "type": "inlineCode",
              "value": "numpy.lib.tracemalloc_domain"
            },
            {
              "type": "text",
              "value": ". Note that NumPy allocation will not show up in "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "tracemalloc_"
            },
            {
              "type": "text",
              "value": " of earlier Python versions."
            }
          ],
          "type": "paragraph"
        },
        {
          "placeholder": "target",
          "type": "Unimplemented",
          "value": ".. _tracemalloc: https://docs.python.org/3/library/tracemalloc.html"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Support for tracemalloc in Python 3.6",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Setting NPY_RELAXED_STRIDES_DEBUG=1 in the environment when relaxed stride checking is enabled will cause NumPy to be compiled with the affected strides set to the maximum value of npy_intp in order to help detect invalid usage of the strides in downstream projects. When enabled, invalid usage often results in an error being raised, but the exact type of error depends on the details of the code. TypeError and OverflowError have been observed in the wild."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "It was previously the case that this option was disabled for releases and enabled in master and changing between the two required editing the code. It is now disabled by default but can be enabled for test builds."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "NumPy may be built with relaxed stride checking debugging",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "Improvements",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Operations where ufunc input and output operands have memory overlap produced undefined results in previous NumPy versions, due to data dependency issues. In NumPy 1.13.0, results from such operations are now defined to be the same as for equivalent operations where there is no memory overlap."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Operations affected now make temporary copies, as needed to eliminate data dependency. As detecting these cases is computationally expensive, a heuristic is used, which may in rare cases result to needless temporary copies.  For operations where the data dependency is simple enough for the heuristic to analyze, temporary copies will not be made even if the arrays overlap, if it can be deduced copies are not necessary.  As an example,``np.add(a, b, out=a)`` will not involve copies."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "To illustrate a previously undefined operation      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x = np.arange(16).astype(float)\n>>> np.add(x[1:], x[:-1], out=x[1:])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In NumPy 1.13.0 the last line is guaranteed to be equivalent to      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> np.add(x[1:].copy(), x[:-1].copy(), out=x[1:])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "A similar operation with simple non-problematic data dependence is      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x = np.arange(16).astype(float)\n>>> np.add(x[1:], x[:-1], out=x[:-1])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "It will continue to produce the same results as in previous NumPy versions, and will not involve unnecessary temporary copies."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The change applies also to in-place binary operations, for example      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x = np.random.rand(500, 500)\n>>> x += x.T"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This statement is now guaranteed to be equivalent to "
            },
            {
              "type": "inlineCode",
              "value": "x[...] = x + x.T"
            },
            {
              "type": "text",
              "value": ", whereas in previous NumPy versions the results were undefined."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Ufunc behavior for overlapping inputs",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Extensions that incorporate Fortran libraries can now be built using the free "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "MinGW_"
            },
            {
              "type": "text",
              "value": " toolset, also under Python 3.5. This works best for extensions that only do calculations and uses the runtime modestly (reading and writing from files, for instance). Note that this does not remove the need for Mingwpy; if you make extensive use of the runtime, you will most likely run into "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "issues_"
            },
            {
              "type": "text",
              "value": ". Instead, it should be regarded as a band-aid until Mingwpy is fully functional."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Extensions can also be compiled using the MinGW toolset using the runtime library from the (moveable) WinPython 3.4 distribution, which can be useful for programs with a PySide1/Qt4 front-end."
            }
          ],
          "type": "paragraph"
        },
        {
          "placeholder": "target",
          "type": "Unimplemented",
          "value": ".. _MinGW: https://sf.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/6.2.0/threads-win32/seh/"
        },
        {
          "placeholder": "target",
          "type": "Unimplemented",
          "value": ".. _issues: https://mingwpy.github.io/issues.html"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Partial support for 64-bit f2py extensions with MinGW",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The functions "
            },
            {
              "type": "inlineCode",
              "value": "numpy.packbits"
            },
            {
              "type": "text",
              "value": " with boolean input and "
            },
            {
              "type": "inlineCode",
              "value": "numpy.unpackbits"
            },
            {
              "type": "text",
              "value": " have been optimized to be a significantly faster for contiguous data."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Performance improvements for ``packbits`` and ``unpackbits``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "In previous versions of NumPy, the "
            },
            {
              "type": "inlineCode",
              "value": "finfo"
            },
            {
              "type": "text",
              "value": " function returned invalid information about the "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "double double"
            },
            {
              "type": "text",
              "value": " format of the "
            },
            {
              "type": "inlineCode",
              "value": "longdouble"
            },
            {
              "type": "text",
              "value": " float type on Power PC (PPC).  The invalid values resulted from the failure of the NumPy algorithm to deal with the variable number of digits in the significand that are a feature of "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "PPC long doubles"
            },
            {
              "type": "text",
              "value": ".  This release by-passes the failing algorithm by using heuristics to detect the presence of the PPC double double format.  A side-effect of using these heuristics is that the "
            },
            {
              "type": "inlineCode",
              "value": "finfo"
            },
            {
              "type": "text",
              "value": " function is faster than previous releases."
            }
          ],
          "type": "paragraph"
        },
        {
          "placeholder": "target",
          "type": "Unimplemented",
          "value": ".. _PPC long doubles: https://www.ibm.com/support/knowledgecenter/en/ssw_aix_71/com.ibm.aix.genprogc/128bit_long_double_floating-point_datatype.htm"
        },
        {
          "placeholder": "target",
          "type": "Unimplemented",
          "value": ".. _double double: https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format#Double-double_arithmetic"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Fix for PPC long double floating point information",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Subclasses of ndarray with no "
            },
            {
              "type": "inlineCode",
              "value": "repr"
            },
            {
              "type": "text",
              "value": " specialization now correctly indent their data and type lines."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Better default repr for ``ndarray`` subclasses",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Comparisons of masked arrays were buggy for masked scalars and failed for structured arrays with dimension higher than one. Both problems are now solved. In the process, it was ensured that in getting the result for a structured array, masked fields are properly ignored, i.e., the result is equal if all fields that are non-masked in both are equal, thus making the behaviour identical to what one gets by comparing an unstructured masked array and then doing "
            },
            {
              "type": "inlineCode",
              "value": ".all()"
            },
            {
              "type": "text",
              "value": " over some axis."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "More reliable comparisons of masked arrays",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "np.matrix"
            },
            {
              "type": "text",
              "value": " failed whenever one attempts to use it with booleans, e.g., "
            },
            {
              "type": "inlineCode",
              "value": "np.matrix('True')"
            },
            {
              "type": "text",
              "value": ". Now, this works as expected."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "np.matrix with booleans elements can now be created using the string syntax",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "All of the following functions in "
            },
            {
              "type": "inlineCode",
              "value": "np.linalg"
            },
            {
              "type": "text",
              "value": " now work when given input arrays with a 0 in the last two dimensions: "
            },
            {
              "type": "inlineCode",
              "value": "det"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "slogdet"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "pinv"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "eigvals"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "eigvalsh"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "eig"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "eigh"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "More ``linalg`` operations now accept empty vectors and matrices",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "NumPy comes bundled with a minimal implementation of lapack for systems without a lapack library installed, under the name of "
            },
            {
              "type": "inlineCode",
              "value": "lapack_lite"
            },
            {
              "type": "text",
              "value": ". This has been upgraded from LAPACK 3.0.0 (June 30, 1999) to LAPACK 3.2.2 (June 30, 2010). See the "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "LAPACK changelogs"
            },
            {
              "type": "text",
              "value": " for details on the all the changes this entails."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "While no new features are exposed through "
            },
            {
              "type": "inlineCode",
              "value": "numpy"
            },
            {
              "type": "text",
              "value": ", this fixes some bugs regarding \"workspace\" sizes, and in some places may use faster algorithms."
            }
          ],
          "type": "paragraph"
        },
        {
          "placeholder": "target",
          "type": "Unimplemented",
          "value": ".. _`LAPACK changelogs`: http://www.netlib.org/lapack/release_notes.html#_4_history_of_lapack_releases"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Bundled version of LAPACK is now 3.2.2",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "This now works on empty arrays, returning 0, and can reduce over multiple axes. Previously, a "
            },
            {
              "type": "inlineCode",
              "value": "ValueError"
            },
            {
              "type": "text",
              "value": " was thrown in these cases."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``reduce`` of ``np.hypot.reduce`` and ``np.logical_xor`` allowed in more cases",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Object arrays that contain themselves no longer cause a recursion error."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Object arrays that contain "
            },
            {
              "type": "inlineCode",
              "value": "list"
            },
            {
              "type": "text",
              "value": " objects are now printed in a way that makes clear the difference between a 2d object array, and a 1d object array of lists."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Better ``repr`` of object arrays",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "Changes",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "By default, "
            },
            {
              "type": "inlineCode",
              "value": "argsort"
            },
            {
              "type": "text",
              "value": " now places the masked values at the end of the sorted array, in the same way that "
            },
            {
              "type": "inlineCode",
              "value": "sort"
            },
            {
              "type": "text",
              "value": " already did. Additionally, the "
            },
            {
              "type": "inlineCode",
              "value": "end_with"
            },
            {
              "type": "text",
              "value": " argument is added to "
            },
            {
              "type": "inlineCode",
              "value": "argsort"
            },
            {
              "type": "text",
              "value": ", for consistency with "
            },
            {
              "type": "inlineCode",
              "value": "sort"
            },
            {
              "type": "text",
              "value": ". Note that this argument is not added at the end, so breaks any code that passed "
            },
            {
              "type": "inlineCode",
              "value": "fill_value"
            },
            {
              "type": "text",
              "value": " as a positional argument."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``argsort`` on masked arrays takes the same default arguments as ``sort``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "For ndarray subclasses, "
            },
            {
              "type": "inlineCode",
              "value": "numpy.average"
            },
            {
              "type": "text",
              "value": " will now return an instance of the subclass, matching the behavior of most other NumPy functions such as "
            },
            {
              "type": "inlineCode",
              "value": "mean"
            },
            {
              "type": "text",
              "value": ". As a consequence, also calls that returned a scalar may now return a subclass array scalar."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``average`` now preserves subclasses",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Previously these operations returned scalars "
            },
            {
              "type": "inlineCode",
              "value": "False"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "True"
            },
            {
              "type": "text",
              "value": " respectively."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``array == None`` and ``array != None`` do element-wise comparison",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Previously, these functions always treated identical objects as equal. This had the effect of overriding comparison failures, comparison of objects that did not return booleans, such as np.arrays, and comparison of objects where the results differed from object identity, such as NaNs."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``np.equal, np.not_equal`` for object arrays ignores object identity",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Boolean array-likes (such as lists of python bools) are always treated as   boolean indexes."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Boolean scalars (including python "
                    },
                    {
                      "type": "inlineCode",
                      "value": "True"
                    },
                    {
                      "type": "text",
                      "value": ") are legal boolean indexes and   never treated as integers."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Boolean indexes must match the dimension of the axis that they index."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Boolean indexes used on the lhs of an assignment must match the dimensions of   the rhs."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Boolean indexing into scalar arrays return a new 1-d array.  This means that   "
                    },
                    {
                      "type": "inlineCode",
                      "value": "array(1)[array(True)]"
                    },
                    {
                      "type": "text",
                      "value": " gives "
                    },
                    {
                      "type": "inlineCode",
                      "value": "array([1])"
                    },
                    {
                      "type": "text",
                      "value": " and not the original array."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Boolean indexing changes",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "It is now possible to adjust the behavior the function will have when dealing with the covariance matrix by using two new keyword arguments:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "tol"
                    },
                    {
                      "type": "text",
                      "value": " can be used to specify a tolerance to use when checking that   the covariance matrix is positive semidefinite."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "check_valid"
                    },
                    {
                      "type": "text",
                      "value": " can be used to configure what the function will do in the   presence of a matrix that is not positive semidefinite. Valid options are   "
                    },
                    {
                      "type": "inlineCode",
                      "value": "ignore"
                    },
                    {
                      "type": "text",
                      "value": ", "
                    },
                    {
                      "type": "inlineCode",
                      "value": "warn"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "type": "inlineCode",
                      "value": "raise"
                    },
                    {
                      "type": "text",
                      "value": ". The default value, "
                    },
                    {
                      "type": "inlineCode",
                      "value": "warn"
                    },
                    {
                      "type": "text",
                      "value": " keeps the   the behavior used on previous releases."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``np.random.multivariate_normal`` behavior with bad covariance matrix",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Previously, "
            },
            {
              "type": "inlineCode",
              "value": "np.testing.assert_array_less"
            },
            {
              "type": "text",
              "value": " ignored all infinite values. This is not the expected behavior both according to documentation and intuitively. Now, -inf < x < inf is considered "
            },
            {
              "type": "inlineCode",
              "value": "True"
            },
            {
              "type": "text",
              "value": " for any real number x and all other cases fail."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``assert_array_less`` compares ``np.inf`` and ``-np.inf`` now",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Some warnings that were previously hidden by the "
            },
            {
              "type": "inlineCode",
              "value": "assert_array_"
            },
            {
              "type": "text",
              "value": " functions are not hidden anymore. In most cases the warnings should be correct and, should they occur, will require changes to the tests using these functions. For the masked array "
            },
            {
              "type": "inlineCode",
              "value": "assert_equal"
            },
            {
              "type": "text",
              "value": " version, warnings may occur when comparing NaT. The function presently does not handle NaT or NaN specifically and it may be best to avoid it at this time should a warning show up due to this change."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``assert_array_`` and masked arrays ``assert_equal`` hide less warnings",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The "
            },
            {
              "type": "inlineCode",
              "value": "offset"
            },
            {
              "type": "text",
              "value": " attribute in a "
            },
            {
              "type": "inlineCode",
              "value": "memmap"
            },
            {
              "type": "text",
              "value": " object is now set to the offset into the file. This is a behaviour change only for offsets greater than "
            },
            {
              "type": "inlineCode",
              "value": "mmap.ALLOCATIONGRANULARITY"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``offset`` attribute value in ``memmap`` objects",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Previously, "
            },
            {
              "type": "inlineCode",
              "value": "np.real"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "np.imag"
            },
            {
              "type": "text",
              "value": " used to return array objects when provided a scalar input, which was inconsistent with other functions like "
            },
            {
              "type": "inlineCode",
              "value": "np.angle"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "np.conj"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``np.real`` and ``np.imag`` return scalars for scalar inputs",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The ABCPolyBase class, from which the convenience classes are derived, sets "
            },
            {
              "type": "inlineCode",
              "value": "__array_ufun__ = None"
            },
            {
              "type": "text",
              "value": " in order of opt out of ufuncs. If a polynomial convenience class instance is passed as an argument to a ufunc, a "
            },
            {
              "type": "inlineCode",
              "value": "TypeError"
            },
            {
              "type": "text",
              "value": " will now be raised."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "The polynomial convenience classes cannot be passed to ufuncs",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "For calls to ufuncs, it was already possible, and recommended, to use an "
            },
            {
              "type": "inlineCode",
              "value": "out"
            },
            {
              "type": "text",
              "value": " argument with a tuple for ufuncs with multiple outputs. This has now been extended to output arguments in the "
            },
            {
              "type": "inlineCode",
              "value": "reduce"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "accumulate"
            },
            {
              "type": "text",
              "value": ", and "
            },
            {
              "type": "inlineCode",
              "value": "reduceat"
            },
            {
              "type": "text",
              "value": " methods. This is mostly for compatibility with "
            },
            {
              "type": "inlineCode",
              "value": "__array_ufunc"
            },
            {
              "type": "text",
              "value": "; there are no ufuncs yet that have more than one output."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Output arguments to ufuncs can be tuples also for ufunc methods",
      "type": "Section"
    }
  ],
  "content": {},
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null,
    "type": "Section"
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "see_also": [],
  "signature": {
    "type": "Signature",
    "value": null
  },
  "type": "DocBlob"
}