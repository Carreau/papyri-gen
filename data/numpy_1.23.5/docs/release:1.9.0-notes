{
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "This release supports Python 2.6 - 2.7 and 3.2 - 3.4."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": "NumPy 1.9.0 Release Notes",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Numerous performance improvements in various areas, most notably indexing and   operations on small arrays are significantly faster.   Indexing operations now also release the GIL."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Addition of "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "nanmedian"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "nanpercentile"
                    },
                    {
                      "type": "text",
                      "value": " rounds out the nanfunction set."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Highlights",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The oldnumeric and numarray modules have been removed."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The doc/pyrex and doc/cython directories have been removed."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The doc/numpybook directory has been removed."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The numpy/testing/numpytest.py file has been removed together with   the importall function it contained."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Dropped Support",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The numpy/polynomial/polytemplate.py file will be removed in NumPy 1.10.0."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Default casting for inplace operations will change to 'same_kind' in   Numpy 1.10.0. This will certainly break some code that is currently   ignoring the warning."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Relaxed stride checking will be the default in 1.10.0"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "String version checks will break because, e.g., '1.9' > '1.10' is True. A   NumpyVersion class has been added that can be used for such comparisons."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The diagonal and diag functions will return writeable views in 1.10.0"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "S"
                    },
                    {
                      "type": "text",
                      "value": " and/or "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "a"
                    },
                    {
                      "type": "text",
                      "value": " dtypes may be changed to represent Python strings   instead of bytes, in Python 3 these two types are very different."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Future Changes",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "Compatibility notes",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "In NumPy 1.8, the diagonal and diag functions returned readonly copies, in NumPy 1.9 they return readonly views, and in 1.10 they will return writeable views."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "The diagonal and diag functions return readonly views.",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "In previous numpy versions operations involving floating point scalars containing special values "
            },
            {
              "type": "inlineCode",
              "value": "NaN"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "Inf"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "-Inf"
            },
            {
              "type": "text",
              "value": " caused the result type to be at least "
            },
            {
              "type": "inlineCode",
              "value": "float64"
            },
            {
              "type": "text",
              "value": ".  As the special values can be represented in the smallest available floating point type, the upcast is not performed anymore."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "For example the dtype of:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "inlineCode",
                  "value": "np.array([1.], dtype=np.float32) * float('nan')"
                }
              ],
              "type": "paragraph"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "now remains "
            },
            {
              "type": "inlineCode",
              "value": "float32"
            },
            {
              "type": "text",
              "value": " instead of being cast to "
            },
            {
              "type": "inlineCode",
              "value": "float64"
            },
            {
              "type": "text",
              "value": ". Operations involving non-special values have not been changed."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Special scalar float values don't cause upcast to double anymore",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "If given more than one percentile to compute numpy.percentile returns an array instead of a list. A single percentile still returns a scalar.  The array is equivalent to converting the list returned in older versions to an array via "
            },
            {
              "type": "inlineCode",
              "value": "np.array"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "If the "
            },
            {
              "type": "inlineCode",
              "value": "overwrite_input"
            },
            {
              "type": "text",
              "value": " option is used the input is only partially instead of fully sorted."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Percentile output changes",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "All "
            },
            {
              "type": "inlineCode",
              "value": "tofile"
            },
            {
              "type": "text",
              "value": " exceptions are now "
            },
            {
              "type": "inlineCode",
              "value": "IOError"
            },
            {
              "type": "text",
              "value": ", some were previously "
            },
            {
              "type": "inlineCode",
              "value": "ValueError"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "ndarray.tofile exception type",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Two changes to numpy.ma.core._check_fill_value:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "When the fill value is a string and the array type is not one of   'OSUV', TypeError is raised instead of the default fill value being used."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "When the fill value overflows the array type, TypeError is raised instead   of OverflowError."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Invalid fill value exceptions",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "This may cause problems with folks who depended on the polynomial classes being derived from PolyBase. They are now all derived from the abstract base class ABCPolyBase. Strictly speaking, there should be a deprecation involved, but no external code making use of the old baseclass could be found."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Polynomial Classes no longer derived from PolyBase",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "A bug in one of the algorithms to generate a binomial random variate has been fixed. This change will likely alter the number of random draws performed, and hence the sequence location will be different after a call to distribution.crk_binomial_btpe. Any tests which rely on the RNG being in a known state should be checked and/or updated as a result."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Using numpy.random.binomial may change the RNG state vs. numpy < 1.9",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "np.random.seed"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "np.random.RandomState"
            },
            {
              "type": "text",
              "value": " now throw a "
            },
            {
              "type": "inlineCode",
              "value": "ValueError"
            },
            {
              "type": "text",
              "value": " if the seed cannot safely be converted to 32 bit unsigned integers. Applications that now fail can be fixed by masking the higher 32 bit values to zero: "
            },
            {
              "type": "inlineCode",
              "value": "seed = seed & 0xFFFFFFFF"
            },
            {
              "type": "text",
              "value": ". This is what is done silently in older versions so the random stream remains the same."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Random seed enforced to be a 32 bit unsigned integer",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The "
            },
            {
              "type": "inlineCode",
              "value": "out"
            },
            {
              "type": "text",
              "value": " argument to "
            },
            {
              "type": "inlineCode",
              "value": "np.argmin"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "np.argmax"
            },
            {
              "type": "text",
              "value": " and their equivalent C-API functions is now checked to match the desired output shape exactly.  If the check fails a "
            },
            {
              "type": "inlineCode",
              "value": "ValueError"
            },
            {
              "type": "text",
              "value": " instead of "
            },
            {
              "type": "inlineCode",
              "value": "TypeError"
            },
            {
              "type": "text",
              "value": " is raised."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Argmin and argmax out argument",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Remove unnecessary broadcasting notation restrictions. "
            },
            {
              "type": "inlineCode",
              "value": "np.einsum('ijk,j->ijk', A, B)"
            },
            {
              "type": "text",
              "value": " can also be written as "
            },
            {
              "type": "inlineCode",
              "value": "np.einsum('ij...,j->ij...', A, B)"
            },
            {
              "type": "text",
              "value": " (ellipsis is no longer required on 'j')"
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Einsum",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The NumPy indexing has seen a complete rewrite in this version. This makes most advanced integer indexing operations much faster and should have no other implications.  However some subtle changes and deprecations were introduced in advanced indexing operations:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Boolean indexing into scalar arrays will always return a new 1-d array.   This means that "
                    },
                    {
                      "type": "inlineCode",
                      "value": "array(1)[array(True)]"
                    },
                    {
                      "type": "text",
                      "value": " gives "
                    },
                    {
                      "type": "inlineCode",
                      "value": "array([1])"
                    },
                    {
                      "type": "text",
                      "value": " and   not the original array."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Advanced indexing into one dimensional arrays used to have   (undocumented) special handling regarding repeating the value array in   assignments when the shape of the value array was too small or did not   match.  Code using this will raise an error. For compatibility you can   use "
                    },
                    {
                      "type": "inlineCode",
                      "value": "arr.flat[index] = values"
                    },
                    {
                      "type": "text",
                      "value": ", which uses the old code branch.  (for   example "
                    },
                    {
                      "type": "inlineCode",
                      "value": "a = np.ones(10); a[np.arange(10)] = [1, 2, 3]"
                    },
                    {
                      "type": "text",
                      "value": ")"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The iteration order over advanced indexes used to be always C-order.   In NumPy 1.9. the iteration order adapts to the inputs and is not   guaranteed (with the exception of a "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "single"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " advanced index which is   never reversed for compatibility reasons). This means that the result   is undefined if multiple values are assigned to the same element.  An   example for this is "
                    },
                    {
                      "type": "inlineCode",
                      "value": "arr[[0, 0], [1, 1]] = [1, 2]"
                    },
                    {
                      "type": "text",
                      "value": ", which may set   "
                    },
                    {
                      "type": "inlineCode",
                      "value": "arr[0, 1]"
                    },
                    {
                      "type": "text",
                      "value": " to either 1 or 2."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Equivalent to the iteration order, the memory layout of the advanced   indexing result is adapted for faster indexing and cannot be predicted."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "All indexing operations return a view or a copy. No indexing operation   will return the original array object. (For example "
                    },
                    {
                      "type": "inlineCode",
                      "value": "arr[...]"
                    },
                    {
                      "type": "text",
                      "value": ")"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "In the future Boolean array-likes (such as lists of python bools) will   always be treated as Boolean indexes and Boolean scalars (including   python "
                    },
                    {
                      "type": "inlineCode",
                      "value": "True"
                    },
                    {
                      "type": "text",
                      "value": ") will be a legal "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "boolean"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " index. At this time, this is   already the case for scalar arrays to allow the general   "
                    },
                    {
                      "type": "inlineCode",
                      "value": "positive = a[a > 0]"
                    },
                    {
                      "type": "text",
                      "value": " to work when "
                    },
                    {
                      "type": "inlineCode",
                      "value": "a"
                    },
                    {
                      "type": "text",
                      "value": " is zero dimensional."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "In NumPy 1.8 it was possible to use "
                    },
                    {
                      "type": "inlineCode",
                      "value": "array(True)"
                    },
                    {
                      "type": "text",
                      "value": " and   "
                    },
                    {
                      "type": "inlineCode",
                      "value": "array(False)"
                    },
                    {
                      "type": "text",
                      "value": " equivalent to 1 and 0 if the result of the operation   was a scalar.  This will raise an error in NumPy 1.9 and, as noted   above, treated as a boolean index in the future."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "All non-integer array-likes are deprecated, object arrays of custom   integer like objects may have to be cast explicitly."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The error reporting for advanced indexing is more informative, however   the error type has changed in some cases. (Broadcasting errors of   indexing arrays are reported as "
                    },
                    {
                      "type": "inlineCode",
                      "value": "IndexError"
                    },
                    {
                      "type": "text",
                      "value": ")"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Indexing with more then one ellipsis ("
                    },
                    {
                      "type": "inlineCode",
                      "value": "..."
                    },
                    {
                      "type": "text",
                      "value": ") is deprecated."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Indexing",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Non-integer axis indexes to reduction ufuncs like "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "add.reduce"
            },
            {
              "type": "text",
              "value": " or "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "sum"
            },
            {
              "type": "text",
              "value": " are deprecated."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Non-integer reduction axis indexes are deprecated",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "promote_types"
            },
            {
              "type": "text",
              "value": " function now returns a valid string length when given an integer or float dtype as one argument and a string dtype as another argument.  Previously it always returned the input string dtype, even if it wasn't long enough to store the max integer/float value converted to a string."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``promote_types`` and string dtype",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "can_cast"
            },
            {
              "type": "text",
              "value": " function now returns False in \"safe\" casting mode for integer/float dtype and string dtype if the string dtype length is not long enough to store the max integer/float value converted to a string. Previously "
            },
            {
              "type": "inlineCode",
              "value": "can_cast"
            },
            {
              "type": "text",
              "value": " in \"safe\" mode returned True for integer/float dtype and a string dtype of any length."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``can_cast`` and string dtype",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The "
            },
            {
              "type": "inlineCode",
              "value": "astype"
            },
            {
              "type": "text",
              "value": " method now returns an error if the string dtype to cast to is not long enough in \"safe\" casting mode to hold the max value of integer/float array that is being casted. Previously the casting was allowed even if the result was truncated."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "astype and string dtype",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "npyio.recfromcsv"
            },
            {
              "type": "text",
              "value": " no longer accepts the undocumented "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "update"
            },
            {
              "type": "text",
              "value": " keyword, which used to override the "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "dtype"
            },
            {
              "type": "text",
              "value": " keyword."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "`npyio.recfromcsv` keyword arguments change",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The "
            },
            {
              "type": "inlineCode",
              "value": "doc/swig"
            },
            {
              "type": "text",
              "value": " directory has been moved to "
            },
            {
              "type": "inlineCode",
              "value": "tools/swig"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "The ``doc/swig`` directory moved",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The unused "
            },
            {
              "type": "inlineCode",
              "value": "simple_capsule_dtor"
            },
            {
              "type": "text",
              "value": " function has been removed from "
            },
            {
              "type": "inlineCode",
              "value": "npy_3kcompat.h"
            },
            {
              "type": "text",
              "value": ".  Note that this header is not meant to be used outside of numpy; other projects should be using their own copy of this file when needed."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "The ``npy_3kcompat.h`` header changed",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "When directly accessing the "
            },
            {
              "type": "inlineCode",
              "value": "sq_item"
            },
            {
              "type": "text",
              "value": " or "
            },
            {
              "type": "inlineCode",
              "value": "sq_ass_item"
            },
            {
              "type": "text",
              "value": " PyObject slots for item getting, negative indices will not be supported anymore. "
            },
            {
              "type": "inlineCode",
              "value": "PySequence_GetItem"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "PySequence_SetItem"
            },
            {
              "type": "text",
              "value": " however fix negative indices so that they can be used there."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Negative indices in C-Api ``sq_item`` and ``sq_ass_item`` sequence methods",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "When "
            },
            {
              "type": "inlineCode",
              "value": "NpyIter_RemoveAxis"
            },
            {
              "type": "text",
              "value": " is now called, the iterator range will be reset."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "When a multi index is being tracked and an iterator is not buffered, it is possible to use "
            },
            {
              "type": "inlineCode",
              "value": "NpyIter_RemoveAxis"
            },
            {
              "type": "text",
              "value": ". In this case an iterator can shrink in size. Because the total size of an iterator is limited, the iterator may be too large before these calls. In this case its size will be set to "
            },
            {
              "type": "inlineCode",
              "value": "-1"
            },
            {
              "type": "text",
              "value": " and an error issued not at construction time but when removing the multi index, setting the iterator range, or getting the next function."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This has no effect on currently working code, but highlights the necessity of checking for an error return if these conditions can occur. In most cases the arrays being iterated are as large as the iterator so that such a problem cannot occur."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This change was already applied to the 1.8.1 release."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "NDIter",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "To match the "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "zeros"
            },
            {
              "type": "text",
              "value": " function "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "zeros_like"
            },
            {
              "type": "text",
              "value": " now returns an array initialized with empty strings instead of an array filled with "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "'0'"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``zeros_like`` for string dtypes now returns empty strings",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "New Features",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "np.percentile"
            },
            {
              "type": "text",
              "value": " now has the interpolation keyword argument to specify in which way points should be interpolated if the percentiles fall between two values.  See the documentation for the available options."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Percentile supports more interpolation options",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "np.median"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "np.percentile"
            },
            {
              "type": "text",
              "value": " now support generalized axis arguments like ufunc reductions do since 1.7. One can now say axis=(index, index) to pick a list of axes for the reduction. The "
            },
            {
              "type": "inlineCode",
              "value": "keepdims"
            },
            {
              "type": "text",
              "value": " keyword argument was also added to allow convenient broadcasting to arrays of the original shape."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Generalized axis support for median and percentile",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The returned data type from the "
            },
            {
              "type": "inlineCode",
              "value": "linspace"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "logspace"
            },
            {
              "type": "text",
              "value": " functions can now be specified using the dtype parameter."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Dtype parameter added to ``np.linspace`` and ``np.logspace``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "For arrays with "
            },
            {
              "type": "inlineCode",
              "value": "ndim"
            },
            {
              "type": "text",
              "value": " exceeding 2, these functions will now apply to the final two axes instead of raising an exception."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "More general ``np.triu`` and ``np.tril`` broadcasting",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "ndarray.tobytes"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "MaskedArray.tobytes"
            },
            {
              "type": "text",
              "value": " have been added as aliases for "
            },
            {
              "type": "inlineCode",
              "value": "tostring"
            },
            {
              "type": "text",
              "value": " which exports arrays as "
            },
            {
              "type": "inlineCode",
              "value": "bytes"
            },
            {
              "type": "text",
              "value": ". This is more consistent in Python 3 where "
            },
            {
              "type": "inlineCode",
              "value": "str"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "bytes"
            },
            {
              "type": "text",
              "value": " are not the same."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``tobytes`` alias for ``tostring`` method",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Added experimental support for the ppc64le and OpenRISC architecture."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Build system",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "All numerical numpy types are now registered with the type hierarchy in the python "
            },
            {
              "type": "inlineCode",
              "value": "numbers"
            },
            {
              "type": "text",
              "value": " module."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Compatibility to python ``numbers`` module",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The ordering of the columns of the Vandermonde matrix can be specified with this new boolean argument."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``increasing`` parameter added to ``np.vander``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The number of times each unique item comes up in the input can now be obtained as an optional return value."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``unique_counts`` parameter added to ``np.unique``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The "
            },
            {
              "type": "inlineCode",
              "value": "np.nanmedian"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "np.nanpercentile"
            },
            {
              "type": "text",
              "value": " functions behave like the median and percentile functions except that NaNs are ignored."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Support for median and percentile in nanfunctions",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The class may be imported from numpy.lib and can be used for version comparison when the numpy version goes to 1.10.devel. For example      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> from numpy.lib import NumpyVersion\n>>> if NumpyVersion(np.__version__) < '1.10.0'):\n...     print('Wow, that is an old NumPy version!')"
        }
      ],
      "level": 2,
      "target": null,
      "title": "NumpyVersion class added",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The numpy storage format 1.0 only allowed the array header to have a total size of 65535 bytes. This can be exceeded by structured arrays with a large number of columns. A new format 2.0 has been added which extends the header size to 4 GiB. "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "np.save"
            },
            {
              "type": "text",
              "value": " will automatically save in 2.0 format if the data requires it, else it will always use the more compatible 1.0 format."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Allow saving arrays with large number of named columns",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "np.cross"
            },
            {
              "type": "text",
              "value": " now properly broadcasts its two input arrays, even if they have different number of dimensions. In earlier versions this would result in either an error being raised, or wrong results computed."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Full broadcasting support for ``np.cross``",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "Improvements",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Pairwise summation is now used in the sum method, but only along the fast axis and for groups of the values <= 8192 in length. This should also improve the accuracy of var and std in some common cases."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Better numerical stability for sum in some cases",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "np.percentile"
            },
            {
              "type": "text",
              "value": " has been implemented in terms of "
            },
            {
              "type": "inlineCode",
              "value": "np.partition"
            },
            {
              "type": "text",
              "value": " which only partially sorts the data via a selection algorithm. This improves the time complexity from "
            },
            {
              "type": "inlineCode",
              "value": "O(nlog(n))"
            },
            {
              "type": "text",
              "value": " to "
            },
            {
              "type": "inlineCode",
              "value": "O(n)"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Percentile implemented in terms of ``np.partition``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The performance of converting lists containing arrays to arrays using "
            },
            {
              "type": "inlineCode",
              "value": "np.array"
            },
            {
              "type": "text",
              "value": " has been improved. It is now equivalent in speed to "
            },
            {
              "type": "inlineCode",
              "value": "np.vstack(list)"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Performance improvement for ``np.array``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "For the built-in numeric types, "
            },
            {
              "type": "inlineCode",
              "value": "np.searchsorted"
            },
            {
              "type": "text",
              "value": " no longer relies on the data type's "
            },
            {
              "type": "inlineCode",
              "value": "compare"
            },
            {
              "type": "text",
              "value": " function to perform the search, but is now implemented by type specific functions. Depending on the size of the inputs, this can result in performance improvements over 2x."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Performance improvement for ``np.searchsorted``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Set "
            },
            {
              "type": "inlineCode",
              "value": "numpy.distutils.system_info.system_info.verbosity = 0"
            },
            {
              "type": "text",
              "value": " and then calls to "
            },
            {
              "type": "inlineCode",
              "value": "numpy.distutils.system_info.get_info('blas_opt')"
            },
            {
              "type": "text",
              "value": " will not print anything on the output. This is mostly for other packages using numpy.distutils."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Optional reduced verbosity for np.distutils",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "A "
            },
            {
              "type": "inlineCode",
              "value": "RuntimeWarning"
            },
            {
              "type": "text",
              "value": " warning is raised when the covariance matrix is not positive-semidefinite."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Covariance check in ``np.random.multivariate_normal``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The polynomial classes have been refactored to use an abstract base class rather than a template in order to implement a common interface. This makes importing the polynomial package faster as the classes do not need to be compiled on import."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Polynomial Classes no longer template based",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Several more functions now release the Global Interpreter Lock allowing more efficient parallelization using the "
            },
            {
              "type": "inlineCode",
              "value": "threading"
            },
            {
              "type": "text",
              "value": " module. Most notably the GIL is now released for fancy indexing, "
            },
            {
              "type": "inlineCode",
              "value": "np.where"
            },
            {
              "type": "text",
              "value": " and the "
            },
            {
              "type": "inlineCode",
              "value": "random"
            },
            {
              "type": "text",
              "value": " module now uses a per-state lock instead of the GIL."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "More GIL releases",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Built-in assumptions that the baseclass behaved like a plain array are being removed. In particular, "
            },
            {
              "type": "inlineCode",
              "value": "repr"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "str"
            },
            {
              "type": "text",
              "value": " should now work more reliably."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "MaskedArray support for more complicated base classes",
      "type": "Section"
    },
    {
      "children": [],
      "level": 2,
      "target": null,
      "title": "C-API",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "Deprecations",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Using non-integer numpy scalars to repeat python sequences is deprecated. For example "
            },
            {
              "type": "inlineCode",
              "value": "np.float_(2) * [1]"
            },
            {
              "type": "text",
              "value": " will be an error in the future."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Non-integer scalars for sequence repetition",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The integer and empty input to "
            },
            {
              "type": "inlineCode",
              "value": "select"
            },
            {
              "type": "text",
              "value": " is deprecated. In the future only boolean arrays will be valid conditions and an empty "
            },
            {
              "type": "inlineCode",
              "value": "condlist"
            },
            {
              "type": "text",
              "value": " will be considered an input error instead of returning the default."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``select`` input deprecations",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The "
            },
            {
              "type": "inlineCode",
              "value": "rank"
            },
            {
              "type": "text",
              "value": " function has been deprecated to avoid confusion with "
            },
            {
              "type": "inlineCode",
              "value": "numpy.linalg.matrix_rank"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``rank`` function",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "In the future object array comparisons both "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "=="
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "np.equal"
            },
            {
              "type": "text",
              "value": " will not make use of identity checks anymore. For example:"
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> a = np.array([np.array([1, 2, 3]), 1])\n>>> b = np.array([np.array([1, 2, 3]), 1])\n>>> a == b"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "will consistently return False (and in the future an error) even if the array in "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "a"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "b"
            },
            {
              "type": "text",
              "value": " was the same object."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The equality operator "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "=="
            },
            {
              "type": "text",
              "value": " will in the future raise errors like "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "np.equal"
            },
            {
              "type": "text",
              "value": " if broadcasting or element comparisons, etc. fails."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Comparison with "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "arr == None"
            },
            {
              "type": "text",
              "value": " will in the future do an elementwise comparison instead of just returning False. Code should be using "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "arr is None"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "All of these changes will give Deprecation- or FutureWarnings at this time."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Object array equality comparisons",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The utility function npy_PyFile_Dup and npy_PyFile_DupClose are broken by the internal buffering python 3 applies to its file objects. To fix this two new functions npy_PyFile_Dup2 and npy_PyFile_DupClose2 are declared in npy_3kcompat.h and the old functions are deprecated. Due to the fragile nature of these functions it is recommended to instead use the python API when possible."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This change was already applied to the 1.8.1 release."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "C-API",
      "type": "Section"
    }
  ],
  "content": {},
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null,
    "type": "Section"
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "see_also": [],
  "signature": {
    "type": "Signature",
    "value": null
  },
  "type": "DocBlob"
}