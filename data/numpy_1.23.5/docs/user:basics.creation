{
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "args": ":ref:`Array creation routines <routines.array-creation>`",
          "children": [],
          "name": "seealso",
          "options": {},
          "type": "mystDirective",
          "value": ""
        }
      ],
      "level": 0,
      "target": "arrays.creation",
      "title": "Array creation",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "There are 6 general mechanisms for creating arrays:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Conversion from other Python structures (i.e. lists and tuples)"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Intrinsic NumPy array creation functions (e.g. arange, ones, zeros,    etc.)"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Replicating, joining, or mutating existing arrays"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Reading arrays from disk, either from standard or custom formats"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Creating arrays from raw bytes through the use of strings or buffers"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Use of special library functions (e.g., random)"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": true,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "You can use these methods to create ndarrays or "
            },
            {
              "type": "inlineCode",
              "value": "structured_arrays"
            },
            {
              "type": "text",
              "value": ". This document will cover general methods for ndarray creation."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Introduction",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "NumPy arrays can be defined using Python sequences such as lists and tuples. Lists and tuples are defined using "
            },
            {
              "type": "inlineCode",
              "value": "[...]"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "(...)"
            },
            {
              "type": "text",
              "value": ", respectively. Lists and tuples can define ndarray creation:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "a list of numbers will create a 1D array,"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "a list of lists will create a 2D array,"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "further nested lists will create higher-dimensional arrays. In general, any array object is called an "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "ndarray"
                        }
                      ],
                      "type": "strong"
                    },
                    {
                      "type": "text",
                      "value": " in NumPy."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "type": "code",
          "value": ">>> a1D = np.array([1, 2, 3, 4])\n>>> a2D = np.array([[1, 2], [3, 4]])\n>>> a3D = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "When you use "
            },
            {
              "type": "inlineCode",
              "value": "numpy.array"
            },
            {
              "type": "text",
              "value": " to define a new array, you should consider the "
            },
            {
              "type": "inlineCode",
              "value": "dtype <basics.types>"
            },
            {
              "type": "text",
              "value": " of the elements in the array, which can be specified explicitly. This feature gives you more control over the underlying data structures and how the elements are handled in C/C++ functions. If you are not careful with "
            },
            {
              "type": "inlineCode",
              "value": "dtype"
            },
            {
              "type": "text",
              "value": " assignments, you can get unwanted overflow, as such"
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> a = np.array([127, 128, 129], dtype=np.int8)\n>>> a\narray([ 127, -128, -127], dtype=int8)"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "An 8-bit signed integer represents integers from -128 to 127. Assigning the "
            },
            {
              "type": "inlineCode",
              "value": "int8"
            },
            {
              "type": "text",
              "value": " array to integers outside of this range results in overflow. This feature can often be misunderstood. If you perform calculations with mismatching "
            },
            {
              "type": "inlineCode",
              "value": "dtypes"
            },
            {
              "type": "text",
              "value": ", you can get unwanted results,  for example      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> a = np.array([2, 3, 4], dtype=np.uint32)\n>>> b = np.array([5, 6, 7], dtype=np.uint32)\n>>> c_unsigned32 = a - b\n>>> print('unsigned c:', c_unsigned32, c_unsigned32.dtype)\nunsigned c: [4294967293 4294967293 4294967293] uint32\n>>> c_signed32 = a - b.astype(np.int32)\n>>> print('signed c:', c_signed32, c_signed32.dtype)\nsigned c: [-3 -3 -3] int64"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Notice when you perform operations with two arrays of the same "
            },
            {
              "type": "inlineCode",
              "value": "dtype"
            },
            {
              "type": "text",
              "value": ": "
            },
            {
              "type": "inlineCode",
              "value": "uint32"
            },
            {
              "type": "text",
              "value": ", the resulting array is the same type. When you perform operations with different "
            },
            {
              "type": "inlineCode",
              "value": "dtype"
            },
            {
              "type": "text",
              "value": ", NumPy will  assign a new type that satisfies all of the array elements involved in the computation, here "
            },
            {
              "type": "inlineCode",
              "value": "uint32"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "int32"
            },
            {
              "type": "text",
              "value": " can both be represented in as "
            },
            {
              "type": "inlineCode",
              "value": "int64"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The default NumPy behavior is to create arrays in either 32 or 64-bit signed integers (platform dependent and matches C "
            },
            {
              "type": "inlineCode",
              "value": "long"
            },
            {
              "type": "text",
              "value": " size) or double precision floating point numbers. If you expect your integer arrays to be a specific type, then you need to specify the dtype while you create the array."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "1) Converting Python sequences to NumPy Arrays",
      "type": "Section"
    },
    {
      "children": [
        {
          "type": "mystComment",
          "value": "..\n  40 functions seems like a small number, but the routies.array-creation\n  has ~47. I'm sure there are more."
        },
        {
          "children": [
            {
              "type": "text",
              "value": "NumPy has over 40 built-in functions for creating arrays as laid out in the "
            },
            {
              "type": "inlineCode",
              "value": "Array creation routines <routines.array-creation>"
            },
            {
              "type": "text",
              "value": ". These functions can be split into roughly three categories, based on the dimension of the array they create:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "1D arrays"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "2D arrays"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "ndarrays"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": true,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 1,
      "target": null,
      "title": "2) Intrinsic NumPy array creation functions",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The 1D array creation functions e.g. "
            },
            {
              "type": "inlineCode",
              "value": "numpy.linspace"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "numpy.arange"
            },
            {
              "type": "text",
              "value": " generally need at least two inputs, "
            },
            {
              "type": "inlineCode",
              "value": "start"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "stop"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "numpy.arange"
            },
            {
              "type": "text",
              "value": " creates arrays with regularly incrementing values. Check the documentation for complete information and examples. A few examples are shown   "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> np.arange(10)\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> np.arange(2, 10, dtype=float)\narray([2., 3., 4., 5., 6., 7., 8., 9.])\n>>> np.arange(2, 3, 0.1)\narray([2. , 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Note: best practice for "
            },
            {
              "type": "inlineCode",
              "value": "numpy.arange"
            },
            {
              "type": "text",
              "value": " is to use integer start, end, and step values. There are some subtleties regarding "
            },
            {
              "type": "inlineCode",
              "value": "dtype"
            },
            {
              "type": "text",
              "value": ". In the second example, the "
            },
            {
              "type": "inlineCode",
              "value": "dtype"
            },
            {
              "type": "text",
              "value": " is defined. In the third example, the array is "
            },
            {
              "type": "inlineCode",
              "value": "dtype=float"
            },
            {
              "type": "text",
              "value": " to accommodate the step size of "
            },
            {
              "type": "inlineCode",
              "value": "0.1"
            },
            {
              "type": "text",
              "value": ". Due to roundoff error, the "
            },
            {
              "type": "inlineCode",
              "value": "stop"
            },
            {
              "type": "text",
              "value": " value is sometimes included."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "numpy.linspace"
            },
            {
              "type": "text",
              "value": " will create arrays with a specified number of elements, and spaced equally between the specified beginning and end values. For example:    "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> np.linspace(1., 4., 6)\narray([1. ,  1.6,  2.2,  2.8,  3.4,  4. ])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The advantage of this creation function is that you guarantee the number of elements and the starting and end point. The previous "
            },
            {
              "type": "inlineCode",
              "value": "arange(start, stop, step)"
            },
            {
              "type": "text",
              "value": " will not include the value "
            },
            {
              "type": "inlineCode",
              "value": "stop"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "1 - 1D array creation functions",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The 2D array creation functions e.g. "
            },
            {
              "type": "inlineCode",
              "value": "numpy.eye"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "numpy.diag"
            },
            {
              "type": "text",
              "value": ", and "
            },
            {
              "type": "inlineCode",
              "value": "numpy.vander"
            },
            {
              "type": "text",
              "value": " define properties of special matrices represented as 2D arrays."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "np.eye(n, m)"
            },
            {
              "type": "text",
              "value": " defines a 2D identity matrix. The elements where i=j (row index and column index are equal) are 1 and the rest are 0, as such   "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> np.eye(3)\narray([[1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.]])\n>>> np.eye(3, 5)\narray([[1., 0., 0., 0., 0.],\n       [0., 1., 0., 0., 0.],\n       [0., 0., 1., 0., 0.]])"
        },
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "numpy.diag"
            },
            {
              "type": "text",
              "value": " can define either a square 2D array with given values along the diagonal "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "or"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " if given a 2D array returns a 1D array that is only the diagonal elements. The two array creation functions can be helpful while doing linear algebra, as such    "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> np.diag([1, 2, 3])\narray([[1, 0, 0],\n       [0, 2, 0],\n       [0, 0, 3]])\n>>> np.diag([1, 2, 3], 1)\narray([[0, 1, 0, 0],\n       [0, 0, 2, 0],\n       [0, 0, 0, 3],\n       [0, 0, 0, 0]])\n>>> a = np.array([[1, 2], [3, 4]])\n>>> np.diag(a)\narray([1, 4])"
        },
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "vander(x, n)"
            },
            {
              "type": "text",
              "value": " defines a Vandermonde matrix as a 2D NumPy array. Each column of the Vandermonde matrix is a decreasing power of the input 1D array or list or tuple, "
            },
            {
              "type": "inlineCode",
              "value": "x"
            },
            {
              "type": "text",
              "value": " where the highest polynomial order is "
            },
            {
              "type": "inlineCode",
              "value": "n-1"
            },
            {
              "type": "text",
              "value": ". This array creation routine is helpful in generating linear least squares models, as such    "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> np.vander(np.linspace(0, 2, 5), 2)\narray([[0. , 1. ],\n      [0.5, 1. ],\n      [1. , 1. ],\n      [1.5, 1. ],\n      [2. , 1. ]])\n>>> np.vander([1, 2, 3, 4], 2)\narray([[1, 1],\n       [2, 1],\n       [3, 1],\n       [4, 1]])\n>>> np.vander((1, 2, 3, 4), 4)\narray([[ 1,  1,  1,  1],\n       [ 8,  4,  2,  1],\n       [27,  9,  3,  1],\n       [64, 16,  4,  1]])"
        }
      ],
      "level": 2,
      "target": null,
      "title": "2 - 2D array creation functions",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The ndarray creation functions e.g. "
            },
            {
              "type": "inlineCode",
              "value": "numpy.ones"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "numpy.zeros"
            },
            {
              "type": "text",
              "value": ", and "
            },
            {
              "type": "inlineCode",
              "value": "~numpy.random.Generator.random"
            },
            {
              "type": "text",
              "value": " define arrays based upon the desired shape.  The  ndarray creation functions can create arrays with any dimension by specifying how many dimensions and length along that dimension in a tuple or list."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "numpy.zeros"
            },
            {
              "type": "text",
              "value": " will create an array filled with 0 values with the specified shape. The default dtype is "
            },
            {
              "type": "inlineCode",
              "value": "float64"
            },
            {
              "type": "text",
              "value": "   "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> np.zeros((2, 3))\narray([[0., 0., 0.], \n       [0., 0., 0.]])\n>>> np.zeros((2, 3, 2))\narray([[[0., 0.],\n        [0., 0.],\n        [0., 0.]],\n<BLANKLINE>        \n       [[0., 0.],\n        [0., 0.],\n        [0., 0.]]])"
        },
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "numpy.ones"
            },
            {
              "type": "text",
              "value": " will create an array filled with 1 values. It is identical to "
            },
            {
              "type": "inlineCode",
              "value": "zeros"
            },
            {
              "type": "text",
              "value": " in all other respects as such   "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> np.ones((2, 3))\narray([[1., 1., 1.], \n       [1., 1., 1.]])\n>>> np.ones((2, 3, 2))\narray([[[1., 1.],\n        [1., 1.],\n        [1., 1.]],\n<BLANKLINE>\n       [[1., 1.],\n        [1., 1.],\n        [1., 1.]]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The "
            },
            {
              "type": "inlineCode",
              "value": "~numpy.random.Generator.random"
            },
            {
              "type": "text",
              "value": " method of the result of "
            },
            {
              "type": "inlineCode",
              "value": "default_rng"
            },
            {
              "type": "text",
              "value": " will create an array filled with random values between 0 and 1. It is included with the "
            },
            {
              "type": "inlineCode",
              "value": "numpy.random"
            },
            {
              "type": "text",
              "value": " library. Below, two arrays are created with shapes (2,3) and (2,3,2), respectively. The seed is set to 42 so you can reproduce these pseudorandom numbers   "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> from numpy.random import default_rng\n>>> default_rng(42).random((2,3))\narray([[0.77395605, 0.43887844, 0.85859792],\n       [0.69736803, 0.09417735, 0.97562235]])\n>>> default_rng(42).random((2,3,2))\narray([[[0.77395605, 0.43887844],\n        [0.85859792, 0.69736803],\n        [0.09417735, 0.97562235]],\n       [[0.7611397 , 0.78606431],\n        [0.12811363, 0.45038594],\n        [0.37079802, 0.92676499]]])"
        },
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "numpy.indices"
            },
            {
              "type": "text",
              "value": " will create a set of arrays (stacked as a one-higher dimensioned array), one per dimension with each representing variation in that dimension:    "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> np.indices((3,3))\narray([[[0, 0, 0], \n        [1, 1, 1], \n        [2, 2, 2]], \n       [[0, 1, 2], \n        [0, 1, 2], \n        [0, 1, 2]]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This is particularly useful for evaluating functions of multiple dimensions on a regular grid."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "3 - general ndarray creation functions",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Once you have created arrays, you can replicate, join, or mutate those existing arrays to create new arrays. When you assign an array or its elements to a new variable, you have to explicitly "
            },
            {
              "type": "inlineCode",
              "value": "numpy.copy"
            },
            {
              "type": "text",
              "value": " the array, otherwise the variable is a view into the original array. Consider the following example   "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> a = np.array([1, 2, 3, 4, 5, 6])\n>>> b = a[:2]\n>>> b += 1\n>>> print('a =', a, '; b =', b)\na = [2 3 3 4 5 6] ; b = [2 3]"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In this example, you did not create a new array. You created a variable, "
            },
            {
              "type": "inlineCode",
              "value": "b"
            },
            {
              "type": "text",
              "value": " that viewed the first 2 elements of "
            },
            {
              "type": "inlineCode",
              "value": "a"
            },
            {
              "type": "text",
              "value": ". When you added 1 to "
            },
            {
              "type": "inlineCode",
              "value": "b"
            },
            {
              "type": "text",
              "value": " you would get the same result by adding 1 to "
            },
            {
              "type": "inlineCode",
              "value": "a[:2]"
            },
            {
              "type": "text",
              "value": ". If you want to create a "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "new"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " array, use the "
            },
            {
              "type": "inlineCode",
              "value": "numpy.copy"
            },
            {
              "type": "text",
              "value": " array creation routine as such   "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> a = np.array([1, 2, 3, 4])\n>>> b = a[:2].copy()\n>>> b += 1\n>>> print('a = ', a, 'b = ', b)\na =  [1 2 3 4] b =  [2 3]"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "For more information and examples look at "
            },
            {
              "type": "inlineCode",
              "value": "Copies and Views\n<quickstart.copies-and-views>"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "There are a number of routines to join existing arrays e.g. "
            },
            {
              "type": "inlineCode",
              "value": "numpy.vstack"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "numpy.hstack"
            },
            {
              "type": "text",
              "value": ", and "
            },
            {
              "type": "inlineCode",
              "value": "numpy.block"
            },
            {
              "type": "text",
              "value": ". Here is an example of joining four 2-by-2 arrays into a 4-by-4 array using "
            },
            {
              "type": "inlineCode",
              "value": "block"
            },
            {
              "type": "text",
              "value": "   "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> A = np.ones((2, 2))\n>>> B = np.eye(2, 2)\n>>> C = np.zeros((2, 2))\n>>> D = np.diag((-3, -4))\n>>> np.block([[A, B], [C, D]])\narray([[ 1.,  1.,  1.,  0.],\n       [ 1.,  1.,  0.,  1.],\n       [ 0.,  0., -3.,  0.],\n       [ 0.,  0.,  0., -4.]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Other routines use similar syntax to join ndarrays. Check the routine's documentation for further examples and syntax."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "3) Replicating, joining, or mutating existing arrays",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "This is the most common case of large array creation. The details depend greatly on the format of data on disk. This section gives general pointers on how to handle various formats. For more detailed examples of IO look at "
            },
            {
              "type": "inlineCode",
              "value": "How to Read and Write files <how-to-io>"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "4) Reading arrays from disk, either from standard or custom formats",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Various fields have standard formats for array data. The following lists the ones with known Python libraries to read them and return NumPy arrays (there may be others for which it is possible to read and convert to NumPy arrays so check the last section as well) ::"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "HDF5: h5py  FITS: Astropy"
                }
              ],
              "type": "paragraph"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Examples of formats that cannot be read directly but for which it is not hard to convert are those formats supported by libraries like PIL (able to read and write many image formats such as jpg, png, etc)."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Standard Binary Formats",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Delimited files such as comma separated value (csv) and tab separated value (tsv) files are used for programs like Excel and LabView. Python functions can read and parse these files line-by-line. NumPy has two standard routines for importing a file with delimited data "
            },
            {
              "type": "inlineCode",
              "value": "numpy.loadtxt"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "numpy.genfromtxt"
            },
            {
              "type": "text",
              "value": ". These functions have more involved use cases in "
            },
            {
              "type": "inlineCode",
              "value": "how-to-io"
            },
            {
              "type": "text",
              "value": ". A simple example given a "
            },
            {
              "type": "inlineCode",
              "value": "simple.csv"
            },
            {
              "type": "text",
              "value": ":"
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "bash",
          "children": [],
          "name": "code-block",
          "options": {},
          "type": "mystDirective",
          "value": "$ cat simple.csv\nx, y\n0, 0\n1, 1\n2, 4\n3, 9"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Importing "
            },
            {
              "type": "inlineCode",
              "value": "simple.csv"
            },
            {
              "type": "text",
              "value": " is accomplished using "
            },
            {
              "type": "inlineCode",
              "value": "numpy.loadtxt"
            },
            {
              "type": "text",
              "value": ":   "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> np.loadtxt('simple.csv', delimiter = ',', skiprows = 1) # doctest: +SKIP\narray([[0., 0.],\n       [1., 1.],\n       [2., 4.],\n       [3., 9.]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "More generic ASCII files can be read using "
            },
            {
              "anchor": null,
              "exists": true,
              "kind": "module",
              "reference": {
                "kind": "api",
                "module": "scipy",
                "path": "scipy.io",
                "type": "RefInfo",
                "version": "*"
              },
              "type": "Link",
              "value": "scipy.io"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Pandas"
                }
              ],
              "title": "",
              "type": "link",
              "url": "https://pandas.pydata.org/"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Common ASCII Formats",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "There are a variety of approaches one can use. If the file has a relatively simple format then one can write a simple I/O library and use the NumPy "
            },
            {
              "type": "inlineCode",
              "value": "fromfile()"
            },
            {
              "type": "text",
              "value": " function and "
            },
            {
              "type": "inlineCode",
              "value": ".tofile()"
            },
            {
              "type": "text",
              "value": " method to read and write NumPy arrays directly (mind your byteorder though!) If a good C or C++ library exists that read the data, one can wrap that library with a variety of techniques though that certainly is much more work and requires significantly more advanced knowledge to interface with C or C++."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "5) Creating arrays from raw bytes through the use of strings or buffers",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "NumPy is the fundamental library for array containers in the Python Scientific Computing stack. Many Python libraries, including SciPy, Pandas, and OpenCV, use NumPy ndarrays as the common format for data exchange, These libraries can create, operate on, and work with NumPy arrays."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "6) Use of special library functions (e.g., SciPy, Pandas, and OpenCV)",
      "type": "Section"
    }
  ],
  "content": {},
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null,
    "type": "Section"
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "see_also": [],
  "signature": {
    "type": "Signature",
    "value": null
  },
  "type": "DocBlob"
}