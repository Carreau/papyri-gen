{
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "type": "mystComment",
          "value": ".. for doctest:\n    >>> import numpy as np"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    {
      "children": [
        {
          "args": "",
          "children": [],
          "name": "seealso",
          "options": {},
          "type": "mystDirective",
          "value": ":ref:`Indexing routines <routines.indexing>`"
        },
        {
          "args": "adapted from \"Guide to NumPy\" by Travis E. Oliphant",
          "children": [],
          "name": "sectionauthor",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "args": "numpy",
          "children": [],
          "name": "currentmodule",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "args": "indexing, slicing",
          "children": [],
          "name": "index",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "ndarrays <ndarray>"
            },
            {
              "type": "text",
              "value": " can be indexed using the standard Python "
            },
            {
              "type": "inlineCode",
              "value": "x[obj]"
            },
            {
              "type": "text",
              "value": " syntax, where "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "x"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " is the array and "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "obj"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " the selection. There are different kinds of indexing available depending on "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "obj"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": ": basic indexing, advanced indexing and field access."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Most of the following examples show the use of indexing when referencing data in an array. The examples work just as well when assigning to an array. See "
            },
            {
              "type": "inlineCode",
              "value": "assigning-values-to-indexed-arrays"
            },
            {
              "type": "text",
              "value": " for specific examples and explanations on how assignments work."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Note that in Python, "
            },
            {
              "type": "inlineCode",
              "value": "x[(exp1, exp2, ..., expN)]"
            },
            {
              "type": "text",
              "value": " is equivalent to "
            },
            {
              "type": "inlineCode",
              "value": "x[exp1, exp2, ..., expN]"
            },
            {
              "type": "text",
              "value": "; the latter is just syntactic sugar for the former."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": "basics.indexing",
      "title": "Indexing on :class:`ndarrays <.ndarray>`",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": "basic-indexing",
      "title": "Basic indexing",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Single element indexing works exactly like that for other standard Python sequences. It is 0-based, and accepts negative indices for indexing from the end of the array.       "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x = np.arange(10)\n>>> x[2]\n2\n>>> x[-2]\n8"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "It is not necessary to separate each dimension's index into its own set of square brackets.       "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x.shape = (2, 5)  # now x is 2-dimensional\n>>> x[1, 3]\n8\n>>> x[1, -1]\n9"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Note that if one indexes a multidimensional array with fewer indices than dimensions, one gets a subdimensional array. For example:       "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x[0]\narray([0, 1, 2, 3, 4])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "That is, each index specified selects the array corresponding to the rest of the dimensions selected. In the above example, choosing 0 means that the remaining dimension of length 5 is being left unspecified, and that what is returned is an array of that dimensionality and size. It must be noted that the returned array is a "
            },
            {
              "type": "inlineCode",
              "value": "view"
            },
            {
              "type": "text",
              "value": ", i.e., it is not a copy of the original, but points to the same values in memory as does the original array. In  this case, the 1-D array at the first position (0) is returned. So using a single index on the returned array, results in a single element being returned. That is:       "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x[0][2]\n2"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "So note that "
            },
            {
              "type": "inlineCode",
              "value": "x[0, 2] == x[0][2]"
            },
            {
              "type": "text",
              "value": " though the second case is more inefficient as a new temporary array is created after the first index that is subsequently indexed by 2."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "note "
                }
              ],
              "type": "admonitionTitle"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "NumPy uses C-order indexing. That means that the last index usually represents the most rapidly changing memory location, unlike Fortran or IDL, where the first index represents the most rapidly changing location in memory. This difference represents a great potential for confusion."
                }
              ],
              "type": "paragraph"
            }
          ],
          "kind": "note",
          "type": "admonition"
        }
      ],
      "level": 2,
      "target": "single-element-indexing",
      "title": "Single element indexing",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Basic slicing extends Python's basic concept of slicing to N dimensions. Basic slicing occurs when "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "obj"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " is a "
            },
            {
              "type": "inlineCode",
              "value": "slice"
            },
            {
              "type": "text",
              "value": " object (constructed by "
            },
            {
              "type": "inlineCode",
              "value": "start:stop:step"
            },
            {
              "type": "text",
              "value": " notation inside of brackets), an integer, or a tuple of slice objects and integers. "
            },
            {
              "type": "inlineCode",
              "value": "Ellipsis"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "newaxis"
            },
            {
              "type": "text",
              "value": " objects can be interspersed with these as well."
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "",
          "children": [],
          "name": "index",
          "options": {},
          "type": "mystDirective",
          "value": "triple: ndarray; special methods; getitem\ntriple: ndarray; special methods; setitem\nsingle: ellipsis\nsingle: newaxis"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The simplest case of indexing with "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "N"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " integers returns an "
            },
            {
              "type": "inlineCode",
              "value": "array\nscalar <arrays.scalars>"
            },
            {
              "type": "text",
              "value": " representing the corresponding item.  As in Python, all indices are zero-based: for the "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "i"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": "-th index "
            },
            {
              "type": "inlineMath",
              "value": "n_i"
            },
            {
              "type": "text",
              "value": ", the valid range is "
            },
            {
              "type": "inlineMath",
              "value": "0 \\le n_i < d_i"
            },
            {
              "type": "text",
              "value": " where "
            },
            {
              "type": "inlineMath",
              "value": "d_i"
            },
            {
              "type": "text",
              "value": " is the "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "i"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": "-th element of the shape of the array.  Negative indices are interpreted as counting from the end of the array ("
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "i.e."
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": ", if "
            },
            {
              "type": "inlineMath",
              "value": "n_i < 0"
            },
            {
              "type": "text",
              "value": ", it means "
            },
            {
              "type": "inlineMath",
              "value": "n_i + d_i"
            },
            {
              "type": "text",
              "value": ")."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "All arrays generated by basic slicing are always "
            },
            {
              "type": "inlineCode",
              "value": "views <view>"
            },
            {
              "type": "text",
              "value": " of the original array."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "note "
                }
              ],
              "type": "admonitionTitle"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "NumPy slicing creates a "
                },
                {
                  "domain": null,
                  "role": "term",
                  "type": "Directive",
                  "value": "view"
                },
                {
                  "type": "text",
                  "value": " instead of a copy as in the case of built-in Python sequences such as string, tuple and list. Care must be taken when extracting a small portion from a large array which becomes useless after the extraction, because the small portion extracted contains a reference to the large original array whose memory will not be released until all arrays derived from it are garbage-collected. In such cases an explicit "
                },
                {
                  "type": "inlineCode",
                  "value": "copy()"
                },
                {
                  "type": "text",
                  "value": " is recommended."
                }
              ],
              "type": "paragraph"
            }
          ],
          "kind": "note",
          "type": "admonition"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The standard rules of sequence slicing apply to basic slicing on a per-dimension basis (including using a step index). Some useful concepts to remember include:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The basic slice syntax is "
                    },
                    {
                      "type": "inlineCode",
                      "value": "i:j:k"
                    },
                    {
                      "type": "text",
                      "value": " where "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "i"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " is the starting index,   "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "j"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " is the stopping index, and "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "k"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " is the step ("
                    },
                    {
                      "type": "inlineMath",
                      "value": "k\\neq0"
                    },
                    {
                      "type": "text",
                      "value": ").   This selects the "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "m"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " elements (in the corresponding dimension) with   index values "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "i"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": ", "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "i + k"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": ", ..., "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "i + (m - 1) k"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " where   "
                    },
                    {
                      "type": "inlineMath",
                      "value": "m = q + (r\\neq0)"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "q"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "r"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " are the quotient and remainder   obtained by dividing "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "j - i"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " by "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "k"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": ": "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "j - i = q k + r"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": ", so that   "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "i + (m - 1) k < j"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": ".    For example       "
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "type": "code",
                  "value": ">>> x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> x[1:7:2]\narray([1, 3, 5])"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Negative "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "i"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "j"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " are interpreted as "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "n + i"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "n + j"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " where   "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "n"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " is the number of elements in the corresponding dimension.   Negative "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "k"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " makes stepping go towards smaller indices.   From the above example        "
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "type": "code",
                  "value": ">>> x[-2:10]\narray([8, 9])\n>>> x[-3:3:-1]\narray([7, 6, 5, 4])"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Assume "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "n"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " is the number of elements in the dimension being   sliced. Then, if "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "i"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " is not given it defaults to 0 for "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "k > 0"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " and   "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "n - 1"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " for "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "k < 0"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " . If "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "j"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " is not given it defaults to "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "n"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " for "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "k > 0"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": "   and "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "-n-1"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " for "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "k < 0"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " . If "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "k"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " is not given it defaults to 1. Note that   "
                    },
                    {
                      "type": "inlineCode",
                      "value": "::"
                    },
                    {
                      "type": "text",
                      "value": " is the same as "
                    },
                    {
                      "type": "inlineCode",
                      "value": ":"
                    },
                    {
                      "type": "text",
                      "value": " and means select all indices along this   axis.   From the above example        "
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "type": "code",
                  "value": ">>> x[5:]\narray([5, 6, 7, 8, 9])"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "If the number of objects in the selection tuple is less than   "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "N"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": ", then "
                    },
                    {
                      "type": "inlineCode",
                      "value": ":"
                    },
                    {
                      "type": "text",
                      "value": " is assumed for any subsequent dimensions.   For example        "
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "type": "code",
                  "value": ">>> x = np.array([[[1],[2],[3]], [[4],[5],[6]]])\n>>> x.shape\n(2, 3, 1)\n>>> x[1:2]\narray([[[4],\n        [5],\n        [6]]])"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "An integer, "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "i"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": ", returns the same values as "
                    },
                    {
                      "type": "inlineCode",
                      "value": "i:i+1"
                    },
                    {
                      "type": "text",
                      "value": "   "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "except"
                        }
                      ],
                      "type": "strong"
                    },
                    {
                      "type": "text",
                      "value": " the dimensionality of the returned object is reduced by   1. In particular, a selection tuple with the "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "p"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": "-th   element an integer (and all other entries "
                    },
                    {
                      "type": "inlineCode",
                      "value": ":"
                    },
                    {
                      "type": "text",
                      "value": ") returns the   corresponding sub-array with dimension "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "N - 1"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": ". If "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "N = 1"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": "   then the returned object is an array scalar. These objects are   explained in "
                    },
                    {
                      "type": "inlineCode",
                      "value": "arrays.scalars"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "If the selection tuple has all entries "
                    },
                    {
                      "type": "inlineCode",
                      "value": ":"
                    },
                    {
                      "type": "text",
                      "value": " except the   "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "p"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": "-th entry which is a slice object "
                    },
                    {
                      "type": "inlineCode",
                      "value": "i:j:k"
                    },
                    {
                      "type": "text",
                      "value": ",   then the returned array has dimension "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "N"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " formed by   concatenating the sub-arrays returned by integer indexing of   elements "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "i"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": ", "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "i+k"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": ", ..., "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "i + (m - 1) k < j"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": ","
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Basic slicing with more than one non-"
                    },
                    {
                      "type": "inlineCode",
                      "value": ":"
                    },
                    {
                      "type": "text",
                      "value": " entry in the slicing   tuple, acts like repeated application of slicing using a single   non-"
                    },
                    {
                      "type": "inlineCode",
                      "value": ":"
                    },
                    {
                      "type": "text",
                      "value": " entry, where the non-"
                    },
                    {
                      "type": "inlineCode",
                      "value": ":"
                    },
                    {
                      "type": "text",
                      "value": " entries are successively taken   (with all other non-"
                    },
                    {
                      "type": "inlineCode",
                      "value": ":"
                    },
                    {
                      "type": "text",
                      "value": " entries replaced by "
                    },
                    {
                      "type": "inlineCode",
                      "value": ":"
                    },
                    {
                      "type": "text",
                      "value": "). Thus,   "
                    },
                    {
                      "type": "inlineCode",
                      "value": "x[ind1, ..., ind2,:]"
                    },
                    {
                      "type": "text",
                      "value": " acts like "
                    },
                    {
                      "type": "inlineCode",
                      "value": "x[ind1][..., ind2, :]"
                    },
                    {
                      "type": "text",
                      "value": " under basic   slicing."
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "children": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "warning The above is **not** true for advanced indexing."
                        }
                      ],
                      "type": "admonitionTitle"
                    }
                  ],
                  "kind": "note",
                  "type": "admonition"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "You may use slicing to set values in the array, but (unlike lists) you   can never grow the array. The size of the value to be set in   "
                    },
                    {
                      "type": "inlineCode",
                      "value": "x[obj] = value"
                    },
                    {
                      "type": "text",
                      "value": " must be (broadcastable to) the same shape as   "
                    },
                    {
                      "type": "inlineCode",
                      "value": "x[obj]"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "A slicing tuple can always be constructed as "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "obj"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": "   and used in the "
                    },
                    {
                      "type": "inlineCode",
                      "value": "x[obj]"
                    },
                    {
                      "type": "text",
                      "value": " notation. Slice objects can be used in   the construction in place of the "
                    },
                    {
                      "type": "inlineCode",
                      "value": "[start:stop:step]"
                    },
                    {
                      "type": "text",
                      "value": "   notation. For example, "
                    },
                    {
                      "type": "inlineCode",
                      "value": "x[1:10:5, ::-1]"
                    },
                    {
                      "type": "text",
                      "value": " can also be implemented   as "
                    },
                    {
                      "type": "inlineCode",
                      "value": "obj = (slice(1, 10, 5), slice(None, None, -1)); x[obj]"
                    },
                    {
                      "type": "text",
                      "value": " . This   can be useful for constructing generic code that works on arrays   of arbitrary dimensions. See "
                    },
                    {
                      "type": "inlineCode",
                      "value": "dealing-with-variable-indices"
                    },
                    {
                      "type": "text",
                      "value": "   for more information."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "args": "",
          "children": [],
          "name": "index",
          "options": {},
          "type": "mystDirective",
          "value": "pair: ndarray; view"
        }
      ],
      "level": 2,
      "target": "slicing-and-striding",
      "title": "Slicing and striding",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "There are some tools to facilitate the easy matching of array shapes with expressions and in assignments."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "Ellipsis"
            },
            {
              "type": "text",
              "value": " expands to the number of "
            },
            {
              "type": "inlineCode",
              "value": ":"
            },
            {
              "type": "text",
              "value": " objects needed for the selection tuple to index all dimensions. In most cases, this means that the length of the expanded selection tuple is "
            },
            {
              "type": "inlineCode",
              "value": "x.ndim"
            },
            {
              "type": "text",
              "value": ". There may only be a single ellipsis present. From the above example      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x[..., 0]\narray([[1, 2, 3],\n      [4, 5, 6]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This is equivalent to      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x[:, :, 0]\narray([[1, 2, 3],\n      [4, 5, 6]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Each "
            },
            {
              "type": "inlineCode",
              "value": "newaxis"
            },
            {
              "type": "text",
              "value": " object in the selection tuple serves to expand the dimensions of the resulting selection by one unit-length dimension.  The added dimension is the position of the "
            },
            {
              "type": "inlineCode",
              "value": "newaxis"
            },
            {
              "type": "text",
              "value": " object in the selection tuple. "
            },
            {
              "type": "inlineCode",
              "value": "newaxis"
            },
            {
              "type": "text",
              "value": " is an alias for "
            },
            {
              "type": "inlineCode",
              "value": "None"
            },
            {
              "type": "text",
              "value": ", and "
            },
            {
              "type": "inlineCode",
              "value": "None"
            },
            {
              "type": "text",
              "value": " can be used in place of this with the same result. From the above example      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x[:, np.newaxis, :, :].shape\n(2, 1, 3, 1)\n>>> x[:, None, :, :].shape\n(2, 1, 3, 1)"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This can be handy to combine two arrays in a way that otherwise would require explicit reshaping operations. For example      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x = np.arange(5)\n>>> x[:, np.newaxis] + x[np.newaxis, :]\narray([[0, 1, 2, 3, 4],\n      [1, 2, 3, 4, 5],\n      [2, 3, 4, 5, 6],\n      [3, 4, 5, 6, 7],\n      [4, 5, 6, 7, 8]])"
        }
      ],
      "level": 2,
      "target": "dimensional-indexing-tools",
      "title": "Dimensional indexing tools",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Advanced indexing is triggered when the selection object, "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "obj"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": ", is a non-tuple sequence object, an "
            },
            {
              "type": "inlineCode",
              "value": "ndarray"
            },
            {
              "type": "text",
              "value": " (of data type integer or bool), or a tuple with at least one sequence object or ndarray (of data type integer or bool). There are two types of advanced indexing: integer and Boolean."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Advanced indexing always returns a "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "copy"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " of the data (contrast with basic slicing that returns a "
            },
            {
              "type": "inlineCode",
              "value": "view"
            },
            {
              "type": "text",
              "value": ")."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "warning "
                }
              ],
              "type": "admonitionTitle"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "The definition of advanced indexing means that "
                },
                {
                  "type": "inlineCode",
                  "value": "x[(1, 2, 3),]"
                },
                {
                  "type": "text",
                  "value": " is fundamentally different than "
                },
                {
                  "type": "inlineCode",
                  "value": "x[(1, 2, 3)]"
                },
                {
                  "type": "text",
                  "value": ". The latter is equivalent to "
                },
                {
                  "type": "inlineCode",
                  "value": "x[1, 2, 3]"
                },
                {
                  "type": "text",
                  "value": " which will trigger basic selection while the former will trigger advanced indexing. Be sure to understand why this occurs."
                }
              ],
              "type": "paragraph"
            }
          ],
          "kind": "note",
          "type": "admonition"
        }
      ],
      "level": 1,
      "target": "advanced-indexing",
      "title": "Advanced indexing",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Integer array indexing allows selection of arbitrary items in the array based on their "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "N"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": "-dimensional index. Each integer array represents a number of indices into that dimension."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Negative values are permitted in the index arrays and work as they do with single indices or slices      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x = np.arange(10, 1, -1)\n>>> x\narray([10,  9,  8,  7,  6,  5,  4,  3,  2])\n>>> x[np.array([3, 3, 1, 8])]\narray([7, 7, 9, 2])\n>>> x[np.array([3, 3, -3, 8])]\narray([7, 7, 4, 2])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "If the index values are out of bounds then an "
            },
            {
              "type": "inlineCode",
              "value": "IndexError"
            },
            {
              "type": "text",
              "value": " is thrown      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x = np.array([[1, 2], [3, 4], [5, 6]])\n>>> x[np.array([1, -1])]\narray([[3, 4],\n      [5, 6]])\n>>> x[np.array([3, 4])]\nTraceback (most recent call last):\n  ...\nIndexError: index 3 is out of bounds for axis 0 with size 3"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "When the index consists of as many integer arrays as dimensions of the array being indexed, the indexing is straightforward, but different from slicing."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Advanced indices always are "
            },
            {
              "type": "inlineCode",
              "value": "broadcast<basics.broadcasting>"
            },
            {
              "type": "text",
              "value": " and iterated as "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "one"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": "       "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": "result[i_1, ..., i_M] == x[ind_1[i_1, ..., i_M], ind_2[i_1, ..., i_M],\n                           ..., ind_N[i_1, ..., i_M]]"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Note that the resulting shape is identical to the (broadcast) indexing array shapes "
            },
            {
              "type": "inlineCode",
              "value": "ind_1, ..., ind_N"
            },
            {
              "type": "text",
              "value": ". If the indices cannot be broadcast to the same shape, an exception "
            },
            {
              "type": "inlineCode",
              "value": "IndexError: shape mismatch: indexing arrays could\nnot be broadcast together with shapes..."
            },
            {
              "type": "text",
              "value": " is raised."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Indexing with multidimensional index arrays tend to be more unusual uses, but they are permitted, and they are useful for some problems. We\u2019ll start with the simplest multidimensional case      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> y = np.arange(35).reshape(5, 7)\n>>> y\narray([[ 0,  1,  2,  3,  4,  5,  6],\n       [ 7,  8,  9, 10, 11, 12, 13],\n       [14, 15, 16, 17, 18, 19, 20],\n       [21, 22, 23, 24, 25, 26, 27],\n       [28, 29, 30, 31, 32, 33, 34]])\n>>> y[np.array([0, 2, 4]), np.array([0, 1, 2])]\narray([ 0, 15, 30])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In this case, if the index arrays have a matching shape, and there is an index array for each dimension of the array being indexed, the resultant array has the same shape as the index arrays, and the values correspond to the index set for each position in the index arrays. In this example, the first index value is 0 for both index arrays, and thus the first value of the resultant array is "
            },
            {
              "type": "inlineCode",
              "value": "y[0, 0]"
            },
            {
              "type": "text",
              "value": ". The next value is "
            },
            {
              "type": "inlineCode",
              "value": "y[2, 1]"
            },
            {
              "type": "text",
              "value": ", and the last is "
            },
            {
              "type": "inlineCode",
              "value": "y[4, 2]"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "If the index arrays do not have the same shape, there is an attempt to broadcast them to the same shape. If they cannot be broadcast to the same shape, an exception is raised      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> y[np.array([0, 2, 4]), np.array([0, 1])]\nTraceback (most recent call last):\n  ...\nIndexError: shape mismatch: indexing arrays could not be broadcast\ntogether with shapes (3,) (2,)"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The broadcasting mechanism permits index arrays to be combined with scalars for other indices. The effect is that the scalar value is used for all the corresponding values of the index arrays      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> y[np.array([0, 2, 4]), 1]\narray([ 1, 15, 29])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Jumping to the next level of complexity, it is possible to only partially index an array with index arrays. It takes a bit of thought to understand what happens in such cases. For example if we just use one index array with y      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> y[np.array([0, 2, 4])]\narray([[ 0,  1,  2,  3,  4,  5,  6],\n      [14, 15, 16, 17, 18, 19, 20],\n      [28, 29, 30, 31, 32, 33, 34]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "It results in the construction of a new array where each value of the index array selects one row from the array being indexed and the resultant array has the resulting shape (number of index elements, size of row)."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In general, the shape of the resultant array will be the concatenation of the shape of the index array (or the shape that all the index arrays were broadcast to) with the shape of any unused dimensions (those not indexed) in the array being indexed."
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "Example",
          "children": [],
          "name": "rubric",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "children": [
            {
              "type": "text",
              "value": "From each row, a specific element should be selected. The row index is just "
            },
            {
              "type": "inlineCode",
              "value": "[0, 1, 2]"
            },
            {
              "type": "text",
              "value": " and the column index specifies the element to choose for the corresponding row, here "
            },
            {
              "type": "inlineCode",
              "value": "[0, 1, 0]"
            },
            {
              "type": "text",
              "value": ". Using both together the task can be solved using advanced indexing      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x = np.array([[1, 2], [3, 4], [5, 6]])\n>>> x[[0, 1, 2], [0, 1, 0]]\narray([1, 4, 5])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "To achieve a behaviour similar to the basic slicing above, broadcasting can be used. The function "
            },
            {
              "type": "inlineCode",
              "value": "ix_"
            },
            {
              "type": "text",
              "value": " can help with this broadcasting. This is best understood with an example."
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "Example",
          "children": [],
          "name": "rubric",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "children": [
            {
              "type": "text",
              "value": "From a 4x3 array the corner elements should be selected using advanced indexing. Thus all elements for which the column is one of "
            },
            {
              "type": "inlineCode",
              "value": "[0, 2]"
            },
            {
              "type": "text",
              "value": " and the row is one of "
            },
            {
              "type": "inlineCode",
              "value": "[0, 3]"
            },
            {
              "type": "text",
              "value": " need to be selected. To use advanced indexing one needs to select all elements "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "explicitly"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": ". Using the method explained previously one could write      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x = np.array([[ 0,  1,  2],\n...               [ 3,  4,  5],\n...               [ 6,  7,  8],\n...               [ 9, 10, 11]])\n>>> rows = np.array([[0, 0],\n...                  [3, 3]], dtype=np.intp)\n>>> columns = np.array([[0, 2],\n...                     [0, 2]], dtype=np.intp)\n>>> x[rows, columns]\narray([[ 0,  2],\n       [ 9, 11]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "However, since the indexing arrays above just repeat themselves, broadcasting can be used (compare operations such as "
            },
            {
              "type": "inlineCode",
              "value": "rows[:, np.newaxis] + columns"
            },
            {
              "type": "text",
              "value": ") to simplify this      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> rows = np.array([0, 3], dtype=np.intp)\n>>> columns = np.array([0, 2], dtype=np.intp)\n>>> rows[:, np.newaxis]\narray([[0],\n       [3]])\n>>> x[rows[:, np.newaxis], columns]\narray([[ 0,  2],\n       [ 9, 11]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This broadcasting can also be achieved using the function "
            },
            {
              "type": "inlineCode",
              "value": "ix_"
            },
            {
              "type": "text",
              "value": ":"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> x[np.ix_(rows, columns)]\narray([[ 0,  2],\n       [ 9, 11]])"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Note that without the "
            },
            {
              "type": "inlineCode",
              "value": "np.ix_"
            },
            {
              "type": "text",
              "value": " call, only the diagonal elements would be selected      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x[rows, columns]\narray([ 0, 11])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "This difference is the most important thing to remember about indexing with multiple advanced indices."
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "Example",
          "children": [],
          "name": "rubric",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "children": [
            {
              "type": "text",
              "value": "A real-life example of where advanced indexing may be useful is for a color lookup table where we want to map the values of an image into RGB triples for display. The lookup table could have a shape (nlookup, 3). Indexing such an array with an image with shape (ny, nx) with dtype=np.uint8 (or any integer type so long as values are with the bounds of the lookup table) will result in an array of shape (ny, nx, 3) where a triple of RGB values is associated with each pixel location."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Integer array indexing",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "This advanced indexing occurs when "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "obj"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " is an array object of Boolean type, such as may be returned from comparison operators. A single boolean index array is practically identical to "
            },
            {
              "type": "inlineCode",
              "value": "x[obj.nonzero()]"
            },
            {
              "type": "text",
              "value": " where, as described above, "
            },
            {
              "type": "inlineCode",
              "value": "obj.nonzero() <ndarray.nonzero>"
            },
            {
              "type": "text",
              "value": " returns a tuple (of length "
            },
            {
              "type": "inlineCode",
              "value": "obj.ndim <ndarray.ndim>"
            },
            {
              "type": "text",
              "value": ") of integer index arrays showing the "
            },
            {
              "type": "inlineCode",
              "value": "True"
            },
            {
              "type": "text",
              "value": " elements of "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "obj"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": ". However, it is faster when "
            },
            {
              "type": "inlineCode",
              "value": "obj.shape == x.shape"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "If "
            },
            {
              "type": "inlineCode",
              "value": "obj.ndim == x.ndim"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "x[obj]"
            },
            {
              "type": "text",
              "value": " returns a 1-dimensional array filled with the elements of "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "x"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " corresponding to the "
            },
            {
              "type": "inlineCode",
              "value": "True"
            },
            {
              "type": "text",
              "value": " values of "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "obj"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": ". The search order will be "
            },
            {
              "type": "inlineCode",
              "value": "row-major"
            },
            {
              "type": "text",
              "value": ", C-style. An index error will be raised if the shape of "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "obj"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " does not match the corresponding dimensions of "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "x"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": ", regardless of whether those values are "
            },
            {
              "type": "inlineCode",
              "value": "True"
            },
            {
              "type": "text",
              "value": " or "
            },
            {
              "type": "inlineCode",
              "value": "False"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "A common use case for this is filtering for desired element values. For example, one may wish to select all entries from an array which are not "
            },
            {
              "type": "inlineCode",
              "value": "NaN"
            },
            {
              "type": "text",
              "value": ":      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x = np.array([[1., 2.], [np.nan, 3.], [np.nan, np.nan]])\n>>> x[~np.isnan(x)]\narray([1., 2., 3.])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Or wish to add a constant to all negative elements      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x = np.array([1., -1., -2., 3])\n>>> x[x < 0] += 20\n>>> x\narray([ 1., 19., 18., 3.])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In general if an index includes a Boolean array, the result will be identical to inserting "
            },
            {
              "type": "inlineCode",
              "value": "obj.nonzero()"
            },
            {
              "type": "text",
              "value": " into the same position and using the integer array indexing mechanism described above. "
            },
            {
              "type": "inlineCode",
              "value": "x[ind_1, boolean_array, ind_2]"
            },
            {
              "type": "text",
              "value": " is equivalent to "
            },
            {
              "type": "inlineCode",
              "value": "x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "If there is only one Boolean array and no integer indexing array present, this is straightforward. Care must only be taken to make sure that the boolean index has "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "exactly"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " as many dimensions as it is supposed to work with."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In general, when the boolean array has fewer dimensions than the array being indexed, this is equivalent to "
            },
            {
              "type": "inlineCode",
              "value": "x[b, ...]"
            },
            {
              "type": "text",
              "value": ", which means x is indexed by b followed by as many "
            },
            {
              "type": "inlineCode",
              "value": ":"
            },
            {
              "type": "text",
              "value": " as are needed to fill out the rank of x. Thus the shape of the result is one dimension containing the number of True elements of the boolean array, followed by the remaining dimensions of the array being indexed      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x = np.arange(35).reshape(5, 7)\n>>> b = x > 20\n>>> b[:, 5]\narray([False, False, False,  True,  True])\n>>> x[b[:, 5]]\narray([[21, 22, 23, 24, 25, 26, 27],\n      [28, 29, 30, 31, 32, 33, 34]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Here the 4th and 5th rows are selected from the indexed array and combined to make a 2-D array."
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "Example",
          "children": [],
          "name": "rubric",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "children": [
            {
              "type": "text",
              "value": "From an array, select all rows which sum up to less or equal two      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x = np.array([[0, 1], [1, 1], [2, 2]])\n>>> rowsum = x.sum(-1)\n>>> x[rowsum <= 2, :]\narray([[0, 1],\n       [1, 1]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Combining multiple Boolean indexing arrays or a Boolean with an integer indexing array can best be understood with the "
            },
            {
              "type": "inlineCode",
              "value": "obj.nonzero() <ndarray.nonzero>"
            },
            {
              "type": "text",
              "value": " analogy. The function "
            },
            {
              "type": "inlineCode",
              "value": "ix_"
            },
            {
              "type": "text",
              "value": " also supports boolean arrays and will work without any surprises."
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "Example",
          "children": [],
          "name": "rubric",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Use boolean indexing to select all rows adding up to an even number. At the same time columns 0 and 2 should be selected with an advanced integer index. Using the "
            },
            {
              "type": "inlineCode",
              "value": "ix_"
            },
            {
              "type": "text",
              "value": " function this can be done with      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x = np.array([[ 0,  1,  2],\n...               [ 3,  4,  5],\n...               [ 6,  7,  8],\n...               [ 9, 10, 11]])\n>>> rows = (x.sum(-1) % 2) == 0\n>>> rows\narray([False,  True, False,  True])\n>>> columns = [0, 2]\n>>> x[np.ix_(rows, columns)]\narray([[ 3,  5],\n       [ 9, 11]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Without the "
            },
            {
              "type": "inlineCode",
              "value": "np.ix_"
            },
            {
              "type": "text",
              "value": " call, only the diagonal elements would be selected."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Or without "
            },
            {
              "type": "inlineCode",
              "value": "np.ix_"
            },
            {
              "type": "text",
              "value": " (compare the integer array examples)      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> rows = rows.nonzero()[0]\n>>> x[rows[:, np.newaxis], columns]\narray([[ 3,  5],\n       [ 9, 11]])"
        },
        {
          "args": "Example",
          "children": [],
          "name": "rubric",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Use a 2-D boolean array of shape (2, 3) with four True elements to select rows from a 3-D array of shape (2, 3, 5) results in a 2-D result of shape (4, 5)      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x = np.arange(30).reshape(2, 3, 5)\n>>> x\narray([[[ 0,  1,  2,  3,  4],\n        [ 5,  6,  7,  8,  9],\n        [10, 11, 12, 13, 14]],\n      [[15, 16, 17, 18, 19],\n        [20, 21, 22, 23, 24],\n        [25, 26, 27, 28, 29]]])\n>>> b = np.array([[True, True, False], [False, True, True]])\n>>> x[b]\narray([[ 0,  1,  2,  3,  4],\n      [ 5,  6,  7,  8,  9],\n      [20, 21, 22, 23, 24],\n      [25, 26, 27, 28, 29]])"
        }
      ],
      "level": 2,
      "target": "boolean-indexing",
      "title": "Boolean array indexing",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "When there is at least one slice ("
            },
            {
              "type": "inlineCode",
              "value": ":"
            },
            {
              "type": "text",
              "value": "), ellipsis ("
            },
            {
              "type": "inlineCode",
              "value": "..."
            },
            {
              "type": "text",
              "value": ") or "
            },
            {
              "type": "inlineCode",
              "value": "newaxis"
            },
            {
              "type": "text",
              "value": " in the index (or the array has more dimensions than there are advanced indices), then the behaviour can be more complicated. It is like concatenating the indexing result for each advanced index element."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In the simplest case, there is only a "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "single"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " advanced index combined with a slice. For example      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> y = np.arange(35).reshape(5,7)\n>>> y[np.array([0, 2, 4]), 1:3]\narray([[ 1,  2],\n       [15, 16],\n       [29, 30]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In effect, the slice and index array operation are independent. The slice operation extracts columns with index 1 and 2, (i.e. the 2nd and 3rd columns), followed by the index array operation which extracts rows with index 0, 2 and 4 (i.e the first, third and fifth rows). This is equivalent to      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> y[:, 1:3][np.array([0, 2, 4]), :]\narray([[ 1,  2],\n       [15, 16],\n       [29, 30]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "A single advanced index can, for example, replace a slice and the result array will be the same. However, it is a copy and may have a different memory layout. A slice is preferable when it is possible. For example      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x = np.array([[ 0,  1,  2],\n...               [ 3,  4,  5],\n...               [ 6,  7,  8],\n...               [ 9, 10, 11]])\n>>> x[1:2, 1:3]\narray([[4, 5]])\n>>> x[1:2, [1, 2]]\narray([[4, 5]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The easiest way to understand a combination of "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "multiple"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " advanced indices may be to think in terms of the resulting shape. There are two parts to the indexing operation, the subspace defined by the basic indexing (excluding integers) and the subspace from the advanced indexing part. Two cases of index combination need to be distinguished:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The advanced indices are separated by a slice, "
                    },
                    {
                      "type": "inlineCode",
                      "value": "Ellipsis"
                    },
                    {
                      "type": "text",
                      "value": " or   "
                    },
                    {
                      "type": "inlineCode",
                      "value": "newaxis"
                    },
                    {
                      "type": "text",
                      "value": ". For example "
                    },
                    {
                      "type": "inlineCode",
                      "value": "x[arr1, :, arr2]"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The advanced indices are all next to each other.   For example "
                    },
                    {
                      "type": "inlineCode",
                      "value": "x[..., arr1, arr2, :]"
                    },
                    {
                      "type": "text",
                      "value": " but "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "not"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " "
                    },
                    {
                      "type": "inlineCode",
                      "value": "x[arr1, :, 1]"
                    },
                    {
                      "type": "text",
                      "value": "   since "
                    },
                    {
                      "type": "inlineCode",
                      "value": "1"
                    },
                    {
                      "type": "text",
                      "value": " is an advanced index in this regard."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In the first case, the dimensions resulting from the advanced indexing operation come first in the result array, and the subspace dimensions after that. In the second case, the dimensions from the advanced indexing operations are inserted into the result array at the same spot as they were in the initial array (the latter logic is what makes simple advanced indexing behave just like slicing)."
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "Example",
          "children": [],
          "name": "rubric",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Suppose "
            },
            {
              "type": "inlineCode",
              "value": "x.shape"
            },
            {
              "type": "text",
              "value": " is (10, 20, 30) and "
            },
            {
              "type": "inlineCode",
              "value": "ind"
            },
            {
              "type": "text",
              "value": " is a (2, 3, 4)-shaped indexing "
            },
            {
              "type": "inlineCode",
              "value": "intp"
            },
            {
              "type": "text",
              "value": " array, then "
            },
            {
              "type": "inlineCode",
              "value": "result = x[..., ind, :]"
            },
            {
              "type": "text",
              "value": " has shape (10, 2, 3, 4, 30) because the (20,)-shaped subspace has been replaced with a (2, 3, 4)-shaped broadcasted indexing subspace. If we let "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "i, j, k"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " loop over the (2, 3, 4)-shaped subspace then "
            },
            {
              "type": "inlineCode",
              "value": "result[..., i, j, k, :] = x[..., ind[i, j, k], :]"
            },
            {
              "type": "text",
              "value": ". This example produces the same result as "
            },
            {
              "type": "inlineCode",
              "value": "x.take(ind, axis=-2) <ndarray.take>"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "Example",
          "children": [],
          "name": "rubric",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Let "
            },
            {
              "type": "inlineCode",
              "value": "x.shape"
            },
            {
              "type": "text",
              "value": " be (10, 20, 30, 40, 50) and suppose "
            },
            {
              "type": "inlineCode",
              "value": "ind_1"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "ind_2"
            },
            {
              "type": "text",
              "value": " can be broadcast to the shape (2, 3, 4). Then "
            },
            {
              "type": "inlineCode",
              "value": "x[:, ind_1, ind_2]"
            },
            {
              "type": "text",
              "value": " has shape (10, 2, 3, 4, 40, 50) because the (20, 30)-shaped subspace from X has been replaced with the (2, 3, 4) subspace from the indices. However, "
            },
            {
              "type": "inlineCode",
              "value": "x[:, ind_1, :, ind_2]"
            },
            {
              "type": "text",
              "value": " has shape (2, 3, 4, 10, 30, 50) because there is no unambiguous place to drop in the indexing subspace, thus it is tacked-on to the beginning. It is always possible to use "
            },
            {
              "type": "inlineCode",
              "value": ".transpose() <ndarray.transpose>"
            },
            {
              "type": "text",
              "value": " to move the subspace anywhere desired. Note that this example cannot be replicated using "
            },
            {
              "type": "inlineCode",
              "value": "take"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "Example",
          "children": [],
          "name": "rubric",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Slicing can be combined with broadcasted boolean indices      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x = np.arange(35).reshape(5, 7)\n>>> b = x > 20\n>>> b\narray([[False, False, False, False, False, False, False],\n      [False, False, False, False, False, False, False],\n      [False, False, False, False, False, False, False],\n      [ True,  True,  True,  True,  True,  True,  True],\n      [ True,  True,  True,  True,  True,  True,  True]])\n>>> x[b[:, 5], 1:3]\narray([[22, 23],\n      [29, 30]])"
        }
      ],
      "level": 2,
      "target": "combining-advanced-and-basic-indexing",
      "title": "Combining advanced and basic indexing",
      "type": "Section"
    },
    {
      "children": [
        {
          "args": ":ref:`structured_arrays`",
          "children": [],
          "name": "seealso",
          "options": {},
          "type": "mystDirective",
          "value": ""
        },
        {
          "children": [
            {
              "type": "text",
              "value": "If the "
            },
            {
              "type": "inlineCode",
              "value": "ndarray"
            },
            {
              "type": "text",
              "value": " object is a structured array the "
            },
            {
              "type": "inlineCode",
              "value": "fields <field>"
            },
            {
              "type": "text",
              "value": " of the array can be accessed by indexing the array with strings, dictionary-like."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Indexing "
            },
            {
              "type": "inlineCode",
              "value": "x['field-name']"
            },
            {
              "type": "text",
              "value": " returns a new "
            },
            {
              "type": "inlineCode",
              "value": "view"
            },
            {
              "type": "text",
              "value": " to the array, which is of the same shape as "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "x"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " (except when the field is a sub-array) but of data type "
            },
            {
              "type": "inlineCode",
              "value": "x.dtype['field-name']"
            },
            {
              "type": "text",
              "value": " and contains only the part of the data in the specified field. Also, "
            },
            {
              "type": "inlineCode",
              "value": "record array <arrays.classes.rec>"
            },
            {
              "type": "text",
              "value": " scalars can be \"indexed\" this way."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Indexing into a structured array can also be done with a list of field names, e.g. "
            },
            {
              "type": "inlineCode",
              "value": "x[['field-name1', 'field-name2']]"
            },
            {
              "type": "text",
              "value": ". As of NumPy 1.16, this returns a view containing only those fields. In older versions of NumPy, it returned a copy. See the user guide section on "
            },
            {
              "type": "inlineCode",
              "value": "structured_arrays"
            },
            {
              "type": "text",
              "value": " for more information on multifield indexing."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "If the accessed field is a sub-array, the dimensions of the sub-array are appended to the shape of the result. For example     "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x = np.zeros((2, 2), dtype=[('a', np.int32), ('b', np.float64, (3, 3))])\n>>> x['a'].shape\n(2, 2)\n>>> x['a'].dtype\ndtype('int32')\n>>> x['b'].shape\n(2, 2, 3, 3)\n>>> x['b'].dtype\ndtype('float64')"
        }
      ],
      "level": 1,
      "target": "arrays.indexing.fields",
      "title": "Field access",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "x.flat <ndarray.flat>"
            },
            {
              "type": "text",
              "value": " returns an iterator that will iterate over the entire array (in C-contiguous style with the last index varying the fastest). This iterator object can also be indexed using basic slicing or advanced indexing as long as the selection object is not a tuple. This should be clear from the fact that "
            },
            {
              "type": "inlineCode",
              "value": "x.flat\n<ndarray.flat>"
            },
            {
              "type": "text",
              "value": " is a 1-dimensional view. It can be used for integer indexing with 1-dimensional C-style-flat indices. The shape of any returned array is therefore the shape of the integer indexing object."
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "",
          "children": [],
          "name": "index",
          "options": {},
          "type": "mystDirective",
          "value": "single: indexing\nsingle: ndarray"
        }
      ],
      "level": 1,
      "target": "flat-iterator-indexing",
      "title": "Flat Iterator indexing",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "As mentioned, one can select a subset of an array to assign to using a single index, slices, and index and mask arrays. The value being assigned to the indexed array must be shape consistent (the same shape or broadcastable to the shape the index produces). For example, it is permitted to assign a constant to a slice:    "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x = np.arange(10)\n>>> x[2:7] = 1"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "or an array of the right size:    "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x[2:7] = np.arange(5)"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Note that assignments may result in changes if assigning higher types to lower types (like floats to ints) or even exceptions (assigning complex to floats or ints):    "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x[1] = 1.2\n>>> x[1]\n1\n>>> x[1] = 1.2j\nTraceback (most recent call last):\n  ...\nTypeError: can't convert complex to int"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Unlike some of the references (such as array and mask indices) assignments are always made to the original data in the array (indeed, nothing else would make sense!). Note though, that some actions may not work as one may naively expect. This particular example is often surprising to people:    "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> x = np.arange(0, 50, 10)\n>>> x\narray([ 0, 10, 20, 30, 40])\n>>> x[np.array([1, 1, 3, 1])] += 1\n>>> x\narray([ 0, 11, 20, 31, 40])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Where people expect that the 1st location will be incremented by 3. In fact, it will only be incremented by 1. The reason is that a new array is extracted from the original (as a temporary) containing the values at 1, 1, 3, 1, then the value 1 is added to the temporary, and then the temporary is assigned back to the original array. Thus the value of the array at "
            },
            {
              "type": "inlineCode",
              "value": "x[1] + 1"
            },
            {
              "type": "text",
              "value": " is assigned to "
            },
            {
              "type": "inlineCode",
              "value": "x[1]"
            },
            {
              "type": "text",
              "value": " three times, rather than being incremented 3 times."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": "assigning-values-to-indexed-arrays",
      "title": "Assigning values to indexed arrays",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The indexing syntax is very powerful but limiting when dealing with a variable number of indices. For example, if you want to write a function that can handle arguments with various numbers of dimensions without having to write special case code for each number of possible dimensions, how can that be done? If one supplies to the index a tuple, the tuple will be interpreted as a list of indices. For example   "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> z = np.arange(81).reshape(3, 3, 3, 3)\n>>> indices = (1, 1, 1, 1)\n>>> z[indices]\n40"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "So one can use code to construct tuples of any number of indices and then use these within an index."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Slices can be specified within programs by using the slice() function in Python. For example:    "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> indices = (1, 1, 1, slice(0, 2))  # same as [1, 1, 1, 0:2]\n>>> z[indices]\narray([39, 40])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Likewise, ellipsis can be specified by code by using the Ellipsis object:    "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> indices = (1, Ellipsis, 1)  # same as [1, ..., 1]\n>>> z[indices]\narray([[28, 31, 34],\n       [37, 40, 43],\n       [46, 49, 52]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "For this reason, it is possible to use the output from the  "
            },
            {
              "type": "inlineCode",
              "value": "np.nonzero() <ndarray.nonzero>"
            },
            {
              "type": "text",
              "value": " function directly as an index since it always returns a tuple of index arrays."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Because of the special treatment of tuples, they are not automatically converted to an array as a list would be. As an example:    "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> z[[1, 1, 1, 1]]  # produces a large array\narray([[[[27, 28, 29],\n         [30, 31, 32], ...\n>>> z[(1, 1, 1, 1)]  # returns a single value\n40"
        }
      ],
      "level": 1,
      "target": "dealing-with-variable-indices",
      "title": "Dealing with variable numbers of indices within programs",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "These are some detailed notes, which are not of importance for day to day indexing (in no particular order):"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The native NumPy indexing type is "
                    },
                    {
                      "type": "inlineCode",
                      "value": "intp"
                    },
                    {
                      "type": "text",
                      "value": " and may differ from the   default integer array type. "
                    },
                    {
                      "type": "inlineCode",
                      "value": "intp"
                    },
                    {
                      "type": "text",
                      "value": " is the smallest data type   sufficient to safely index any array; for advanced indexing it may be   faster than other types."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "For advanced assignments, there is in general no guarantee for the   iteration order. This means that if an element is set more than once,   it is not possible to predict the final result."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "An empty (tuple) index is a full scalar index into a zero-dimensional array.   "
                    },
                    {
                      "type": "inlineCode",
                      "value": "x[()]"
                    },
                    {
                      "type": "text",
                      "value": " returns a "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "scalar"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " if "
                    },
                    {
                      "type": "inlineCode",
                      "value": "x"
                    },
                    {
                      "type": "text",
                      "value": " is zero-dimensional and a view   otherwise. On the other hand, "
                    },
                    {
                      "type": "inlineCode",
                      "value": "x[...]"
                    },
                    {
                      "type": "text",
                      "value": " always returns a view."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "If a zero-dimensional array is present in the index "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "and"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " it is a full   integer index the result will be a "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "scalar"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " and not a zero-dimensional array.   (Advanced indexing is not triggered.)"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "When an ellipsis ("
                    },
                    {
                      "type": "inlineCode",
                      "value": "..."
                    },
                    {
                      "type": "text",
                      "value": ") is present but has no size (i.e. replaces zero   "
                    },
                    {
                      "type": "inlineCode",
                      "value": ":"
                    },
                    {
                      "type": "text",
                      "value": ") the result will still always be an array. A view if no advanced index   is present, otherwise a copy."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The "
                    },
                    {
                      "type": "inlineCode",
                      "value": "nonzero"
                    },
                    {
                      "type": "text",
                      "value": " equivalence for Boolean arrays does not hold for zero   dimensional boolean arrays."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "When the result of an advanced indexing operation has no elements but an   individual index is out of bounds, whether or not an "
                    },
                    {
                      "type": "inlineCode",
                      "value": "IndexError"
                    },
                    {
                      "type": "text",
                      "value": " is   raised is undefined (e.g. "
                    },
                    {
                      "type": "inlineCode",
                      "value": "x[[], [123]]"
                    },
                    {
                      "type": "text",
                      "value": " with "
                    },
                    {
                      "type": "inlineCode",
                      "value": "123"
                    },
                    {
                      "type": "text",
                      "value": " being out of bounds)."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "When a "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "casting"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " error occurs during assignment (for example updating a   numerical array using a sequence of strings), the array being assigned   to may end up in an unpredictable partially updated state.   However, if any other error (such as an out of bounds index) occurs, the   array will remain unchanged."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The memory layout of an advanced indexing result is optimized for each   indexing operation and no particular memory order can be assumed."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "When using a subclass (especially one which manipulates its shape), the   default "
                    },
                    {
                      "type": "inlineCode",
                      "value": "ndarray.__setitem__"
                    },
                    {
                      "type": "text",
                      "value": " behaviour will call "
                    },
                    {
                      "type": "inlineCode",
                      "value": "__getitem__"
                    },
                    {
                      "type": "text",
                      "value": " for   "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "basic"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " indexing but not for "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "advanced"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " indexing. For such a subclass it may   be preferable to call "
                    },
                    {
                      "type": "inlineCode",
                      "value": "ndarray.__setitem__"
                    },
                    {
                      "type": "text",
                      "value": " with a "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "base class"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " ndarray   view on the data. This "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "must"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " be done if the subclasses "
                    },
                    {
                      "type": "inlineCode",
                      "value": "__getitem__"
                    },
                    {
                      "type": "text",
                      "value": " does   not return views."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Detailed notes",
      "type": "Section"
    }
  ],
  "content": {},
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null,
    "type": "Section"
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "see_also": [],
  "signature": {
    "type": "Signature",
    "value": null
  },
  "type": "DocBlob"
}