{
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "args": "Pierre Gerard-Marchant <pierregmcode@gmail.com>",
          "children": [],
          "name": "sectionauthor",
          "options": {},
          "type": "mystDirective",
          "value": ""
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "NumPy provides several functions to create arrays from tabular data. We focus here on the "
            },
            {
              "type": "inlineCode",
              "value": "~numpy.genfromtxt"
            },
            {
              "type": "text",
              "value": " function."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In a nutshell, "
            },
            {
              "type": "inlineCode",
              "value": "~numpy.genfromtxt"
            },
            {
              "type": "text",
              "value": " runs two main loops.  The first loop converts each line of the file in a sequence of strings.  The second loop converts each string to the appropriate data type.  This mechanism is slower than a single loop, but gives more flexibility.  In particular, "
            },
            {
              "type": "inlineCode",
              "value": "~numpy.genfromtxt"
            },
            {
              "type": "text",
              "value": " is able to take missing data into account, when other faster and simpler functions like "
            },
            {
              "type": "inlineCode",
              "value": "~numpy.loadtxt"
            },
            {
              "type": "text",
              "value": " cannot."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "note "
                }
              ],
              "type": "admonitionTitle"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "When giving examples, we will use the following conventions      "
                }
              ],
              "type": "paragraph"
            },
            {
              "type": "code",
              "value": ">>> import numpy as np\n>>> from io import StringIO"
            }
          ],
          "kind": "note",
          "type": "admonition"
        }
      ],
      "level": 0,
      "target": null,
      "title": "Importing data with :func:`~numpy.genfromtxt`",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The only mandatory argument of "
            },
            {
              "type": "inlineCode",
              "value": "~numpy.genfromtxt"
            },
            {
              "type": "text",
              "value": " is the source of the data. It can be a string, a list of strings, a generator or an open file-like object with a "
            },
            {
              "type": "inlineCode",
              "value": "read"
            },
            {
              "type": "text",
              "value": " method, for example, a file or  "
            },
            {
              "type": "inlineCode",
              "value": "io.StringIO"
            },
            {
              "type": "text",
              "value": " object. If a single string is provided, it is assumed to be the name of a local or remote file. If a list of strings or a generator returning strings is provided, each string is treated as one line in a file. When the URL of a remote file is passed, the file is automatically downloaded to the current directory and opened."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Recognized file types are text files and archives.  Currently, the function recognizes "
            },
            {
              "type": "inlineCode",
              "value": "gzip"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "bz2"
            },
            {
              "type": "text",
              "value": " ("
            },
            {
              "type": "inlineCode",
              "value": "bzip2"
            },
            {
              "type": "text",
              "value": ") archives.  The type of the archive is determined from the extension of the file: if the filename ends with "
            },
            {
              "type": "inlineCode",
              "value": "'.gz'"
            },
            {
              "type": "text",
              "value": ", a "
            },
            {
              "type": "inlineCode",
              "value": "gzip"
            },
            {
              "type": "text",
              "value": " archive is expected; if it ends with "
            },
            {
              "type": "inlineCode",
              "value": "'bz2'"
            },
            {
              "type": "text",
              "value": ", a "
            },
            {
              "type": "inlineCode",
              "value": "bzip2"
            },
            {
              "type": "text",
              "value": " archive is assumed."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Defining the input",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "Splitting the lines into columns",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Once the file is defined and open for reading, "
            },
            {
              "type": "inlineCode",
              "value": "~numpy.genfromtxt"
            },
            {
              "type": "text",
              "value": " splits each non-empty line into a sequence of strings.  Empty or commented lines are just skipped.  The "
            },
            {
              "type": "inlineCode",
              "value": "delimiter"
            },
            {
              "type": "text",
              "value": " keyword is used to define how the splitting should take place."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Quite often, a single character marks the separation between columns.  For example, comma-separated files (CSV) use a comma ("
            },
            {
              "type": "inlineCode",
              "value": ","
            },
            {
              "type": "text",
              "value": ") or a semicolon ("
            },
            {
              "type": "inlineCode",
              "value": ";"
            },
            {
              "type": "text",
              "value": ") as delimiter     "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> data = u\"1, 2, 3\\n4, 5, 6\"\n>>> np.genfromtxt(StringIO(data), delimiter=\",\")\narray([[1.,  2.,  3.],\n       [4.,  5.,  6.]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Another common separator is "
            },
            {
              "type": "inlineCode",
              "value": "\"\\t\""
            },
            {
              "type": "text",
              "value": ", the tabulation character.  However, we are not limited to a single character, any string will do.  By default, "
            },
            {
              "type": "inlineCode",
              "value": "~numpy.genfromtxt"
            },
            {
              "type": "text",
              "value": " assumes "
            },
            {
              "type": "inlineCode",
              "value": "delimiter=None"
            },
            {
              "type": "text",
              "value": ", meaning that the line is split along white spaces (including tabs) and that consecutive white spaces are considered as a single white space."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Alternatively, we may be dealing with a fixed-width file, where columns are defined as a given number of characters.  In that case, we need to set "
            },
            {
              "type": "inlineCode",
              "value": "delimiter"
            },
            {
              "type": "text",
              "value": " to a single integer (if all the columns have the same size) or to a sequence of integers (if columns can have different sizes)     "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> data = u\"  1  2  3\\n  4  5 67\\n890123  4\"\n>>> np.genfromtxt(StringIO(data), delimiter=3)\narray([[  1.,    2.,    3.],\n       [  4.,    5.,   67.],\n       [890.,  123.,    4.]])\n>>> data = u\"123456789\\n   4  7 9\\n   4567 9\"\n>>> np.genfromtxt(StringIO(data), delimiter=(4, 3, 2))\narray([[1234.,   567.,    89.],\n       [   4.,     7.,     9.],\n       [   4.,   567.,     9.]])"
        }
      ],
      "level": 2,
      "target": null,
      "title": "The ``delimiter`` argument",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "By default, when a line is decomposed into a series of strings, the individual entries are not stripped of leading nor trailing white spaces. This behavior can be overwritten by setting the optional argument "
            },
            {
              "type": "inlineCode",
              "value": "autostrip"
            },
            {
              "type": "text",
              "value": " to a value of "
            },
            {
              "type": "inlineCode",
              "value": "True"
            },
            {
              "type": "text",
              "value": "     "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> data = u\"1, abc , 2\\n 3, xxx, 4\"\n>>> # Without autostrip\n>>> np.genfromtxt(StringIO(data), delimiter=\",\", dtype=\"|U5\")\narray([['1', ' abc ', ' 2'],\n       ['3', ' xxx', ' 4']], dtype='<U5')\n>>> # With autostrip\n>>> np.genfromtxt(StringIO(data), delimiter=\",\", dtype=\"|U5\", autostrip=True)\narray([['1', 'abc', '2'],\n       ['3', 'xxx', '4']], dtype='<U5')"
        }
      ],
      "level": 2,
      "target": null,
      "title": "The ``autostrip`` argument",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The optional argument "
            },
            {
              "type": "inlineCode",
              "value": "comments"
            },
            {
              "type": "text",
              "value": " is used to define a character string that marks the beginning of a comment.  By default, "
            },
            {
              "type": "inlineCode",
              "value": "~numpy.genfromtxt"
            },
            {
              "type": "text",
              "value": " assumes "
            },
            {
              "type": "inlineCode",
              "value": "comments='#'"
            },
            {
              "type": "text",
              "value": ".  The comment marker may occur anywhere on the line.  Any character present after the comment marker(s) is simply ignored     "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> data = u\"\"\"#\n... # Skip me !\n... # Skip me too !\n... 1, 2\n... 3, 4\n... 5, 6 #This is the third line of the data\n... 7, 8\n... # And here comes the last line\n... 9, 0\n... \"\"\"\n>>> np.genfromtxt(StringIO(data), comments=\"#\", delimiter=\",\")\narray([[1., 2.],\n       [3., 4.],\n       [5., 6.],\n       [7., 8.],\n       [9., 0.]])"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "versionadded 1.7.0"
                }
              ],
              "type": "admonitionTitle"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "When "
                },
                {
                  "type": "inlineCode",
                  "value": "comments"
                },
                {
                  "type": "text",
                  "value": " is set to "
                },
                {
                  "type": "inlineCode",
                  "value": "None"
                },
                {
                  "type": "text",
                  "value": ", no lines are treated as comments."
                }
              ],
              "type": "paragraph"
            }
          ],
          "kind": "note",
          "type": "admonition"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "note "
                }
              ],
              "type": "admonitionTitle"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "There is one notable exception to this behavior: if the optional argument "
                },
                {
                  "type": "inlineCode",
                  "value": "names=True"
                },
                {
                  "type": "text",
                  "value": ", the first commented line will be examined for names."
                }
              ],
              "type": "paragraph"
            }
          ],
          "kind": "note",
          "type": "admonition"
        }
      ],
      "level": 2,
      "target": null,
      "title": "The ``comments`` argument",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "Skipping lines and choosing columns",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The presence of a header in the file can hinder data processing.  In that case, we need to use the "
            },
            {
              "type": "inlineCode",
              "value": "skip_header"
            },
            {
              "type": "text",
              "value": " optional argument.  The values of this argument must be an integer which corresponds to the number of lines to skip at the beginning of the file, before any other action is performed.  Similarly, we can skip the last "
            },
            {
              "type": "inlineCode",
              "value": "n"
            },
            {
              "type": "text",
              "value": " lines of the file by using the "
            },
            {
              "type": "inlineCode",
              "value": "skip_footer"
            },
            {
              "type": "text",
              "value": " attribute and giving it a value of "
            },
            {
              "type": "inlineCode",
              "value": "n"
            },
            {
              "type": "text",
              "value": "     "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> data = u\"\\n\".join(str(i) for i in range(10))\n>>> np.genfromtxt(StringIO(data),)\narray([0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.])\n>>> np.genfromtxt(StringIO(data),\n...               skip_header=3, skip_footer=5)\narray([3.,  4.])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "By default, "
            },
            {
              "type": "inlineCode",
              "value": "skip_header=0"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "skip_footer=0"
            },
            {
              "type": "text",
              "value": ", meaning that no lines are skipped."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "The ``skip_header`` and ``skip_footer`` arguments",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "In some cases, we are not interested in all the columns of the data but only a few of them.  We can select which columns to import with the "
            },
            {
              "type": "inlineCode",
              "value": "usecols"
            },
            {
              "type": "text",
              "value": " argument.  This argument accepts a single integer or a sequence of integers corresponding to the indices of the columns to import. Remember that by convention, the first column has an index of 0.  Negative integers behave the same as regular Python negative indexes."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "For example, if we want to import only the first and the last columns, we can use "
            },
            {
              "type": "inlineCode",
              "value": "usecols=(0, -1)"
            },
            {
              "type": "text",
              "value": "     "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> data = u\"1 2 3\\n4 5 6\"\n>>> np.genfromtxt(StringIO(data), usecols=(0, -1))\narray([[1.,  3.],\n       [4.,  6.]])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "If the columns have names, we can also select which columns to import by giving their name to the "
            },
            {
              "type": "inlineCode",
              "value": "usecols"
            },
            {
              "type": "text",
              "value": " argument, either as a sequence of strings or a comma-separated string     "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> data = u\"1 2 3\\n4 5 6\"\n>>> np.genfromtxt(StringIO(data),\n...               names=\"a, b, c\", usecols=(\"a\", \"c\"))\narray([(1., 3.), (4., 6.)], dtype=[('a', '<f8'), ('c', '<f8')])\n>>> np.genfromtxt(StringIO(data),\n...               names=\"a, b, c\", usecols=(\"a, c\"))\n    array([(1., 3.), (4., 6.)], dtype=[('a', '<f8'), ('c', '<f8')])"
        }
      ],
      "level": 2,
      "target": null,
      "title": "The ``usecols`` argument",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The main way to control how the sequences of strings we have read from the file are converted to other types is to set the "
            },
            {
              "type": "inlineCode",
              "value": "dtype"
            },
            {
              "type": "text",
              "value": " argument. Acceptable values for this argument are:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "a single type, such as "
                    },
                    {
                      "type": "inlineCode",
                      "value": "dtype=float"
                    },
                    {
                      "type": "text",
                      "value": ".   The output will be 2D with the given dtype, unless a name has been   associated with each column with the use of the "
                    },
                    {
                      "type": "inlineCode",
                      "value": "names"
                    },
                    {
                      "type": "text",
                      "value": " argument   (see below).  Note that "
                    },
                    {
                      "type": "inlineCode",
                      "value": "dtype=float"
                    },
                    {
                      "type": "text",
                      "value": " is the default for   "
                    },
                    {
                      "type": "inlineCode",
                      "value": "~numpy.genfromtxt"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "a sequence of types, such as "
                    },
                    {
                      "type": "inlineCode",
                      "value": "dtype=(int, float, float)"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "a comma-separated string, such as "
                    },
                    {
                      "type": "inlineCode",
                      "value": "dtype=\"i4,f8,|U3\""
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "a dictionary with two keys "
                    },
                    {
                      "type": "inlineCode",
                      "value": "'names'"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "type": "inlineCode",
                      "value": "'formats'"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "a sequence of tuples "
                    },
                    {
                      "type": "inlineCode",
                      "value": "(name, type)"
                    },
                    {
                      "type": "text",
                      "value": ", such as   "
                    },
                    {
                      "type": "inlineCode",
                      "value": "dtype=[('A', int), ('B', float)]"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "an existing "
                    },
                    {
                      "type": "inlineCode",
                      "value": "numpy.dtype"
                    },
                    {
                      "type": "text",
                      "value": " object."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "the special value "
                    },
                    {
                      "type": "inlineCode",
                      "value": "None"
                    },
                    {
                      "type": "text",
                      "value": ".   In that case, the type of the columns will be determined from the data   itself (see below)."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In all the cases but the first one, the output will be a 1D array with a structured dtype.  This dtype has as many fields as items in the sequence. The field names are defined with the "
            },
            {
              "type": "inlineCode",
              "value": "names"
            },
            {
              "type": "text",
              "value": " keyword."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "When "
            },
            {
              "type": "inlineCode",
              "value": "dtype=None"
            },
            {
              "type": "text",
              "value": ", the type of each column is determined iteratively from its data.  We start by checking whether a string can be converted to a boolean (that is, if the string matches "
            },
            {
              "type": "inlineCode",
              "value": "true"
            },
            {
              "type": "text",
              "value": " or "
            },
            {
              "type": "inlineCode",
              "value": "false"
            },
            {
              "type": "text",
              "value": " in lower cases); then whether it can be converted to an integer, then to a float, then to a complex and eventually to a string."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The option "
            },
            {
              "type": "inlineCode",
              "value": "dtype=None"
            },
            {
              "type": "text",
              "value": " is provided for convenience.  However, it is significantly slower than setting the dtype explicitly."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Choosing the data type",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "Setting the names",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "A natural approach when dealing with tabular data is to allocate a name to each column.  A first possibility is to use an explicit structured dtype, as mentioned previously     "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> data = StringIO(\"1 2 3\\n 4 5 6\")\n>>> np.genfromtxt(data, dtype=[(_, int) for _ in \"abc\"])\narray([(1, 2, 3), (4, 5, 6)],\n      dtype=[('a', '<i8'), ('b', '<i8'), ('c', '<i8')])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Another simpler possibility is to use the "
            },
            {
              "type": "inlineCode",
              "value": "names"
            },
            {
              "type": "text",
              "value": " keyword with a sequence of strings or a comma-separated string     "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> data = StringIO(\"1 2 3\\n 4 5 6\")\n>>> np.genfromtxt(data, names=\"A, B, C\")\narray([(1., 2., 3.), (4., 5., 6.)],\n      dtype=[('A', '<f8'), ('B', '<f8'), ('C', '<f8')])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In the example above, we used the fact that by default, "
            },
            {
              "type": "inlineCode",
              "value": "dtype=float"
            },
            {
              "type": "text",
              "value": ". By giving a sequence of names, we are forcing the output to a structured dtype."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "We may sometimes need to define the column names from the data itself.  In that case, we must use the "
            },
            {
              "type": "inlineCode",
              "value": "names"
            },
            {
              "type": "text",
              "value": " keyword with a value of "
            },
            {
              "type": "inlineCode",
              "value": "True"
            },
            {
              "type": "text",
              "value": ".  The names will then be read from the first line (after the "
            },
            {
              "type": "inlineCode",
              "value": "skip_header"
            },
            {
              "type": "text",
              "value": " ones), even if the line is commented out     "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> data = StringIO(\"So it goes\\n#a b c\\n1 2 3\\n 4 5 6\")\n>>> np.genfromtxt(data, skip_header=1, names=True)\narray([(1., 2., 3.), (4., 5., 6.)],\n      dtype=[('a', '<f8'), ('b', '<f8'), ('c', '<f8')])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The default value of "
            },
            {
              "type": "inlineCode",
              "value": "names"
            },
            {
              "type": "text",
              "value": " is "
            },
            {
              "type": "inlineCode",
              "value": "None"
            },
            {
              "type": "text",
              "value": ".  If we give any other value to the keyword, the new names will overwrite the field names we may have defined with the dtype     "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> data = StringIO(\"1 2 3\\n 4 5 6\")\n>>> ndtype=[('a',int), ('b', float), ('c', int)]\n>>> names = [\"A\", \"B\", \"C\"]\n>>> np.genfromtxt(data, names=names, dtype=ndtype)\narray([(1, 2., 3), (4, 5., 6)],\n      dtype=[('A', '<i8'), ('B', '<f8'), ('C', '<i8')])"
        }
      ],
      "level": 2,
      "target": null,
      "title": "The ``names`` argument",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "If "
            },
            {
              "type": "inlineCode",
              "value": "names=None"
            },
            {
              "type": "text",
              "value": " but a structured dtype is expected, names are defined with the standard NumPy default of "
            },
            {
              "type": "inlineCode",
              "value": "\"f%i\""
            },
            {
              "type": "text",
              "value": ", yielding names like "
            },
            {
              "type": "inlineCode",
              "value": "f0"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": "f1"
            },
            {
              "type": "text",
              "value": " and so forth     "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> data = StringIO(\"1 2 3\\n 4 5 6\")\n>>> np.genfromtxt(data, dtype=(int, float, int))\narray([(1, 2., 3), (4, 5., 6)],\n      dtype=[('f0', '<i8'), ('f1', '<f8'), ('f2', '<i8')])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In the same way, if we don't give enough names to match the length of the dtype, the missing names will be defined with this default template     "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> data = StringIO(\"1 2 3\\n 4 5 6\")\n>>> np.genfromtxt(data, dtype=(int, float, int), names=\"a\")\narray([(1, 2., 3), (4, 5., 6)],\n      dtype=[('a', '<i8'), ('f0', '<f8'), ('f1', '<i8')])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "We can overwrite this default with the "
            },
            {
              "type": "inlineCode",
              "value": "defaultfmt"
            },
            {
              "type": "text",
              "value": " argument, that takes any format string     "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> data = StringIO(\"1 2 3\\n 4 5 6\")\n>>> np.genfromtxt(data, dtype=(int, float, int), defaultfmt=\"var_%02i\")\narray([(1, 2., 3), (4, 5., 6)],\n      dtype=[('var_00', '<i8'), ('var_01', '<f8'), ('var_02', '<i8')])"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "note "
                }
              ],
              "type": "admonitionTitle"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "We need to keep in mind that "
                },
                {
                  "type": "inlineCode",
                  "value": "defaultfmt"
                },
                {
                  "type": "text",
                  "value": " is used only if some names are expected but not defined."
                }
              ],
              "type": "paragraph"
            }
          ],
          "kind": "note",
          "type": "admonition"
        }
      ],
      "level": 2,
      "target": null,
      "title": "The ``defaultfmt`` argument",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "NumPy arrays with a structured dtype can also be viewed as "
            },
            {
              "type": "inlineCode",
              "value": "~numpy.recarray"
            },
            {
              "type": "text",
              "value": ", where a field can be accessed as if it were an attribute.  For that reason, we may need to make sure that the field name doesn't contain any space or invalid character, or that it does not correspond to the name of a standard attribute (like "
            },
            {
              "type": "inlineCode",
              "value": "size"
            },
            {
              "type": "text",
              "value": " or "
            },
            {
              "type": "inlineCode",
              "value": "shape"
            },
            {
              "type": "text",
              "value": "), which would confuse the interpreter.  "
            },
            {
              "type": "inlineCode",
              "value": "~numpy.genfromtxt"
            },
            {
              "type": "text",
              "value": " accepts three optional arguments that provide a finer control on the names:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "dd": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "Gives a string combining all the characters that must be deleted from       the name. By default, invalid characters are       "
                        },
                        {
                          "type": "inlineCode",
                          "value": "~!@#$%^&*()-=+~\\|]}[{';:\n      /?.>,<"
                        },
                        {
                          "type": "text",
                          "value": "."
                        }
                      ],
                      "type": "paragraph"
                    }
                  ],
                  "dt": {
                    "children": [
                      {
                        "type": "inlineCode",
                        "value": "deletechars"
                      }
                    ],
                    "type": "paragraph"
                  },
                  "type": "DefListItem"
                },
                {
                  "dd": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "Gives a list of the names to exclude, such as "
                        },
                        {
                          "type": "inlineCode",
                          "value": "return"
                        },
                        {
                          "type": "text",
                          "value": ", "
                        },
                        {
                          "type": "inlineCode",
                          "value": "file"
                        },
                        {
                          "type": "text",
                          "value": ",       "
                        },
                        {
                          "type": "inlineCode",
                          "value": "print"
                        },
                        {
                          "type": "text",
                          "value": "...  If one of the input name is part of this list, an       underscore character ("
                        },
                        {
                          "type": "inlineCode",
                          "value": "'_'"
                        },
                        {
                          "type": "text",
                          "value": ") will be appended to it."
                        }
                      ],
                      "type": "paragraph"
                    }
                  ],
                  "dt": {
                    "children": [
                      {
                        "type": "inlineCode",
                        "value": "excludelist"
                      }
                    ],
                    "type": "paragraph"
                  },
                  "type": "DefListItem"
                },
                {
                  "dd": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "Whether the names should be case-sensitive ("
                        },
                        {
                          "type": "inlineCode",
                          "value": "case_sensitive=True"
                        },
                        {
                          "type": "text",
                          "value": "),       converted to upper case ("
                        },
                        {
                          "type": "inlineCode",
                          "value": "case_sensitive=False"
                        },
                        {
                          "type": "text",
                          "value": " or       "
                        },
                        {
                          "type": "inlineCode",
                          "value": "case_sensitive='upper'"
                        },
                        {
                          "type": "text",
                          "value": ") or to lower case       ("
                        },
                        {
                          "type": "inlineCode",
                          "value": "case_sensitive='lower'"
                        },
                        {
                          "type": "text",
                          "value": ")."
                        }
                      ],
                      "type": "paragraph"
                    }
                  ],
                  "dt": {
                    "children": [
                      {
                        "type": "inlineCode",
                        "value": "case_sensitive"
                      }
                    ],
                    "type": "paragraph"
                  },
                  "type": "DefListItem"
                }
              ],
              "type": "DefList"
            }
          ],
          "type": "blockquote"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Validating names",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "Tweaking the conversion",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Usually, defining a dtype is sufficient to define how the sequence of strings must be converted.  However, some additional control may sometimes be required.  For example, we may want to make sure that a date in a format "
            },
            {
              "type": "inlineCode",
              "value": "YYYY/MM/DD"
            },
            {
              "type": "text",
              "value": " is converted to a "
            },
            {
              "type": "inlineCode",
              "value": "~datetime.datetime"
            },
            {
              "type": "text",
              "value": " object, or that a string like "
            },
            {
              "type": "inlineCode",
              "value": "xx%"
            },
            {
              "type": "text",
              "value": " is properly converted to a float between 0 and 1.  In such cases, we should define conversion functions with the "
            },
            {
              "type": "inlineCode",
              "value": "converters"
            },
            {
              "type": "text",
              "value": " arguments."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The value of this argument is typically a dictionary with column indices or column names as keys and a conversion functions as values.  These conversion functions can either be actual functions or lambda functions. In any case, they should accept only a string as input and output only a single element of the wanted type."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In the following example, the second column is converted from as string representing a percentage to a float between 0 and 1     "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> convertfunc = lambda x: float(x.strip(b\"%\"))/100.\n>>> data = u\"1, 2.3%, 45.\\n6, 78.9%, 0\"\n>>> names = (\"i\", \"p\", \"n\")\n>>> # General case .....\n>>> np.genfromtxt(StringIO(data), delimiter=\",\", names=names)\narray([(1., nan, 45.), (6., nan, 0.)],\n      dtype=[('i', '<f8'), ('p', '<f8'), ('n', '<f8')])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "We need to keep in mind that by default, "
            },
            {
              "type": "inlineCode",
              "value": "dtype=float"
            },
            {
              "type": "text",
              "value": ".  A float is therefore expected for the second column.  However, the strings "
            },
            {
              "type": "inlineCode",
              "value": "' 2.3%'"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "' 78.9%'"
            },
            {
              "type": "text",
              "value": " cannot be converted to float and we end up having "
            },
            {
              "type": "inlineCode",
              "value": "np.nan"
            },
            {
              "type": "text",
              "value": " instead.  Let's now use a converter     "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> # Converted case ...\n>>> np.genfromtxt(StringIO(data), delimiter=\",\", names=names,\n...               converters={1: convertfunc})\narray([(1., 0.023, 45.), (6., 0.789, 0.)],\n      dtype=[('i', '<f8'), ('p', '<f8'), ('n', '<f8')])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The same results can be obtained by using the name of the second column ("
            },
            {
              "type": "inlineCode",
              "value": "\"p\""
            },
            {
              "type": "text",
              "value": ") as key instead of its index (1)     "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> # Using a name for the converter ...\n>>> np.genfromtxt(StringIO(data), delimiter=\",\", names=names,\n...               converters={\"p\": convertfunc})\narray([(1., 0.023, 45.), (6., 0.789, 0.)],\n      dtype=[('i', '<f8'), ('p', '<f8'), ('n', '<f8')])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Converters can also be used to provide a default for missing entries.  In the following example, the converter "
            },
            {
              "type": "inlineCode",
              "value": "convert"
            },
            {
              "type": "text",
              "value": " transforms a stripped string into the corresponding float or into -999 if the string is empty. We need to explicitly strip the string from white spaces as it is not done by default     "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> data = u\"1, , 3\\n 4, 5, 6\"\n>>> convert = lambda x: float(x.strip() or -999)\n>>> np.genfromtxt(StringIO(data), delimiter=\",\",\n...               converters={1: convert})\narray([[   1., -999.,    3.],\n       [   4.,    5.,    6.]])"
        }
      ],
      "level": 2,
      "target": null,
      "title": "The ``converters`` argument",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Some entries may be missing in the dataset we are trying to import.  In a previous example, we used a converter to transform an empty string into a float.  However, user-defined converters may rapidly become cumbersome to manage."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The "
            },
            {
              "type": "inlineCode",
              "value": "~numpy.genfromtxt"
            },
            {
              "type": "text",
              "value": " function provides two other complementary mechanisms: the "
            },
            {
              "type": "inlineCode",
              "value": "missing_values"
            },
            {
              "type": "text",
              "value": " argument is used to recognize missing data and a second argument, "
            },
            {
              "type": "inlineCode",
              "value": "filling_values"
            },
            {
              "type": "text",
              "value": ", is used to process these missing data."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Using missing and filling values",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "By default, any empty string is marked as missing.  We can also consider more complex strings, such as "
            },
            {
              "type": "inlineCode",
              "value": "\"N/A\""
            },
            {
              "type": "text",
              "value": " or "
            },
            {
              "type": "inlineCode",
              "value": "\"???\""
            },
            {
              "type": "text",
              "value": " to represent missing or invalid data.  The "
            },
            {
              "type": "inlineCode",
              "value": "missing_values"
            },
            {
              "type": "text",
              "value": " argument accepts three kinds of values:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "dd": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "This string will be used as the marker for missing data for all the       columns"
                        }
                      ],
                      "type": "paragraph"
                    }
                  ],
                  "dt": {
                    "children": [
                      {
                        "type": "text",
                        "value": "a string or a comma-separated string"
                      }
                    ],
                    "type": "paragraph"
                  },
                  "type": "DefListItem"
                },
                {
                  "dd": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "In that case, each item is associated to a column, in order."
                        }
                      ],
                      "type": "paragraph"
                    }
                  ],
                  "dt": {
                    "children": [
                      {
                        "type": "text",
                        "value": "a sequence of strings"
                      }
                    ],
                    "type": "paragraph"
                  },
                  "type": "DefListItem"
                },
                {
                  "dd": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "Values of the dictionary are strings or sequence of strings.  The       corresponding keys can be column indices (integers) or column names       (strings). In addition, the special key "
                        },
                        {
                          "type": "inlineCode",
                          "value": "None"
                        },
                        {
                          "type": "text",
                          "value": " can be used to       define a default applicable to all columns."
                        }
                      ],
                      "type": "paragraph"
                    }
                  ],
                  "dt": {
                    "children": [
                      {
                        "type": "text",
                        "value": "a dictionary"
                      }
                    ],
                    "type": "paragraph"
                  },
                  "type": "DefListItem"
                }
              ],
              "type": "DefList"
            }
          ],
          "type": "blockquote"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``missing_values``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "We know how to recognize missing data, but we still need to provide a value for these missing entries.  By default, this value is determined from the expected dtype according to this table:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "=============  ============== Expected type  Default =============  ============== "
            },
            {
              "type": "inlineCode",
              "value": "bool"
            },
            {
              "type": "text",
              "value": "       "
            },
            {
              "type": "inlineCode",
              "value": "False"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "int"
            },
            {
              "type": "text",
              "value": "        "
            },
            {
              "type": "inlineCode",
              "value": "-1"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "float"
            },
            {
              "type": "text",
              "value": "      "
            },
            {
              "type": "inlineCode",
              "value": "np.nan"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "complex"
            },
            {
              "type": "text",
              "value": "    "
            },
            {
              "type": "inlineCode",
              "value": "np.nan+0j"
            },
            {
              "type": "text",
              "value": " "
            },
            {
              "type": "inlineCode",
              "value": "string"
            },
            {
              "type": "text",
              "value": "     "
            },
            {
              "type": "inlineCode",
              "value": "'???'"
            },
            {
              "type": "text",
              "value": " =============  =============="
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "We can get a finer control on the conversion of missing values with the "
            },
            {
              "type": "inlineCode",
              "value": "filling_values"
            },
            {
              "type": "text",
              "value": " optional argument.  Like "
            },
            {
              "type": "inlineCode",
              "value": "missing_values"
            },
            {
              "type": "text",
              "value": ", this argument accepts different kind of values:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "dd": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "This will be the default for all columns"
                        }
                      ],
                      "type": "paragraph"
                    }
                  ],
                  "dt": {
                    "children": [
                      {
                        "type": "text",
                        "value": "a single value"
                      }
                    ],
                    "type": "paragraph"
                  },
                  "type": "DefListItem"
                },
                {
                  "dd": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "Each entry will be the default for the corresponding column"
                        }
                      ],
                      "type": "paragraph"
                    }
                  ],
                  "dt": {
                    "children": [
                      {
                        "type": "text",
                        "value": "a sequence of values"
                      }
                    ],
                    "type": "paragraph"
                  },
                  "type": "DefListItem"
                },
                {
                  "dd": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "Each key can be a column index or a column name, and the       corresponding value should be a single object.  We can use the       special key "
                        },
                        {
                          "type": "inlineCode",
                          "value": "None"
                        },
                        {
                          "type": "text",
                          "value": " to define a default for all columns."
                        }
                      ],
                      "type": "paragraph"
                    }
                  ],
                  "dt": {
                    "children": [
                      {
                        "type": "text",
                        "value": "a dictionary"
                      }
                    ],
                    "type": "paragraph"
                  },
                  "type": "DefListItem"
                }
              ],
              "type": "DefList"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In the following example, we suppose that the missing values are flagged with "
            },
            {
              "type": "inlineCode",
              "value": "\"N/A\""
            },
            {
              "type": "text",
              "value": " in the first column and by "
            },
            {
              "type": "inlineCode",
              "value": "\"???\""
            },
            {
              "type": "text",
              "value": " in the third column. We wish to transform these missing values to 0 if they occur in the first and second column, and to -999 if they occur in the last column      "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> data = u\"N/A, 2, 3\\n4, ,???\"\n>>> kwargs = dict(delimiter=\",\",\n...               dtype=int,\n...               names=\"a,b,c\",\n...               missing_values={0:\"N/A\", 'b':\" \", 2:\"???\"},\n...               filling_values={0:0, 'b':0, 2:-999})\n>>> np.genfromtxt(StringIO(data), **kwargs)\narray([(0, 2, 3), (4, 0, -999)],\n      dtype=[('a', '<i8'), ('b', '<i8'), ('c', '<i8')])"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``filling_values``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "We may also want to keep track of the occurrence of missing data by constructing a boolean mask, with "
            },
            {
              "type": "inlineCode",
              "value": "True"
            },
            {
              "type": "text",
              "value": " entries where data was missing and "
            },
            {
              "type": "inlineCode",
              "value": "False"
            },
            {
              "type": "text",
              "value": " otherwise.  To do that, we just have to set the optional argument "
            },
            {
              "type": "inlineCode",
              "value": "usemask"
            },
            {
              "type": "text",
              "value": " to "
            },
            {
              "type": "inlineCode",
              "value": "True"
            },
            {
              "type": "text",
              "value": " (the default is "
            },
            {
              "type": "inlineCode",
              "value": "False"
            },
            {
              "type": "text",
              "value": ").  The output array will then be a "
            },
            {
              "type": "inlineCode",
              "value": "~numpy.ma.MaskedArray"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "mystComment",
          "value": ".. unpack=None, loose=True, invalid_raise=True)"
        }
      ],
      "level": 2,
      "target": null,
      "title": "``usemask``",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "In addition to "
            },
            {
              "type": "inlineCode",
              "value": "~numpy.genfromtxt"
            },
            {
              "type": "text",
              "value": ", the "
            },
            {
              "type": "inlineCode",
              "value": "numpy.lib.npyio"
            },
            {
              "type": "text",
              "value": " module provides several convenience functions derived from "
            },
            {
              "type": "inlineCode",
              "value": "~numpy.genfromtxt"
            },
            {
              "type": "text",
              "value": ".  These functions work the same way as the original, but they have different default values."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "dd": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Returns a standard "
                    },
                    {
                      "type": "inlineCode",
                      "value": "numpy.recarray"
                    },
                    {
                      "type": "text",
                      "value": " (if "
                    },
                    {
                      "type": "inlineCode",
                      "value": "usemask=False"
                    },
                    {
                      "type": "text",
                      "value": ") or a    "
                    },
                    {
                      "type": "inlineCode",
                      "value": "numpy.ma.mrecords.MaskedRecords"
                    },
                    {
                      "type": "text",
                      "value": " array (if "
                    },
                    {
                      "type": "inlineCode",
                      "value": "usemaske=True"
                    },
                    {
                      "type": "text",
                      "value": ").  The    default dtype is "
                    },
                    {
                      "type": "inlineCode",
                      "value": "dtype=None"
                    },
                    {
                      "type": "text",
                      "value": ", meaning that the types of each column    will be automatically determined."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "dt": {
                "children": [
                  {
                    "type": "inlineCode",
                    "value": "numpy.lib.npyio.recfromtxt"
                  }
                ],
                "type": "paragraph"
              },
              "type": "DefListItem"
            },
            {
              "dd": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Like "
                    },
                    {
                      "type": "inlineCode",
                      "value": "numpy.lib.npyio.recfromtxt"
                    },
                    {
                      "type": "text",
                      "value": ", but with a default "
                    },
                    {
                      "type": "inlineCode",
                      "value": "delimiter=\",\""
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "dt": {
                "children": [
                  {
                    "type": "inlineCode",
                    "value": "numpy.lib.npyio.recfromcsv"
                  }
                ],
                "type": "paragraph"
              },
              "type": "DefListItem"
            }
          ],
          "type": "DefList"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Shortcut functions",
      "type": "Section"
    }
  ],
  "content": {},
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null,
    "type": "Section"
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "see_also": [],
  "signature": {
    "type": "Signature",
    "value": null
  },
  "type": "DocBlob"
}