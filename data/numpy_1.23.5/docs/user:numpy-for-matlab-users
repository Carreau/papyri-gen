{
  "aliases": [],
  "arbitrary": [
    {
      "children": [],
      "level": 0,
      "target": "numpy-for-matlab-users",
      "title": "NumPy for MATLAB users",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "MATLAB\u00ae and NumPy have a lot in common, but NumPy was created to work with Python, not to be a MATLAB clone.  This guide will help MATLAB users get started with NumPy."
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "html",
          "children": [],
          "name": "raw",
          "options": {},
          "type": "mystDirective",
          "value": "<style>\ntable.docutils td { border: solid 1px #ccc; }\n</style>"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Introduction",
      "type": "Section"
    },
    {
      "children": [
        {
          "args": "",
          "children": [],
          "name": "list-table",
          "options": {
            "class": "docutils"
          },
          "type": "mystDirective",
          "value": "* - In MATLAB, the basic type, even for scalars, is a\n    multidimensional array. Array assignments in MATLAB are stored as\n    2D arrays of double precision floating point numbers, unless you\n    specify the number of dimensions and type.  Operations on the 2D\n    instances of these arrays are modeled on matrix operations in\n    linear algebra.\n\n  - In NumPy, the basic type is a multidimensional ``array``.  Array\n    assignments in NumPy are usually stored as :ref:`n-dimensional arrays<arrays>` with the\n    minimum type required to hold the objects in sequence, unless you\n    specify the number of dimensions and type. NumPy performs\n    operations element-by-element, so multiplying 2D arrays with\n    ``*`` is not a matrix multiplication -- it's an\n    element-by-element multiplication. (The ``@`` operator, available\n    since Python 3.5, can be used for conventional matrix\n    multiplication.)\n\n* - MATLAB numbers indices from 1; ``a(1)`` is the first element.\n    :ref:`See note INDEXING <numpy-for-matlab-users.notes>`\n  - NumPy, like Python, numbers indices from 0; ``a[0]`` is the first\n    element.\n\n* - MATLAB's scripting language was created for linear algebra so the\n    syntax for some array manipulations is more compact than\n    NumPy's. On the other hand, the API for adding GUIs and creating\n    full-fledged applications is more or less an afterthought.\n  - NumPy is  based on Python, a\n    general-purpose language.  The advantage to NumPy\n    is access to Python libraries including: `SciPy\n    <https://www.scipy.org/>`_, `Matplotlib <https://matplotlib.org/>`_,\n    `Pandas <https://pandas.pydata.org/>`_, `OpenCV <https://opencv.org/>`_,\n    and more. In addition, Python is often `embedded as a scripting language\n    <https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language>`_\n    in other software, allowing NumPy to be used there too.\n\n* - MATLAB array slicing uses pass-by-value semantics, with a lazy\n    copy-on-write scheme to prevent creating copies until they are\n    needed. Slicing operations copy parts of the array.\n  - NumPy array slicing uses pass-by-reference, that does not copy\n    the arguments. Slicing operations are views into an array."
        }
      ],
      "level": 1,
      "target": null,
      "title": "Some key differences",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The table below gives rough equivalents for some common MATLAB expressions. These are similar expressions, not equivalents. For details, see the "
            },
            {
              "type": "inlineCode",
              "value": "documentation<reference>"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In the table below, it is assumed that you have executed the following commands in Python:"
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": "import numpy as np\nfrom scipy import io, integrate, linalg, signal\nfrom scipy.sparse.linalg import cg, eigs"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Also assume below that if the Notes talk about \"matrix\" that the arguments are two-dimensional entities."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Rough equivalents",
      "type": "Section"
    },
    {
      "children": [
        {
          "args": "",
          "children": [],
          "name": "list-table",
          "options": {
            "header-rows": "1"
          },
          "type": "mystDirective",
          "value": "* - MATLAB\n  - NumPy\n  - Notes\n\n* - ``help func``\n  - ``info(func)`` or ``help(func)`` or ``func?`` (in IPython)\n  - get help on the function *func*\n\n* - ``which func``\n  - :ref:`see note HELP <numpy-for-matlab-users.notes>`\n  - find out where *func* is defined\n\n* - ``type func``\n  - ``np.source(func)`` or ``func??`` (in IPython)\n  - print source for *func* (if not a native function)\n\n* - ``% comment``\n  - ``# comment``\n  - comment a line of code with the text ``comment``\n\n* - ::\n\n      for i=1:3\n          fprintf('%i\\n',i)\n      end\n\n  - ::\n\n      for i in range(1, 4):\n         print(i)\n\n  - use a for-loop to print the numbers 1, 2, and 3 using :py:class:`range <range>`\n\n* - ``a && b``\n  - ``a and b``\n  - short-circuiting logical AND operator (:ref:`Python native operator <python:boolean>`);\n    scalar arguments only\n\n* - ``a || b``\n  - ``a or b``\n  - short-circuiting logical OR operator (:ref:`Python native operator <python:boolean>`);\n    scalar arguments only\n\n* - .. code:: matlab\n\n     >> 4 == 4\n     ans = 1\n     >> 4 == 5\n     ans = 0\n\n  - ::\n\n     >>> 4 == 4\n     True\n     >>> 4 == 5\n     False\n\n  - The :ref:`boolean objects <python:bltin-boolean-values>`\n    in Python are ``True`` and ``False``, as opposed to MATLAB\n    logical types of ``1`` and ``0``.\n\n* - .. code:: matlab\n\n      a=4\n      if a==4\n          fprintf('a = 4\\n')\n      elseif a==5\n          fprintf('a = 5\\n')\n      end\n\n  - ::\n\n      a = 4\n      if a == 4:\n          print('a = 4')\n      elif a == 5:\n          print('a = 5')\n\n  - create an if-else statement to check if ``a`` is 4 or 5 and print result\n\n* - ``1*i``, ``1*j``,  ``1i``, ``1j``\n  - ``1j``\n  - complex numbers\n\n* - ``eps``\n  - ``np.finfo(float).eps`` or ``np.spacing(1)``\n  - distance from 1 to the next larger representable real number in double\n    precision\n\n* - ``load data.mat``\n  - ``io.loadmat('data.mat')``\n  - Load MATLAB variables saved to the file ``data.mat``. (Note: When saving arrays to\n    ``data.mat`` in MATLAB/Octave, use a recent binary format. :func:`scipy.io.loadmat`\n    will create a dictionary with the saved arrays and further information.)\n\n* - ``ode45``\n  - ``integrate.solve_ivp(f)``\n  - integrate an ODE with Runge-Kutta 4,5\n\n* - ``ode15s``\n  - ``integrate.solve_ivp(f, method='BDF')``\n  - integrate an ODE with BDF method"
        }
      ],
      "level": 2,
      "target": null,
      "title": "General purpose equivalents",
      "type": "Section"
    },
    {
      "children": [
        {
          "args": "",
          "children": [],
          "name": "list-table",
          "options": {
            "header-rows": "1"
          },
          "type": "mystDirective",
          "value": "* - MATLAB\n  - NumPy\n  - Notes\n\n* - ``ndims(a)``\n  - ``np.ndim(a)`` or ``a.ndim``\n  - number of dimensions of array ``a``\n\n* - ``numel(a)``\n  - ``np.size(a)`` or ``a.size``\n  - number of elements of array ``a``\n\n* - ``size(a)``\n  - ``np.shape(a)`` or ``a.shape``\n  - \"size\" of array ``a``\n\n* - ``size(a,n)``\n  - ``a.shape[n-1]``\n  - get the number of elements of the n-th dimension of array ``a``. (Note\n    that MATLAB uses 1 based indexing while Python uses 0 based indexing,\n    See note :ref:`INDEXING <numpy-for-matlab-users.notes>`)\n\n* - ``[ 1 2 3; 4 5 6 ]``\n  - ``np.array([[1., 2., 3.], [4., 5., 6.]])``\n  - define a 2x3 2D array\n\n* - ``[ a b; c d ]``\n  - ``np.block([[a, b], [c, d]])``\n  - construct a matrix from blocks ``a``, ``b``, ``c``, and ``d``\n\n* - ``a(end)``\n  - ``a[-1]``\n  - access last element in MATLAB vector (1xn or nx1) or 1D NumPy array\n    ``a`` (length n)\n\n* - ``a(2,5)``\n  - ``a[1, 4]``\n  - access element in second row, fifth column in 2D array ``a``\n\n* - ``a(2,:)``\n  - ``a[1]`` or  ``a[1, :]``\n  - entire second row of 2D array ``a``\n\n* - ``a(1:5,:)``\n  - ``a[0:5]`` or ``a[:5]`` or ``a[0:5, :]``\n  - first 5 rows of 2D array ``a``\n\n* - ``a(end-4:end,:)``\n  - ``a[-5:]``\n  - last 5 rows of 2D array ``a``\n\n* - ``a(1:3,5:9)``\n  - ``a[0:3, 4:9]``\n  - The first through third rows and fifth through ninth columns of a 2D array, ``a``.\n\n* - ``a([2,4,5],[1,3])``\n  - ``a[np.ix_([1, 3, 4], [0, 2])]``\n  - rows 2,4 and 5 and columns 1 and 3.  This allows the matrix to be\n    modified, and doesn't require a regular slice.\n\n* - ``a(3:2:21,:)``\n  - ``a[2:21:2,:]``\n  - every other row of ``a``, starting with the third and going to the\n    twenty-first\n\n* - ``a(1:2:end,:)``\n  - ``a[::2, :]``\n  - every other row of ``a``, starting with the first\n\n* - ``a(end:-1:1,:)``  or ``flipud(a)``\n  -  ``a[::-1,:]``\n  - ``a`` with rows in reverse order\n\n* - ``a([1:end 1],:)``\n  -  ``a[np.r_[:len(a),0]]``\n  - ``a`` with copy of the first row appended to the end\n\n* - ``a.'``\n  - ``a.transpose()`` or ``a.T``\n  - transpose of ``a``\n\n* - ``a'``\n  - ``a.conj().transpose()`` or ``a.conj().T``\n  - conjugate transpose of ``a``\n\n* - ``a * b``\n  - ``a @ b``\n  - matrix multiply\n\n* - ``a .* b``\n  - ``a * b``\n  - element-wise multiply\n\n* - ``a./b``\n  - ``a/b``\n  - element-wise divide\n\n* - ``a.^3``\n  - ``a**3``\n  - element-wise exponentiation\n\n* - ``(a > 0.5)``\n  - ``(a > 0.5)``\n  - matrix whose i,jth element is (a_ij > 0.5).  The MATLAB result is an\n    array of logical values 0 and 1.  The NumPy result is an array of the boolean\n    values ``False`` and ``True``.\n\n* - ``find(a > 0.5)``\n  - ``np.nonzero(a > 0.5)``\n  - find the indices where (``a`` > 0.5)\n\n* - ``a(:,find(v > 0.5))``\n  - ``a[:,np.nonzero(v > 0.5)[0]]``\n  - extract the columns of ``a`` where vector v > 0.5\n\n* - ``a(:,find(v>0.5))``\n  - ``a[:, v.T > 0.5]``\n  - extract the columns of ``a`` where column vector v > 0.5\n\n* - ``a(a<0.5)=0``\n  - ``a[a < 0.5]=0``\n  - ``a`` with elements less than 0.5 zeroed out\n\n* - ``a .* (a>0.5)``\n  - ``a * (a > 0.5)``\n  - ``a`` with elements less than 0.5 zeroed out\n\n* - ``a(:) = 3``\n  - ``a[:] = 3``\n  - set all values to the same scalar value\n\n* - ``y=x``\n  - ``y = x.copy()``\n  - NumPy assigns by reference\n\n* - ``y=x(2,:)``\n  - ``y = x[1, :].copy()``\n  - NumPy slices are by reference\n\n* - ``y=x(:)``\n  - ``y = x.flatten()``\n  - turn array into vector (note that this forces a copy). To obtain the\n    same data ordering as in MATLAB, use ``x.flatten('F')``.\n\n* - ``1:10``\n  - ``np.arange(1., 11.)`` or ``np.r_[1.:11.]`` or  ``np.r_[1:10:10j]``\n  - create an increasing vector (see note :ref:`RANGES\n    <numpy-for-matlab-users.notes>`)\n\n* - ``0:9``\n  - ``np.arange(10.)`` or  ``np.r_[:10.]`` or  ``np.r_[:9:10j]``\n  - create an increasing vector (see note :ref:`RANGES\n    <numpy-for-matlab-users.notes>`)\n\n* - ``[1:10]'``\n  - ``np.arange(1.,11.)[:, np.newaxis]``\n  - create a column vector\n\n* - ``zeros(3,4)``\n  - ``np.zeros((3, 4))``\n  - 3x4 two-dimensional array full of 64-bit floating point zeros\n\n* - ``zeros(3,4,5)``\n  - ``np.zeros((3, 4, 5))``\n  - 3x4x5 three-dimensional array full of 64-bit floating point zeros\n\n* - ``ones(3,4)``\n  - ``np.ones((3, 4))``\n  - 3x4 two-dimensional array full of 64-bit floating point ones\n\n* - ``eye(3)``\n  - ``np.eye(3)``\n  - 3x3 identity matrix\n\n* - ``diag(a)``\n  - ``np.diag(a)``\n  - returns a vector of the diagonal elements of 2D array, ``a``\n\n* - ``diag(v,0)``\n  - ``np.diag(v, 0)``\n  - returns a square diagonal matrix whose nonzero values are the elements of\n    vector, ``v``\n\n* - .. code:: matlab\n\n      rng(42,'twister')\n      rand(3,4)\n\n  - ::\n\n      from numpy.random import default_rng\n      rng = default_rng(42)\n      rng.random(3, 4)\n\n    or older version: ``random.rand((3, 4))``\n\n  - generate a random 3x4 array with default random number generator and\n    seed = 42\n\n* - ``linspace(1,3,4)``\n  - ``np.linspace(1,3,4)``\n  - 4 equally spaced samples between 1 and 3, inclusive\n\n* - ``[x,y]=meshgrid(0:8,0:5)``\n  - ``np.mgrid[0:9.,0:6.]`` or ``np.meshgrid(r_[0:9.],r_[0:6.])``\n  - two 2D arrays: one of x values, the other of y values\n\n* -\n  - ``ogrid[0:9.,0:6.]`` or ``np.ix_(np.r_[0:9.],np.r_[0:6.]``\n  - the best way to eval functions on a grid\n\n* - ``[x,y]=meshgrid([1,2,4],[2,4,5])``\n  - ``np.meshgrid([1,2,4],[2,4,5])``\n  -\n\n* -\n  - ``np.ix_([1,2,4],[2,4,5])``\n  - the best way to eval functions on a grid\n\n* - ``repmat(a, m, n)``\n  - ``np.tile(a, (m, n))``\n  - create m by n copies of ``a``\n\n* - ``[a b]``\n  - ``np.concatenate((a,b),1)`` or ``np.hstack((a,b))`` or\n    ``np.column_stack((a,b))`` or ``np.c_[a,b]``\n  - concatenate columns of ``a`` and ``b``\n\n* - ``[a; b]``\n  - ``np.concatenate((a,b))`` or ``np.vstack((a,b))`` or ``np.r_[a,b]``\n  - concatenate rows of ``a`` and ``b``\n\n* - ``max(max(a))``\n  - ``a.max()`` or ``np.nanmax(a)``\n  - maximum element of ``a`` (with ndims(a)<=2 for MATLAB, if there are\n    NaN's, ``nanmax`` will ignore these and return largest value)\n\n* - ``max(a)``\n  - ``a.max(0)``\n  - maximum element of each column of array ``a``\n\n* - ``max(a,[],2)``\n  - ``a.max(1)``\n  - maximum element of each row of array ``a``\n\n* - ``max(a,b)``\n  - ``np.maximum(a, b)``\n  - compares ``a`` and ``b`` element-wise, and returns the maximum value\n    from each pair\n\n* - ``norm(v)``\n  - ``np.sqrt(v @ v)`` or ``np.linalg.norm(v)``\n  - L2 norm of vector ``v``\n\n* - ``a & b``\n  - ``logical_and(a,b)``\n  - element-by-element AND operator (NumPy ufunc) :ref:`See note\n    LOGICOPS <numpy-for-matlab-users.notes>`\n\n* - ``a | b``\n  - ``np.logical_or(a,b)``\n  - element-by-element OR operator (NumPy ufunc) :ref:`See note LOGICOPS\n    <numpy-for-matlab-users.notes>`\n\n* - ``bitand(a,b)``\n  - ``a & b``\n  - bitwise AND operator (Python native and NumPy ufunc)\n\n* - ``bitor(a,b)``\n  - ``a | b``\n  - bitwise OR operator (Python native and NumPy ufunc)\n\n* - ``inv(a)``\n  - ``linalg.inv(a)``\n  - inverse of square 2D array ``a``\n\n* - ``pinv(a)``\n  - ``linalg.pinv(a)``\n  - pseudo-inverse of 2D array ``a``\n\n* - ``rank(a)``\n  - ``np.linalg.matrix_rank(a)``\n  - matrix rank of a 2D array ``a``\n\n* - ``a\\b``\n  - ``linalg.solve(a, b)`` if ``a`` is square; ``linalg.lstsq(a, b)``\n    otherwise\n  - solution of a x = b for x\n\n* - ``b/a``\n  - Solve ``a.T x.T = b.T`` instead\n  - solution of x a = b for x\n\n* - ``[U,S,V]=svd(a)``\n  - ``U, S, Vh = linalg.svd(a); V = Vh.T``\n  - singular value decomposition of ``a``\n\n* - ``chol(a)``\n  - ``linalg.cholesky(a)``\n  - Cholesky factorization of a 2D array\n\n* - ``[V,D]=eig(a)``\n  - ``D,V = linalg.eig(a)``\n  - eigenvalues :math:`\\lambda` and eigenvectors :math:`v` of ``a``,\n    where :math:`\\mathbf{a} v = \\lambda v`\n\n* - ``[V,D]=eig(a,b)``\n  - ``D,V = linalg.eig(a, b)``\n  - eigenvalues :math:`\\lambda` and eigenvectors :math:`v` of\n    ``a``, ``b``\n    where :math:`\\mathbf{a} v = \\lambda \\mathbf{b} v`\n\n* - ``[V,D]=eigs(a,3)``\n  - ``D,V = eigs(a, k=3)``\n  - find the ``k=3`` largest eigenvalues and eigenvectors of 2D array, ``a``\n\n* - ``[Q,R]=qr(a,0)``\n  - ``Q,R = linalg.qr(a)``\n  - QR decomposition\n\n* - ``[L,U,P]=lu(a)`` where ``a==P'*L*U``\n  - ``P,L,U = linalg.lu(a)`` where ``a == P@L@U``\n  - LU decomposition with partial pivoting\n    (note: P(MATLAB) == transpose(P(NumPy)))\n\n* - ``conjgrad``\n  - ``cg``\n  - conjugate gradients solver\n\n* - ``fft(a)``\n  - ``np.fft.fft(a)``\n  - Fourier transform of ``a``\n\n* - ``ifft(a)``\n  - ``np.fft.ifft(a)``\n  - inverse Fourier transform of ``a``\n\n* - ``sort(a)``\n  - ``np.sort(a)`` or ``a.sort(axis=0)``\n  - sort each column of a 2D array, ``a``\n\n* - ``sort(a, 2)``\n  - ``np.sort(a, axis=1)`` or ``a.sort(axis=1)``\n  - sort the each row of 2D array, ``a``\n\n* - ``[b,I]=sortrows(a,1)``\n  - ``I = np.argsort(a[:, 0]); b = a[I,:]``\n  - save the array ``a`` as array ``b`` with rows sorted by the first column\n\n* - ``x = Z\\y``\n  - ``x = linalg.lstsq(Z, y)``\n  - perform a linear regression of the form :math:`\\mathbf{Zx}=\\mathbf{y}`\n\n* - ``decimate(x, q)``\n  - ``signal.resample(x, np.ceil(len(x)/q))``\n  - downsample with low-pass filtering\n\n* - ``unique(a)``\n  - ``np.unique(a)``\n  - a vector of unique values in array ``a``\n\n* - ``squeeze(a)``\n  - ``a.squeeze()``\n  - remove singleton dimensions of array ``a``. Note that MATLAB will always\n    return arrays of 2D or higher while NumPy will return arrays of 0D or\n    higher"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Linear algebra equivalents",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "\\ "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Submatrix"
                }
              ],
              "type": "strong"
            },
            {
              "type": "text",
              "value": ": Assignment to a submatrix can be done with lists of indices using the "
            },
            {
              "type": "inlineCode",
              "value": "ix_"
            },
            {
              "type": "text",
              "value": " command. E.g., for 2D array "
            },
            {
              "type": "inlineCode",
              "value": "a"
            },
            {
              "type": "text",
              "value": ", one might do: "
            },
            {
              "type": "inlineCode",
              "value": "ind=[1, 3];\u00a0a[np.ix_(ind, ind)] += 100"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "\\ "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "HELP"
                }
              ],
              "type": "strong"
            },
            {
              "type": "text",
              "value": ": There is no direct equivalent of MATLAB's "
            },
            {
              "type": "inlineCode",
              "value": "which"
            },
            {
              "type": "text",
              "value": " command, but the commands "
            },
            {
              "type": "inlineCode",
              "value": "help"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "numpy.source"
            },
            {
              "type": "text",
              "value": " will usually list the filename where the function is located. Python also has an "
            },
            {
              "type": "inlineCode",
              "value": "inspect"
            },
            {
              "type": "text",
              "value": " module (do "
            },
            {
              "type": "inlineCode",
              "value": "import\u00a0inspect"
            },
            {
              "type": "text",
              "value": ") which provides a "
            },
            {
              "type": "inlineCode",
              "value": "getfile"
            },
            {
              "type": "text",
              "value": " that often works."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "\\ "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "INDEXING"
                }
              ],
              "type": "strong"
            },
            {
              "type": "text",
              "value": ": MATLAB uses one based indexing, so the initial element of a sequence has index 1. Python uses zero based indexing, so the initial element of a sequence has index 0. Confusion and flamewars arise because each has advantages and disadvantages. One based indexing is consistent with common human language usage, where the \"first\" element of a sequence has index 1. Zero based indexing "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "simplifies indexing"
                }
              ],
              "title": "",
              "type": "link",
              "url": "https://groups.google.com/group/comp.lang.python/msg/1bf4d925dfbf368?q=g:thl3498076713d&hl=en"
            },
            {
              "type": "text",
              "value": ". See also "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "a text by prof.dr. Edsger W. Dijkstra"
                }
              ],
              "title": "",
              "type": "link",
              "url": "https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "\\ "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "RANGES"
                }
              ],
              "type": "strong"
            },
            {
              "type": "text",
              "value": ": In MATLAB, "
            },
            {
              "type": "inlineCode",
              "value": "0:5"
            },
            {
              "type": "text",
              "value": " can be used as both a range literal and a 'slice' index (inside parentheses); however, in Python, constructs like "
            },
            {
              "type": "inlineCode",
              "value": "0:5"
            },
            {
              "type": "text",
              "value": " can "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "only"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " be used as a slice index (inside square brackets). Thus the somewhat quirky "
            },
            {
              "type": "inlineCode",
              "value": "r_"
            },
            {
              "type": "text",
              "value": " object was created to allow NumPy to have a similarly terse range construction mechanism. Note that "
            },
            {
              "type": "inlineCode",
              "value": "r_"
            },
            {
              "type": "text",
              "value": " is not called like a function or a constructor, but rather "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "indexed"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": " using square brackets, which allows the use of Python's slice syntax in the arguments."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "\\ "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "LOGICOPS"
                }
              ],
              "type": "strong"
            },
            {
              "type": "text",
              "value": ": "
            },
            {
              "type": "inlineCode",
              "value": "&"
            },
            {
              "type": "text",
              "value": " or "
            },
            {
              "type": "inlineCode",
              "value": "|"
            },
            {
              "type": "text",
              "value": " in NumPy is bitwise AND/OR, while in MATLAB & and "
            },
            {
              "type": "inlineCode",
              "value": "|"
            },
            {
              "type": "text",
              "value": " are logical AND/OR. The two can appear to work the same, but there are important differences. If you would have used MATLAB's "
            },
            {
              "type": "inlineCode",
              "value": "&"
            },
            {
              "type": "text",
              "value": " or "
            },
            {
              "type": "inlineCode",
              "value": "|"
            },
            {
              "type": "text",
              "value": " operators, you should use the NumPy ufuncs "
            },
            {
              "type": "inlineCode",
              "value": "logical_and"
            },
            {
              "type": "text",
              "value": "/"
            },
            {
              "type": "inlineCode",
              "value": "logical_or"
            },
            {
              "type": "text",
              "value": ". The notable differences between MATLAB's and NumPy's "
            },
            {
              "type": "inlineCode",
              "value": "&"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "|"
            },
            {
              "type": "text",
              "value": " operators are:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Non-logical {0,1} inputs: NumPy's output is the bitwise AND of the    inputs. MATLAB treats any non-zero value as 1 and returns the logical    AND. For example "
                    },
                    {
                      "type": "inlineCode",
                      "value": "(3 & 4)"
                    },
                    {
                      "type": "text",
                      "value": " in NumPy is "
                    },
                    {
                      "type": "inlineCode",
                      "value": "0"
                    },
                    {
                      "type": "text",
                      "value": ", while in MATLAB both "
                    },
                    {
                      "type": "inlineCode",
                      "value": "3"
                    },
                    {
                      "type": "text",
                      "value": "    and "
                    },
                    {
                      "type": "inlineCode",
                      "value": "4"
                    },
                    {
                      "type": "text",
                      "value": "    are considered logical true and "
                    },
                    {
                      "type": "inlineCode",
                      "value": "(3 & 4)"
                    },
                    {
                      "type": "text",
                      "value": " returns "
                    },
                    {
                      "type": "inlineCode",
                      "value": "1"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Precedence: NumPy's & operator is higher precedence than logical    operators like "
                    },
                    {
                      "type": "inlineCode",
                      "value": "<"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "type": "inlineCode",
                      "value": ">"
                    },
                    {
                      "type": "text",
                      "value": "; MATLAB's is the reverse."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "If you know you have boolean arguments, you can get away with using NumPy's bitwise operators, but be careful with parentheses, like this: "
            },
            {
              "type": "inlineCode",
              "value": "z\n= (x > 1) & (x < 2)"
            },
            {
              "type": "text",
              "value": ". The absence of NumPy operator forms of "
            },
            {
              "type": "inlineCode",
              "value": "logical_and"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "logical_or"
            },
            {
              "type": "text",
              "value": " is an unfortunate consequence of Python's design."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "RESHAPE and LINEAR INDEXING"
                }
              ],
              "type": "strong"
            },
            {
              "type": "text",
              "value": ": MATLAB always allows multi-dimensional arrays to be accessed using scalar or linear indices, NumPy does not. Linear indices are common in MATLAB programs, e.g. "
            },
            {
              "type": "inlineCode",
              "value": "find()"
            },
            {
              "type": "text",
              "value": " on a matrix returns them, whereas NumPy's find behaves differently. When converting MATLAB code it might be necessary to first reshape a matrix to a linear sequence, perform some indexing operations and then reshape back. As reshape (usually) produces views onto the same storage, it should be possible to do this fairly efficiently. Note that the scan order used by reshape in NumPy defaults to the 'C' order, whereas MATLAB uses the Fortran order. If you are simply converting to a linear sequence and back this doesn't matter. But if you are converting reshapes from MATLAB code which relies on the scan order, then this MATLAB code: "
            },
            {
              "type": "inlineCode",
              "value": "z =\nreshape(x,3,4);"
            },
            {
              "type": "text",
              "value": " should become "
            },
            {
              "type": "inlineCode",
              "value": "z = x.reshape(3,4,order='F').copy()"
            },
            {
              "type": "text",
              "value": " in NumPy."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": "numpy-for-matlab-users.notes",
      "title": "Notes",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Historically, NumPy has provided a special matrix type, "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "np.matrix"
            },
            {
              "type": "text",
              "value": ", which is a subclass of ndarray which makes binary operations linear algebra operations. You may see it used in some existing code instead of "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "np.array"
            },
            {
              "type": "text",
              "value": ". So, which one to use?"
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "'array' or 'matrix'? Which should I use?",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "Use arrays"
                }
              ],
              "type": "strong"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "They support multidimensional array algebra that is supported in MATLAB"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "They are the standard vector/matrix/tensor type of NumPy. Many NumPy    functions return arrays, not matrices."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "There is a clear distinction between element-wise operations and    linear algebra operations."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "You can have standard vectors or row/column vectors if you like."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Until Python 3.5 the only disadvantage of using the array type was that you had to use "
            },
            {
              "type": "inlineCode",
              "value": "dot"
            },
            {
              "type": "text",
              "value": " instead of "
            },
            {
              "type": "inlineCode",
              "value": "*"
            },
            {
              "type": "text",
              "value": " to multiply (reduce) two tensors (scalar product, matrix vector multiplication etc.). Since Python 3.5 you can use the matrix multiplication "
            },
            {
              "type": "inlineCode",
              "value": "@"
            },
            {
              "type": "text",
              "value": " operator."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Given the above, we intend to deprecate "
            },
            {
              "type": "inlineCode",
              "value": "matrix"
            },
            {
              "type": "text",
              "value": " eventually."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Short answer",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "NumPy contains both an "
            },
            {
              "type": "inlineCode",
              "value": "array"
            },
            {
              "type": "text",
              "value": " class and a "
            },
            {
              "type": "inlineCode",
              "value": "matrix"
            },
            {
              "type": "text",
              "value": " class. The "
            },
            {
              "type": "inlineCode",
              "value": "array"
            },
            {
              "type": "text",
              "value": " class is intended to be a general-purpose n-dimensional array for many kinds of numerical computing, while "
            },
            {
              "type": "inlineCode",
              "value": "matrix"
            },
            {
              "type": "text",
              "value": " is intended to facilitate linear algebra computations specifically. In practice there are only a handful of key differences between the two."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Operators "
                    },
                    {
                      "type": "inlineCode",
                      "value": "*"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "type": "inlineCode",
                      "value": "@"
                    },
                    {
                      "type": "text",
                      "value": ", functions "
                    },
                    {
                      "type": "inlineCode",
                      "value": "dot()"
                    },
                    {
                      "type": "text",
                      "value": ", and "
                    },
                    {
                      "type": "inlineCode",
                      "value": "multiply()"
                    },
                    {
                      "type": "text",
                      "value": ":"
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "children": [
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "text",
                              "value": "For "
                            },
                            {
                              "type": "inlineCode",
                              "value": "array"
                            },
                            {
                              "type": "text",
                              "value": ", "
                            },
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "``*`` means element-wise multiplication"
                                }
                              ],
                              "type": "strong"
                            },
                            {
                              "type": "text",
                              "value": ", while       "
                            },
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "``@`` means matrix multiplication"
                                }
                              ],
                              "type": "strong"
                            },
                            {
                              "type": "text",
                              "value": "; they have associated functions       "
                            },
                            {
                              "type": "inlineCode",
                              "value": "multiply()"
                            },
                            {
                              "type": "text",
                              "value": " and "
                            },
                            {
                              "type": "inlineCode",
                              "value": "dot()"
                            },
                            {
                              "type": "text",
                              "value": ".  (Before Python 3.5, "
                            },
                            {
                              "type": "inlineCode",
                              "value": "@"
                            },
                            {
                              "type": "text",
                              "value": " did not exist       and one had to use "
                            },
                            {
                              "type": "inlineCode",
                              "value": "dot()"
                            },
                            {
                              "type": "text",
                              "value": " for matrix multiplication)."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "text",
                              "value": "For "
                            },
                            {
                              "type": "inlineCode",
                              "value": "matrix"
                            },
                            {
                              "type": "text",
                              "value": ", "
                            },
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "``*`` means matrix multiplication"
                                }
                              ],
                              "type": "strong"
                            },
                            {
                              "type": "text",
                              "value": ", and for       element-wise multiplication one has to use the "
                            },
                            {
                              "type": "inlineCode",
                              "value": "multiply()"
                            },
                            {
                              "type": "text",
                              "value": " function."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    }
                  ],
                  "ordered": false,
                  "spread": false,
                  "start": 1,
                  "type": "list"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Handling of vectors (one-dimensional arrays)"
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "children": [
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "text",
                              "value": "For "
                            },
                            {
                              "type": "inlineCode",
                              "value": "array"
                            },
                            {
                              "type": "text",
                              "value": ", the "
                            },
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "vector shapes 1xN, Nx1, and N are all different\n      things"
                                }
                              ],
                              "type": "strong"
                            },
                            {
                              "type": "text",
                              "value": ". Operations like "
                            },
                            {
                              "type": "inlineCode",
                              "value": "A[:,1]"
                            },
                            {
                              "type": "text",
                              "value": " return a one-dimensional array of       shape N, not a two-dimensional array of shape Nx1. Transpose on a       one-dimensional "
                            },
                            {
                              "type": "inlineCode",
                              "value": "array"
                            },
                            {
                              "type": "text",
                              "value": " does nothing."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "text",
                              "value": "For "
                            },
                            {
                              "type": "inlineCode",
                              "value": "matrix"
                            },
                            {
                              "type": "text",
                              "value": ", "
                            },
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "one-dimensional arrays are always upconverted to 1xN\n      or Nx1 matrices"
                                }
                              ],
                              "type": "strong"
                            },
                            {
                              "type": "text",
                              "value": " (row or column vectors). "
                            },
                            {
                              "type": "inlineCode",
                              "value": "A[:,1]"
                            },
                            {
                              "type": "text",
                              "value": " returns a       two-dimensional matrix of shape Nx1."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    }
                  ],
                  "ordered": false,
                  "spread": false,
                  "start": 1,
                  "type": "list"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Handling of higher-dimensional arrays (ndim > 2)"
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "children": [
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": "array"
                            },
                            {
                              "type": "text",
                              "value": " objects "
                            },
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "can have number of dimensions > 2"
                                }
                              ],
                              "type": "strong"
                            },
                            {
                              "type": "text",
                              "value": ";"
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": "matrix"
                            },
                            {
                              "type": "text",
                              "value": " objects "
                            },
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "always have exactly two dimensions"
                                }
                              ],
                              "type": "strong"
                            },
                            {
                              "type": "text",
                              "value": "."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    }
                  ],
                  "ordered": false,
                  "spread": false,
                  "start": 1,
                  "type": "list"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Convenience attributes"
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "children": [
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": "array"
                            },
                            {
                              "type": "text",
                              "value": " "
                            },
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "has a .T attribute"
                                }
                              ],
                              "type": "strong"
                            },
                            {
                              "type": "text",
                              "value": ", which returns the transpose of       the data."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": "matrix"
                            },
                            {
                              "type": "text",
                              "value": " "
                            },
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "also has .H, .I, and .A attributes"
                                }
                              ],
                              "type": "strong"
                            },
                            {
                              "type": "text",
                              "value": ", which return       the conjugate transpose, inverse, and "
                            },
                            {
                              "type": "inlineCode",
                              "value": "asarray()"
                            },
                            {
                              "type": "text",
                              "value": " of the matrix,       respectively."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    }
                  ],
                  "ordered": false,
                  "spread": false,
                  "start": 1,
                  "type": "list"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Convenience constructor"
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "children": [
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "text",
                              "value": "The "
                            },
                            {
                              "type": "inlineCode",
                              "value": "array"
                            },
                            {
                              "type": "text",
                              "value": " constructor "
                            },
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "takes (nested) Python sequences as\n      initializers"
                                }
                              ],
                              "type": "strong"
                            },
                            {
                              "type": "text",
                              "value": ". As in, "
                            },
                            {
                              "type": "inlineCode",
                              "value": "array([[1,2,3],[4,5,6]])"
                            },
                            {
                              "type": "text",
                              "value": "."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "text",
                              "value": "The "
                            },
                            {
                              "type": "inlineCode",
                              "value": "matrix"
                            },
                            {
                              "type": "text",
                              "value": " constructor additionally "
                            },
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "takes a convenient\n      string initializer"
                                }
                              ],
                              "type": "strong"
                            },
                            {
                              "type": "text",
                              "value": ". As in "
                            },
                            {
                              "type": "inlineCode",
                              "value": "matrix(\"[1\u00a02\u00a03;\u00a04\u00a05\u00a06]\")"
                            },
                            {
                              "type": "text",
                              "value": "."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    }
                  ],
                  "ordered": false,
                  "spread": false,
                  "start": 1,
                  "type": "list"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "There are pros and cons to using both:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "array"
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "children": [
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": ":)"
                            },
                            {
                              "type": "text",
                              "value": " Element-wise multiplication is easy: "
                            },
                            {
                              "type": "inlineCode",
                              "value": "A*B"
                            },
                            {
                              "type": "text",
                              "value": "."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": ":("
                            },
                            {
                              "type": "text",
                              "value": " You have to remember that matrix multiplication has its own       operator, "
                            },
                            {
                              "type": "inlineCode",
                              "value": "@"
                            },
                            {
                              "type": "text",
                              "value": "."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": ":)"
                            },
                            {
                              "type": "text",
                              "value": " You can treat one-dimensional arrays as "
                            },
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "either"
                                }
                              ],
                              "type": "emphasis"
                            },
                            {
                              "type": "text",
                              "value": " row or column       vectors. "
                            },
                            {
                              "type": "inlineCode",
                              "value": "A @ v"
                            },
                            {
                              "type": "text",
                              "value": " treats "
                            },
                            {
                              "type": "inlineCode",
                              "value": "v"
                            },
                            {
                              "type": "text",
                              "value": " as a column vector, while       "
                            },
                            {
                              "type": "inlineCode",
                              "value": "v @ A"
                            },
                            {
                              "type": "text",
                              "value": " treats "
                            },
                            {
                              "type": "inlineCode",
                              "value": "v"
                            },
                            {
                              "type": "text",
                              "value": " as a row vector. This can save you having to       type a lot of transposes."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": ":)"
                            },
                            {
                              "type": "text",
                              "value": " "
                            },
                            {
                              "type": "inlineCode",
                              "value": "array"
                            },
                            {
                              "type": "text",
                              "value": " is the \"default\" NumPy type, so it gets the most       testing, and is the type most likely to be returned by 3rd party       code that uses NumPy."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": ":)"
                            },
                            {
                              "type": "text",
                              "value": " Is quite at home handling data of any number of dimensions."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": ":)"
                            },
                            {
                              "type": "text",
                              "value": " Closer in semantics to tensor algebra, if you are familiar       with that."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": ":)"
                            },
                            {
                              "type": "text",
                              "value": " "
                            },
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "All"
                                }
                              ],
                              "type": "emphasis"
                            },
                            {
                              "type": "text",
                              "value": " operations ("
                            },
                            {
                              "type": "inlineCode",
                              "value": "*"
                            },
                            {
                              "type": "text",
                              "value": ", "
                            },
                            {
                              "type": "inlineCode",
                              "value": "/"
                            },
                            {
                              "type": "text",
                              "value": ", "
                            },
                            {
                              "type": "inlineCode",
                              "value": "+"
                            },
                            {
                              "type": "text",
                              "value": ", "
                            },
                            {
                              "type": "inlineCode",
                              "value": "-"
                            },
                            {
                              "type": "text",
                              "value": " etc.) are       element-wise."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": ":("
                            },
                            {
                              "type": "text",
                              "value": " Sparse matrices from "
                            },
                            {
                              "type": "inlineCode",
                              "value": "scipy.sparse"
                            },
                            {
                              "type": "text",
                              "value": " do not interact as well       with arrays."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    }
                  ],
                  "ordered": false,
                  "spread": false,
                  "start": 1,
                  "type": "list"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "matrix"
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "children": [
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": ":\\\\"
                            },
                            {
                              "type": "text",
                              "value": " Behavior is more like that of MATLAB matrices."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": "<:("
                            },
                            {
                              "type": "text",
                              "value": " Maximum of two-dimensional. To hold three-dimensional data you       need "
                            },
                            {
                              "type": "inlineCode",
                              "value": "array"
                            },
                            {
                              "type": "text",
                              "value": " or perhaps a Python list of "
                            },
                            {
                              "type": "inlineCode",
                              "value": "matrix"
                            },
                            {
                              "type": "text",
                              "value": "."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": "<:("
                            },
                            {
                              "type": "text",
                              "value": " Minimum of two-dimensional. You cannot have vectors. They must be       cast as single-column or single-row matrices."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": "<:("
                            },
                            {
                              "type": "text",
                              "value": " Since "
                            },
                            {
                              "type": "inlineCode",
                              "value": "array"
                            },
                            {
                              "type": "text",
                              "value": " is the default in NumPy, some functions may       return an "
                            },
                            {
                              "type": "inlineCode",
                              "value": "array"
                            },
                            {
                              "type": "text",
                              "value": " even if you give them a "
                            },
                            {
                              "type": "inlineCode",
                              "value": "matrix"
                            },
                            {
                              "type": "text",
                              "value": " as an       argument. This shouldn't happen with NumPy functions (if it does       it's a bug), but 3rd party code based on NumPy may not honor type       preservation like NumPy does."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": ":)"
                            },
                            {
                              "type": "text",
                              "value": " "
                            },
                            {
                              "type": "inlineCode",
                              "value": "A*B"
                            },
                            {
                              "type": "text",
                              "value": " is matrix multiplication, so it looks just like you write       it in linear algebra (For Python >= 3.5 plain arrays have the same       convenience with the "
                            },
                            {
                              "type": "inlineCode",
                              "value": "@"
                            },
                            {
                              "type": "text",
                              "value": " operator)."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": "<:("
                            },
                            {
                              "type": "text",
                              "value": " Element-wise multiplication requires calling a function,       "
                            },
                            {
                              "type": "inlineCode",
                              "value": "multiply(A,B)"
                            },
                            {
                              "type": "text",
                              "value": "."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": "<:("
                            },
                            {
                              "type": "text",
                              "value": " The use of operator overloading is a bit illogical: "
                            },
                            {
                              "type": "inlineCode",
                              "value": "*"
                            },
                            {
                              "type": "text",
                              "value": "       does not work element-wise but "
                            },
                            {
                              "type": "inlineCode",
                              "value": "/"
                            },
                            {
                              "type": "text",
                              "value": " does."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "text",
                              "value": "Interaction with "
                            },
                            {
                              "type": "inlineCode",
                              "value": "scipy.sparse"
                            },
                            {
                              "type": "text",
                              "value": " is a bit cleaner."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    }
                  ],
                  "ordered": false,
                  "spread": false,
                  "start": 1,
                  "type": "list"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The "
            },
            {
              "type": "inlineCode",
              "value": "array"
            },
            {
              "type": "text",
              "value": " is thus much more advisable to use.  Indeed, we intend to deprecate "
            },
            {
              "type": "inlineCode",
              "value": "matrix"
            },
            {
              "type": "text",
              "value": " eventually."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Long answer",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "In MATLAB the main tool available to you for customizing the environment is to modify the search path with the locations of your favorite functions. You can put such customizations into a startup script that MATLAB will run on startup."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "NumPy, or rather Python, has similar facilities."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "To modify your Python search path to include the locations of your    own modules, define the "
                    },
                    {
                      "type": "inlineCode",
                      "value": "PYTHONPATH"
                    },
                    {
                      "type": "text",
                      "value": " environment variable."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "To have a particular script file executed when the interactive Python    interpreter is started, define the "
                    },
                    {
                      "type": "inlineCode",
                      "value": "PYTHONSTARTUP"
                    },
                    {
                      "type": "text",
                      "value": " environment    variable to contain the name of your startup script."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Unlike MATLAB, where anything on your path can be called immediately, with Python you need to first do an 'import' statement to make functions in a particular file accessible."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "For example you might make a startup script that looks like this (Note: this is just an example, not a statement of \"best practices\"):"
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": "# Make all numpy available via shorter 'np' prefix\nimport numpy as np\n#\n# Make the SciPy linear algebra functions available as linalg.func()\n# e.g. linalg.lu, linalg.eig (for general l*B@u==A@u solution)\nfrom scipy import linalg\n#\n# Define a Hermitian function\ndef hermitian(A, **kwargs):\n    return np.conj(A,**kwargs).T\n# Make a shortcut for hermitian:\n#    hermitian(A) --> H(A)\nH = hermitian"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "To use the deprecated "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "matrix"
            },
            {
              "type": "text",
              "value": " and other "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "matlib"
            },
            {
              "type": "text",
              "value": " functions:"
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": "# Make all matlib functions accessible at the top level via M.func()\nimport numpy.matlib as M\n# Make some matlib functions accessible directly at the top level via, e.g. rand(3,3)\nfrom numpy.matlib import matrix,rand,zeros,ones,empty,eye"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Customizing your environment",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Another somewhat outdated MATLAB/NumPy cross-reference can be found at http://mathesaurus.sf.net/"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "An extensive list of tools for scientific work with Python can be found in the "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "topical software page"
                }
              ],
              "title": "",
              "type": "link",
              "url": "https://scipy.org/topical-software.html"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "See "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "List of Python software: scripting"
                }
              ],
              "title": "",
              "type": "link",
              "url": "https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language"
            },
            {
              "type": "text",
              "value": " for a list of software that use Python as a scripting language"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "MATLAB\u00ae and SimuLink\u00ae are registered trademarks of The MathWorks, Inc."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Links",
      "type": "Section"
    }
  ],
  "content": {},
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null,
    "type": "Section"
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "see_also": [],
  "signature": {
    "type": "Signature",
    "value": null
  },
  "type": "DocBlob"
}