{
  "aliases": [],
  "arbitrary": [
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "NumPy's ndarray objects provide both a high-level API for operations on array-structured data and a concrete implementation of the API based on "
            },
            {
              "type": "inlineCode",
              "value": "strided in-RAM storage <arrays>"
            },
            {
              "type": "text",
              "value": ". While this API is powerful and fairly general, its concrete implementation has limitations. As datasets grow and NumPy becomes used in a variety of new environments and architectures, there are cases where the strided in-RAM storage strategy is inappropriate, which has caused different libraries to reimplement this API for their own uses. This includes GPU arrays ("
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "CuPy_"
            },
            {
              "type": "text",
              "value": "), Sparse arrays ("
            },
            {
              "anchor": null,
              "exists": true,
              "kind": "module",
              "reference": {
                "kind": "api",
                "module": "scipy.sparse",
                "path": "scipy.sparse",
                "type": "RefInfo",
                "version": "*"
              },
              "type": "Link",
              "value": "scipy.sparse"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "PyData/Sparse <Sparse_>"
            },
            {
              "type": "text",
              "value": ") and parallel arrays ("
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "Dask_"
            },
            {
              "type": "text",
              "value": " arrays) as well as various NumPy-like implementations in deep learning frameworks, like "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "TensorFlow_"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "PyTorch_"
            },
            {
              "type": "text",
              "value": ". Similarly, there are many projects that build on top of the NumPy API for labeled and indexed arrays ("
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "XArray_"
            },
            {
              "type": "text",
              "value": "), automatic differentiation ("
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "JAX_"
            },
            {
              "type": "text",
              "value": "), masked arrays ("
            },
            {
              "anchor": null,
              "exists": true,
              "kind": "module",
              "reference": {
                "kind": "api",
                "module": "numpy.ma",
                "path": "numpy.ma",
                "type": "RefInfo",
                "version": "*"
              },
              "type": "Link",
              "value": "numpy.ma"
            },
            {
              "type": "text",
              "value": "), physical units ("
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "astropy.units_"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "pint_"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "unyt_"
            },
            {
              "type": "text",
              "value": "), among others that add additional functionality on top of the NumPy API."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Yet, users still want to work with these arrays using the familiar NumPy API and re-use existing code with minimal (ideally zero) porting overhead. With this goal in mind, various protocols are defined for implementations of multi-dimensional arrays with high-level APIs matching NumPy."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Broadly speaking, there are three groups of features used for interoperability with NumPy:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Methods of turning a foreign object into an ndarray;"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Methods of deferring execution from a NumPy function to another array    library;"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Methods that use NumPy functions and return an instance of a foreign object."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": true,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "We describe these features below."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": "basics.interoperability",
      "title": "Interoperability with NumPy",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The first set of interoperability features from the NumPy API allows foreign objects to be treated as NumPy arrays whenever possible. When NumPy functions encounter a foreign object, they will try (in order):"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The buffer protocol, described "
                    },
                    {
                      "type": "inlineCode",
                      "value": "in the Python C-API documentation\n   <python:c-api/buffer>"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The "
                    },
                    {
                      "type": "inlineCode",
                      "value": "__array_interface__"
                    },
                    {
                      "type": "text",
                      "value": " protocol, described    "
                    },
                    {
                      "type": "inlineCode",
                      "value": "in this page <arrays.interface>"
                    },
                    {
                      "type": "text",
                      "value": ". A precursor to Python's buffer    protocol, it defines a way to access the contents of a NumPy array from other    C extensions."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The "
                    },
                    {
                      "type": "inlineCode",
                      "value": "__array__()"
                    },
                    {
                      "type": "text",
                      "value": " method, which asks an arbitrary object to convert    itself into an array."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": true,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "For both the buffer and the "
            },
            {
              "type": "inlineCode",
              "value": "__array_interface__"
            },
            {
              "type": "text",
              "value": " protocols, the object describes its memory layout and NumPy does everything else (zero-copy if possible). If that's not possible, the object itself is responsible for returning a "
            },
            {
              "type": "inlineCode",
              "value": "ndarray"
            },
            {
              "type": "text",
              "value": " from "
            },
            {
              "type": "inlineCode",
              "value": "__array__()"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "DLPack <dlpack:index>"
            },
            {
              "type": "text",
              "value": " is yet another protocol to convert foreign objects to NumPy arrays in a language and device agnostic manner. NumPy doesn't implicitly convert objects to ndarrays using DLPack. It provides the function "
            },
            {
              "anchor": null,
              "exists": true,
              "kind": "module",
              "reference": {
                "kind": "api",
                "module": "numpy",
                "path": "numpy:from_dlpack",
                "type": "RefInfo",
                "version": "*"
              },
              "type": "Link",
              "value": "numpy.from_dlpack"
            },
            {
              "type": "text",
              "value": " that accepts any object implementing the "
            },
            {
              "type": "inlineCode",
              "value": "__dlpack__"
            },
            {
              "type": "text",
              "value": " method and outputs a NumPy ndarray (which is generally a view of the input object's data buffer). The "
            },
            {
              "type": "inlineCode",
              "value": "dlpack:python-spec"
            },
            {
              "type": "text",
              "value": " page explains the "
            },
            {
              "type": "inlineCode",
              "value": "__dlpack__"
            },
            {
              "type": "text",
              "value": " protocol in detail."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "1. Using arbitrary objects in NumPy",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The "
            },
            {
              "type": "inlineCode",
              "value": "array interface protocol <arrays.interface>"
            },
            {
              "type": "text",
              "value": " defines a way for array-like objects to re-use each other's data buffers. Its implementation relies on the existence of the following attributes or methods:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "__array_interface__"
                    },
                    {
                      "type": "text",
                      "value": ": a Python dictionary containing the shape, the    element type, and optionally, the data buffer address and the strides of an    array-like object;"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "__array__()"
                    },
                    {
                      "type": "text",
                      "value": ": a method returning the NumPy ndarray view of an array-like    object;"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The "
            },
            {
              "type": "inlineCode",
              "value": "__array_interface__"
            },
            {
              "type": "text",
              "value": " attribute can be inspected directly:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> import numpy as np\n>>> x = np.array([1, 2, 5.0, 8])\n>>> x.__array_interface__\n{'data': (94708397920832, False), 'strides': None, 'descr': [('', '<f8')], 'typestr': '<f8', 'shape': (4,), 'version': 3}"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The "
            },
            {
              "type": "inlineCode",
              "value": "__array_interface__"
            },
            {
              "type": "text",
              "value": " attribute can also be used to manipulate the object data in place:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> class wrapper():\n...     pass\n...\n>>> arr = np.array([1, 2, 3, 4])\n>>> buf = arr.__array_interface__\n>>> buf\n{'data': (140497590272032, False), 'strides': None, 'descr': [('', '<i8')], 'typestr': '<i8', 'shape': (4,), 'version': 3}\n>>> buf['shape'] = (2, 2)\n>>> w = wrapper()\n>>> w.__array_interface__ = buf\n>>> new_arr = np.array(w, copy=False)\n>>> new_arr\narray([[1, 2],\n       [3, 4]])"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "We can check that "
            },
            {
              "type": "inlineCode",
              "value": "arr"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "new_arr"
            },
            {
              "type": "text",
              "value": " share the same data buffer:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> new_arr[0, 0] = 1000\n>>> new_arr\narray([[1000,    2],\n       [   3,    4]])\n>>> arr\narray([1000, 2, 3, 4])"
            }
          ],
          "type": "blockquote"
        }
      ],
      "level": 2,
      "target": null,
      "title": "The array interface protocol",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The "
            },
            {
              "type": "inlineCode",
              "value": "__array__()"
            },
            {
              "type": "text",
              "value": " method ensures that any NumPy-like object (an array, any object exposing the array interface, an object whose "
            },
            {
              "type": "inlineCode",
              "value": "__array__()"
            },
            {
              "type": "text",
              "value": " method returns an array or any nested sequence) that implements it can be used as a NumPy array. If possible, this will mean using "
            },
            {
              "type": "inlineCode",
              "value": "__array__()"
            },
            {
              "type": "text",
              "value": " to create a NumPy ndarray view of the array-like object. Otherwise, this copies the data into a new ndarray object. This is not optimal, as coercing arrays into ndarrays may cause performance problems or create the need for copies and loss of metadata, as the original object and any attributes/behavior it may have had, is lost."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "To see an example of a custom array implementation including the use of "
            },
            {
              "type": "inlineCode",
              "value": "__array__()"
            },
            {
              "type": "text",
              "value": ", see "
            },
            {
              "type": "inlineCode",
              "value": "basics.dispatch"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "The ``__array__()`` method",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The "
            },
            {
              "type": "inlineCode",
              "value": "DLPack <dlpack:index>"
            },
            {
              "type": "text",
              "value": " protocol defines a memory-layout of strided n-dimensional array objects. It offers the following syntax for data exchange:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "A "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "module",
                      "reference": {
                        "kind": "api",
                        "module": "numpy",
                        "path": "numpy:from_dlpack",
                        "type": "RefInfo",
                        "version": "*"
                      },
                      "type": "Link",
                      "value": "numpy.from_dlpack"
                    },
                    {
                      "type": "text",
                      "value": " function, which accepts (array) objects with a    "
                    },
                    {
                      "type": "inlineCode",
                      "value": "__dlpack__"
                    },
                    {
                      "type": "text",
                      "value": " method and uses that method to construct a new array    containing the data from "
                    },
                    {
                      "type": "inlineCode",
                      "value": "x"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "__dlpack__(self, stream=None)"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "type": "inlineCode",
                      "value": "__dlpack_device__"
                    },
                    {
                      "type": "text",
                      "value": " methods on the    array object, which will be called from within "
                    },
                    {
                      "type": "inlineCode",
                      "value": "from_dlpack"
                    },
                    {
                      "type": "text",
                      "value": ", to query    what device the array is on (may be needed to pass in the correct    stream, e.g. in the case of multiple GPUs) and to access the data."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": true,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Unlike the buffer protocol, DLPack allows exchanging arrays containing data on devices other than the CPU (e.g. Vulkan or GPU). Since NumPy only supports CPU, it can only convert objects whose data exists on the CPU. But other libraries, like "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "PyTorch_"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "CuPy_"
            },
            {
              "type": "text",
              "value": ", may exchange data on GPU using this protocol."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "The DLPack Protocol",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "A second set of methods defined by the NumPy API allows us to defer the execution from a NumPy function to another array library."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Consider the following function."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> import numpy as np\n>>> def f(x):\n...     return np.mean(np.exp(x))"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Note that "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "np.exp <numpy.exp>"
            },
            {
              "type": "text",
              "value": " is a "
            },
            {
              "type": "inlineCode",
              "value": "ufunc <ufuncs-basics>"
            },
            {
              "type": "text",
              "value": ", which means that it operates on ndarrays in an element-by-element fashion. On the other hand, "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "np.mean <numpy.mean>"
            },
            {
              "type": "text",
              "value": " operates along one of the array's axes."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "We can apply "
            },
            {
              "type": "inlineCode",
              "value": "f"
            },
            {
              "type": "text",
              "value": " to a NumPy ndarray object directly:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> x = np.array([1, 2, 3, 4])\n>>> f(x)\n21.1977562209304"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "We would like this function to work equally well with any NumPy-like array object."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "NumPy allows a class to indicate that it would like to handle computations in a custom-defined way through the following interfaces:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "__array_ufunc__"
                    },
                    {
                      "type": "text",
                      "value": ": allows third-party objects to support and override    "
                    },
                    {
                      "type": "inlineCode",
                      "value": "ufuncs <ufuncs-basics>"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "__array_function__"
                    },
                    {
                      "type": "text",
                      "value": ": a catch-all for NumPy functionality that is not    covered by the "
                    },
                    {
                      "type": "inlineCode",
                      "value": "__array_ufunc__"
                    },
                    {
                      "type": "text",
                      "value": " protocol for universal functions."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "As long as foreign objects implement the "
            },
            {
              "type": "inlineCode",
              "value": "__array_ufunc__"
            },
            {
              "type": "text",
              "value": " or "
            },
            {
              "type": "inlineCode",
              "value": "__array_function__"
            },
            {
              "type": "text",
              "value": " protocols, it is possible to operate on them without the need for explicit conversion."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "2. Operating on foreign objects without converting",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "A "
            },
            {
              "type": "inlineCode",
              "value": "universal function (or ufunc for short) <ufuncs-basics>"
            },
            {
              "type": "text",
              "value": " is a \u201cvectorized\u201d wrapper for a function that takes a fixed number of specific inputs and produces a fixed number of specific outputs. The output of the ufunc (and its methods) is not necessarily a ndarray, if not all input arguments are ndarrays. Indeed, if any input defines an "
            },
            {
              "type": "inlineCode",
              "value": "__array_ufunc__"
            },
            {
              "type": "text",
              "value": " method, control will be passed completely to that function, i.e., the ufunc is overridden. The "
            },
            {
              "type": "inlineCode",
              "value": "__array_ufunc__"
            },
            {
              "type": "text",
              "value": " method defined on that (non-ndarray) object has access to the NumPy ufunc. Because ufuncs have a well-defined structure, the foreign "
            },
            {
              "type": "inlineCode",
              "value": "__array_ufunc__"
            },
            {
              "type": "text",
              "value": " method may rely on ufunc attributes like "
            },
            {
              "type": "inlineCode",
              "value": ".at()"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "type": "inlineCode",
              "value": ".reduce()"
            },
            {
              "type": "text",
              "value": ", and others."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "A subclass can override what happens when executing NumPy ufuncs on it by overriding the default "
            },
            {
              "type": "inlineCode",
              "value": "ndarray.__array_ufunc__"
            },
            {
              "type": "text",
              "value": " method. This method is executed instead of the ufunc and should return either the result of the operation, or "
            },
            {
              "type": "inlineCode",
              "value": "NotImplemented"
            },
            {
              "type": "text",
              "value": " if the operation requested is not implemented."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "The ``__array_ufunc__`` protocol",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "To achieve enough coverage of the NumPy API to support downstream projects, there is a need to go beyond "
            },
            {
              "type": "inlineCode",
              "value": "__array_ufunc__"
            },
            {
              "type": "text",
              "value": " and implement a protocol that allows arguments of a NumPy function to take control and divert execution to another function (for example, a GPU or parallel implementation) in a way that is safe and consistent across projects."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The semantics of "
            },
            {
              "type": "inlineCode",
              "value": "__array_function__"
            },
            {
              "type": "text",
              "value": " are very similar to "
            },
            {
              "type": "inlineCode",
              "value": "__array_ufunc__"
            },
            {
              "type": "text",
              "value": ", except the operation is specified by an arbitrary callable object rather than a ufunc instance and method. For more details, see "
            },
            {
              "type": "inlineCode",
              "value": "NEP18"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "The ``__array_function__`` protocol",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "A third type of feature set is meant to use the NumPy function implementation and then convert the return value back into an instance of the foreign object. The "
            },
            {
              "type": "inlineCode",
              "value": "__array_finalize__"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "__array_wrap__"
            },
            {
              "type": "text",
              "value": " methods act behind the scenes to ensure that the return type of a NumPy function can be specified as needed."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The "
            },
            {
              "type": "inlineCode",
              "value": "__array_finalize__"
            },
            {
              "type": "text",
              "value": " method is the mechanism that NumPy provides to allow subclasses to handle the various ways that new instances get created. This method is called whenever the system internally allocates a new array from an object which is a subclass (subtype) of the ndarray. It can be used to change attributes after construction, or to update meta-information from the \u201cparent.\u201d"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The "
            },
            {
              "type": "inlineCode",
              "value": "__array_wrap__"
            },
            {
              "type": "text",
              "value": " method \u201cwraps up the action\u201d in the sense of allowing any object (such as user-defined functions) to set the type of its return value and update attributes and metadata. This can be seen as the opposite of the "
            },
            {
              "type": "inlineCode",
              "value": "__array__"
            },
            {
              "type": "text",
              "value": " method. At the end of every object that implements "
            },
            {
              "type": "inlineCode",
              "value": "__array_wrap__"
            },
            {
              "type": "text",
              "value": ", this method is called on the input object with the highest "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "array priority"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": ", or the output object if one was specified. The "
            },
            {
              "type": "inlineCode",
              "value": "__array_priority__"
            },
            {
              "type": "text",
              "value": " attribute is used to determine what type of object to return in situations where there is more than one possibility for the Python type of the returned object. For example, subclasses may opt to use this method to transform the output array into an instance of the subclass and update metadata before returning the array to the user."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "For more information on these methods, see "
            },
            {
              "type": "inlineCode",
              "value": "basics.subclassing"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "specific-array-subtyping"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "3. Returning foreign objects",
      "type": "Section"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "Interoperability examples",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Consider the following:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> import pandas as pd\n>>> ser = pd.Series([1, 2, 3, 4])\n>>> type(ser)\npandas.core.series.Series"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Now, "
            },
            {
              "type": "inlineCode",
              "value": "ser"
            },
            {
              "type": "text",
              "value": " is "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "not"
                }
              ],
              "type": "strong"
            },
            {
              "type": "text",
              "value": " a ndarray, but because it "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "implements the __array_ufunc__ protocol"
                }
              ],
              "title": "",
              "type": "link",
              "url": "https://pandas.pydata.org/docs/user_guide/dsintro.html#dataframe-interoperability-with-numpy-functions"
            },
            {
              "type": "text",
              "value": ", we can apply ufuncs to it as if it were a ndarray:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> np.exp(ser)\n   0     2.718282\n   1     7.389056\n   2    20.085537\n   3    54.598150\n   dtype: float64\n>>> np.sin(ser)\n   0    0.841471\n   1    0.909297\n   2    0.141120\n   3   -0.756802\n   dtype: float64"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "We can even do operations with other ndarrays:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> np.add(ser, np.array([5, 6, 7, 8]))\n   0     6\n   1     8\n   2    10\n   3    12\n   dtype: int64\n>>> f(ser)\n21.1977562209304\n>>> result = ser.__array__()\n>>> type(result)\nnumpy.ndarray"
            }
          ],
          "type": "blockquote"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Example: Pandas ``Series`` objects",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "PyTorch"
                }
              ],
              "title": "",
              "type": "link",
              "url": "https://pytorch.org/"
            },
            {
              "type": "text",
              "value": " is an optimized tensor library for deep learning using GPUs and CPUs. PyTorch arrays are commonly called "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "tensors"
                }
              ],
              "type": "emphasis"
            },
            {
              "type": "text",
              "value": ". Tensors are similar to NumPy's ndarrays, except that tensors can run on GPUs or other hardware accelerators. In fact, tensors and NumPy arrays can often share the same underlying memory, eliminating the need to copy data."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> import torch\n>>> data = [[1, 2],[3, 4]]\n>>> x_np = np.array(data)\n>>> x_tensor = torch.tensor(data)"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Note that "
            },
            {
              "type": "inlineCode",
              "value": "x_np"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "x_tensor"
            },
            {
              "type": "text",
              "value": " are different kinds of objects:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> x_np\narray([[1, 2],\n       [3, 4]])\n>>> x_tensor\ntensor([[1, 2],\n        [3, 4]])"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "However, we can treat PyTorch tensors as NumPy arrays without the need for explicit conversion:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> np.exp(x_tensor)\ntensor([[ 2.7183,  7.3891],\n        [20.0855, 54.5982]], dtype=torch.float64)"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Also, note that the return type of this function is compatible with the initial data type."
            }
          ],
          "type": "paragraph"
        },
        {
          "args": "Warning",
          "children": [],
          "name": "admonition",
          "options": {},
          "type": "mystDirective",
          "value": "While this mixing of ndarrays and tensors may be convenient, it is not\nrecommended. It will not work for non-CPU tensors, and will have unexpected\nbehavior in corner cases. Users should prefer explicitly converting the\nndarray to a tensor."
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "note "
                }
              ],
              "type": "admonitionTitle"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "PyTorch does not implement "
                },
                {
                  "type": "inlineCode",
                  "value": "__array_function__"
                },
                {
                  "type": "text",
                  "value": " or "
                },
                {
                  "type": "inlineCode",
                  "value": "__array_ufunc__"
                },
                {
                  "type": "text",
                  "value": ". Under the hood, the "
                },
                {
                  "type": "inlineCode",
                  "value": "Tensor.__array__()"
                },
                {
                  "type": "text",
                  "value": " method returns a NumPy ndarray as a view of the tensor data buffer. See "
                },
                {
                  "domain": null,
                  "role": null,
                  "type": "Directive",
                  "value": "this issue\n<https://github.com/pytorch/pytorch/issues/24015>"
                },
                {
                  "type": "text",
                  "value": " and the "
                },
                {
                  "domain": null,
                  "role": null,
                  "type": "Directive",
                  "value": "__torch_function__ implementation\n<https://github.com/pytorch/pytorch/blob/master/torch/overrides.py>"
                },
                {
                  "type": "text",
                  "value": " for details."
                }
              ],
              "type": "paragraph"
            }
          ],
          "kind": "note",
          "type": "admonition"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Note also that we can see "
            },
            {
              "type": "inlineCode",
              "value": "__array_wrap__"
            },
            {
              "type": "text",
              "value": " in action here, even though "
            },
            {
              "type": "inlineCode",
              "value": "torch.Tensor"
            },
            {
              "type": "text",
              "value": " is not a subclass of ndarray     "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>> import torch\n>>> t = torch.arange(4)\n>>> np.abs(t)\ntensor([0, 1, 2, 3])"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "PyTorch implements "
            },
            {
              "type": "inlineCode",
              "value": "__array_wrap__"
            },
            {
              "type": "text",
              "value": " to be able to get tensors back from NumPy functions, and we can modify it directly to control which type of objects are returned from these functions."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Example: PyTorch tensors",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "CuPy is a NumPy/SciPy-compatible array library for GPU-accelerated computing with Python. CuPy implements a subset of the NumPy interface by implementing "
            },
            {
              "type": "inlineCode",
              "value": "cupy.ndarray"
            },
            {
              "type": "text",
              "value": ", "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "a counterpart to NumPy ndarrays"
                }
              ],
              "title": "",
              "type": "link",
              "url": "https://docs.cupy.dev/en/stable/reference/ndarray.html"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> import cupy as cp\n>>> x_gpu = cp.array([1, 2, 3, 4])"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The "
            },
            {
              "type": "inlineCode",
              "value": "cupy.ndarray"
            },
            {
              "type": "text",
              "value": " object implements the "
            },
            {
              "type": "inlineCode",
              "value": "__array_ufunc__"
            },
            {
              "type": "text",
              "value": " interface. This enables NumPy ufuncs to be applied to CuPy arrays (this will defer operation to the matching CuPy CUDA/ROCm implementation of the ufunc):"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> np.mean(np.exp(x_gpu))\narray(21.19775622)"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Note that the return type of these operations is still consistent with the initial type:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> arr = cp.random.randn(1, 2, 3, 4).astype(cp.float32)\n>>> result = np.sum(arr)\n>>> print(type(result))\n<class 'cupy._core.core.ndarray'>"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "See "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "this page in the CuPy documentation for details"
                }
              ],
              "title": "",
              "type": "link",
              "url": "https://docs.cupy.dev/en/stable/reference/ufunc.html"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "inlineCode",
              "value": "cupy.ndarray"
            },
            {
              "type": "text",
              "value": " also implements the "
            },
            {
              "type": "inlineCode",
              "value": "__array_function__"
            },
            {
              "type": "text",
              "value": " interface, meaning it is possible to do operations such as"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> a = np.random.randn(100, 100)\n>>> a_gpu = cp.asarray(a)\n>>> qr_gpu = np.linalg.qr(a_gpu)"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "CuPy implements many NumPy functions on "
            },
            {
              "type": "inlineCode",
              "value": "cupy.ndarray"
            },
            {
              "type": "text",
              "value": " objects, but not all. See "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "the CuPy documentation"
                }
              ],
              "title": "",
              "type": "link",
              "url": "https://docs.cupy.dev/en/stable/user_guide/difference.html"
            },
            {
              "type": "text",
              "value": " for details."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Example: CuPy arrays",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Dask is a flexible library for parallel computing in Python. Dask Array implements a subset of the NumPy ndarray interface using blocked algorithms, cutting up the large array into many small arrays. This allows computations on larger-than-memory arrays using multiple cores."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Dask supports "
            },
            {
              "type": "inlineCode",
              "value": "__array__()"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "type": "inlineCode",
              "value": "__array_ufunc__"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> import dask.array as da\n>>> x = da.random.normal(1, 0.1, size=(20, 20), chunks=(10, 10))\n>>> np.mean(np.exp(x))\ndask.array<mean_agg-aggregate, shape=(), dtype=float64, chunksize=(), chunktype=numpy.ndarray>\n>>> np.mean(np.exp(x)).compute()\n5.090097550553843"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "note "
                }
              ],
              "type": "admonitionTitle"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Dask is lazily evaluated, and the result from a computation isn't computed until you ask for it by invoking "
                },
                {
                  "type": "inlineCode",
                  "value": "compute()"
                },
                {
                  "type": "text",
                  "value": "."
                }
              ],
              "type": "paragraph"
            }
          ],
          "kind": "note",
          "type": "admonition"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "See "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "the Dask array documentation"
                }
              ],
              "title": "",
              "type": "link",
              "url": "https://docs.dask.org/en/stable/array.html"
            },
            {
              "type": "text",
              "value": " and the "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "scope of Dask arrays interoperability with NumPy arrays"
                }
              ],
              "title": "",
              "type": "link",
              "url": "https://docs.dask.org/en/stable/array.html#scope"
            },
            {
              "type": "text",
              "value": " for details."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Example: Dask arrays",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Several Python data science libraries implement the "
            },
            {
              "type": "inlineCode",
              "value": "__dlpack__"
            },
            {
              "type": "text",
              "value": " protocol. Among them are "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "PyTorch_"
            },
            {
              "type": "text",
              "value": " and "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "CuPy_"
            },
            {
              "type": "text",
              "value": ". A full list of libraries that implement this protocol can be found on "
            },
            {
              "type": "inlineCode",
              "value": "this page of DLPack documentation <dlpack:index>"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Convert a PyTorch CPU tensor to NumPy array:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> import torch\n>>> x_torch = torch.arange(5)\n>>> x_torch\ntensor([0, 1, 2, 3, 4])\n>>> x_np = np.from_dlpack(x_torch)\n>>> x_np\narray([0, 1, 2, 3, 4])\n>>> # note that x_np is a view of x_torch\n>>> x_torch[1] = 100\n>>> x_torch\ntensor([  0, 100,   2,   3,   4])\n>>> x_np\narray([  0, 100,   2,   3,   4])"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "The imported arrays are read-only so writing or operating in-place will fail:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> x.flags.writeable\nFalse\n>>> x_np[1] = 1\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: assignment destination is read-only"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "A copy must be created in order to operate on the imported arrays in-place, but will mean duplicating the memory. Do not do this for very large arrays:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> x_np_copy = x_np.copy()\n>>> x_np_copy.sort()  # works"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "children": [
                {
                  "type": "text",
                  "value": "note "
                }
              ],
              "type": "admonitionTitle"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "Note that GPU tensors can't be converted to NumPy arrays since NumPy doesn't support GPU devices:"
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "code",
                  "value": ">>> x_torch = torch.arange(5, device='cuda')\n>>> np.from_dlpack(x_torch)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nRuntimeError: Unsupported device in DLTensor."
                }
              ],
              "type": "blockquote"
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "But, if both libraries support the device the data buffer is on, it is possible to use the "
                },
                {
                  "type": "inlineCode",
                  "value": "__dlpack__"
                },
                {
                  "type": "text",
                  "value": " protocol (e.g. "
                },
                {
                  "domain": null,
                  "role": null,
                  "type": "Directive",
                  "value": "PyTorch_"
                },
                {
                  "type": "text",
                  "value": " and "
                },
                {
                  "domain": null,
                  "role": null,
                  "type": "Directive",
                  "value": "CuPy_"
                },
                {
                  "type": "text",
                  "value": "):"
                }
              ],
              "type": "paragraph"
            },
            {
              "children": [
                {
                  "type": "code",
                  "value": ">>> x_torch = torch.arange(5, device='cuda')\n>>> x_cupy = cupy.from_dlpack(x_torch)"
                }
              ],
              "type": "blockquote"
            }
          ],
          "kind": "note",
          "type": "admonition"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Similarly, a NumPy array can be converted to a PyTorch tensor:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> x_np = np.arange(5)\n>>> x_torch = torch.from_dlpack(x_np)"
            }
          ],
          "type": "blockquote"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Read-only arrays cannot be exported:"
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "code",
              "value": ">>> x_np = np.arange(5)\n>>> x_np.flags.writeable = False\n>>> torch.from_dlpack(x_np)  # doctest: +ELLIPSIS\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \".../site-packages/torch/utils/dlpack.py\", line 63, in from_dlpack\n    dlpack = ext_tensor.__dlpack__()\nTypeError: NumPy currently only supports dlpack for writeable arrays"
            }
          ],
          "type": "blockquote"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Example: DLPack",
      "type": "Section"
    },
    {
      "children": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "arrays.interface"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "basics.dispatch"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "special-attributes-and-methods"
                    },
                    {
                      "type": "text",
                      "value": " (details on the "
                    },
                    {
                      "type": "inlineCode",
                      "value": "__array_ufunc__"
                    },
                    {
                      "type": "text",
                      "value": " and    "
                    },
                    {
                      "type": "inlineCode",
                      "value": "__array_function__"
                    },
                    {
                      "type": "text",
                      "value": " protocols)"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "basics.subclassing"
                    },
                    {
                      "type": "text",
                      "value": " (details on the "
                    },
                    {
                      "type": "inlineCode",
                      "value": "__array_wrap__"
                    },
                    {
                      "type": "text",
                      "value": " and    "
                    },
                    {
                      "type": "inlineCode",
                      "value": "__array_finalize__"
                    },
                    {
                      "type": "text",
                      "value": " methods)"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "specific-array-subtyping"
                    },
                    {
                      "type": "text",
                      "value": " (more details on the implementation of    "
                    },
                    {
                      "type": "inlineCode",
                      "value": "__array_finalize__"
                    },
                    {
                      "type": "text",
                      "value": ", "
                    },
                    {
                      "type": "inlineCode",
                      "value": "__array_wrap__"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "type": "inlineCode",
                      "value": "__array_priority__"
                    },
                    {
                      "type": "text",
                      "value": ")"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "type": "inlineCode",
                      "value": "NumPy roadmap: interoperability <neps:roadmap>"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "PyTorch documentation on the Bridge with NumPy"
                        }
                      ],
                      "title": "",
                      "type": "link",
                      "url": "https://pytorch.org/tutorials/beginner/blitz/tensor_tutorial.html#bridge-to-np-label"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "spread": false,
              "type": "listItem"
            }
          ],
          "ordered": false,
          "spread": false,
          "start": 1,
          "type": "list"
        },
        {
          "placeholder": "target",
          "type": "Unimplemented",
          "value": ".. _CuPy: https://cupy.dev/"
        },
        {
          "placeholder": "target",
          "type": "Unimplemented",
          "value": ".. _Sparse: https://sparse.pydata.org/"
        },
        {
          "placeholder": "target",
          "type": "Unimplemented",
          "value": ".. _Dask: https://docs.dask.org/"
        },
        {
          "placeholder": "target",
          "type": "Unimplemented",
          "value": ".. _TensorFlow: https://www.tensorflow.org/"
        },
        {
          "placeholder": "target",
          "type": "Unimplemented",
          "value": ".. _PyTorch: https://pytorch.org/"
        },
        {
          "placeholder": "target",
          "type": "Unimplemented",
          "value": ".. _XArray: http://xarray.pydata.org/"
        },
        {
          "placeholder": "target",
          "type": "Unimplemented",
          "value": ".. _JAX: https://jax.readthedocs.io/"
        },
        {
          "placeholder": "target",
          "type": "Unimplemented",
          "value": ".. _astropy.units: https://docs.astropy.org/en/stable/units/"
        },
        {
          "placeholder": "target",
          "type": "Unimplemented",
          "value": ".. _pint: https://pint.readthedocs.io/"
        },
        {
          "placeholder": "target",
          "type": "Unimplemented",
          "value": ".. _unyt: https://unyt.readthedocs.io/"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Further reading",
      "type": "Section"
    }
  ],
  "content": {},
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null,
    "type": "Section"
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "see_also": [],
  "signature": {
    "type": "Signature",
    "value": null
  },
  "type": "DocBlob"
}