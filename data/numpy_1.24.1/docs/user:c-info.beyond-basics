{
  "aliases": [],
  "arbitrary": [
    {
      "children": [],
      "level": 0,
      "target": null,
      "title": "Beyond the Basics"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "Iterating over elements in the array"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "One common algorithmic requirement is to be able to walk over all elements in a multidimensional array. The array iterator object makes this easy to do in a generic way that works for arrays of any dimension. Naturally, if you know the number of dimensions you will be using, then you can always write nested for loops to accomplish the iteration. If, however, you want to write code that works with any number of dimensions, then you can make use of the array iterator. An array iterator object is returned when accessing the .flat attribute of an array."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "",
            "content": "single: array iterator",
            "name": "index",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Basic usage is to call "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_IterNew"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ( "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "array"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ) where array is an ndarray object (or one of its sub-classes). The returned object is an array-iterator object (the same object returned by the .flat attribute of the ndarray). This object is usually cast to PyArrayIterObject* so that its members can be accessed. The only members that are needed are "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "iter->size"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " which contains the total size of the array, "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "iter->index"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", which contains the current 1-d index into the array, and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "iter->dataptr"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " which is a pointer to the data for the current element of the array.  Sometimes it is also useful to access "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "iter->ao"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " which is a pointer to the underlying ndarray object."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "After processing data at the current element of the array, the next element of the array can be obtained using the macro "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_ITER_NEXT"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ( "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "iter"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ). The iteration always proceeds in a C-style contiguous fashion (last index varying the fastest). The "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_ITER_GOTO"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ( "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "iter"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "destination"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ) can be used to jump to a particular point in the array, where "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "destination"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is an array of npy_intp data-type with space to handle at least the number of dimensions in the underlying array. Occasionally it is useful to use "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_ITER_GOTO1D"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ( "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "iter"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "index"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ) which will jump to the 1-d index given by the value of "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "index"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ". The most common usage, however, is given in the following example."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "c",
            "content": "PyObject *obj; /* assumed to be some ndarray object */\nPyArrayIterObject *iter;\n...\niter = (PyArrayIterObject *)PyArray_IterNew(obj);\nif (iter == NULL) goto fail;   /* Assume fail has clean-up code */\nwhile (iter->index < iter->size) {\n    /* do something with the data at it->dataptr */\n    PyArray_ITER_NEXT(it);\n}\n...",
            "name": "code-block",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "You can also use "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArrayIter_Check"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ( "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "obj"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ) to ensure you have an iterator object and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_ITER_RESET"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ( "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "iter"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ) to reset an iterator object back to the beginning of the array."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "It should be emphasized at this point that you may not need the array iterator if your array is already contiguous (using an array iterator will work but will be slower than the fastest code you could write). The major purpose of array iterators is to encapsulate iteration over N-dimensional arrays with arbitrary strides. They are used in many, many places in the NumPy source code itself. If you already know your array is contiguous (Fortran or C), then simply adding the element- size to a running pointer variable will step you through the array very efficiently. In other words, code like this will probably be faster for you in the contiguous case (assuming doubles)."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "c",
            "content": "npy_intp size;\ndouble *dptr;  /* could make this any variable type */\nsize = PyArray_SIZE(obj);\ndptr = PyArray_DATA(obj);\nwhile(size--) {\n   /* do something with the data at dptr */\n   dptr++;\n}",
            "name": "code-block",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "level": 2,
      "target": "`sec:array_iterator`",
      "title": "Basic Iteration"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "A common algorithm is to loop over all elements of an array and perform some function with each element by issuing a function call. As function calls can be time consuming, one way to speed up this kind of algorithm is to write the function so it takes a vector of data and then write the iteration so the function call is performed for an entire dimension of data at a time. This increases the amount of work done per function call, thereby reducing the function-call over-head to a small(er) fraction of the total time. Even if the interior of the loop is performed without a function call it can be advantageous to perform the inner loop over the dimension with the highest number of elements to take advantage of speed enhancements available on micro- processors that use pipelining to enhance fundamental operations."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_IterAllButAxis"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ( "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "array"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "&dim"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ) constructs an iterator object that is modified so that it will not iterate over the dimension indicated by dim. The only restriction on this iterator object, is that the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_ITER_GOTO1D"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ( "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "it"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "ind"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ) macro cannot be used (thus flat indexing won't work either if you pass this object back to Python --- so you shouldn't do this). Note that the returned object from this routine is still usually cast to PyArrayIterObject \\*. All that's been done is to modify the strides and dimensions of the returned iterator to simulate iterating over array[...,0,...] where 0 is placed on the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "\\textrm{dim}^{\\textrm{th}}"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": " dimension. If dim is negative, then the dimension with the largest axis is found and used."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Iterating over all but one axis"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Very often, it is desirable to iterate over several arrays at the same time. The universal functions are an example of this kind of behavior. If all you want to do is iterate over arrays with the same shape, then simply creating several iterator objects is the standard procedure. For example, the following code iterates over two arrays assumed to be the same shape and size (actually obj1 just has to have at least as many total elements as does obj2):"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "c",
            "content": "/* It is already assumed that obj1 and obj2\n   are ndarrays of the same shape and size.\n*/\niter1 = (PyArrayIterObject *)PyArray_IterNew(obj1);\nif (iter1 == NULL) goto fail;\niter2 = (PyArrayIterObject *)PyArray_IterNew(obj2);\nif (iter2 == NULL) goto fail;  /* assume iter1 is DECREF'd at fail */\nwhile (iter2->index < iter2->size)  {\n    /* process with iter1->dataptr and iter2->dataptr */\n    PyArray_ITER_NEXT(iter1);\n    PyArray_ITER_NEXT(iter2);\n}",
            "name": "code-block",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Iterating over multiple arrays"
    },
    {
      "children": [
        {
          "data": {
            "argument": "",
            "content": "single: broadcasting",
            "name": "index",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "When multiple arrays are involved in an operation, you may want to use the same broadcasting rules that the math operations ("
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "i.e."
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " the ufuncs) use. This can be done easily using the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArrayMultiIterObject"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ".  This is the object returned from the Python command numpy.broadcast and it is almost as easy to use from C. The function "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_MultiIterNew"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ( "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "n"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "..."
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ) is used (with "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "n"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " input objects in place of "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "..."
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ). The input objects can be arrays or anything that can be converted into an array. A pointer to a PyArrayMultiIterObject is returned.  Broadcasting has already been accomplished which adjusts the iterators so that all that needs to be done to advance to the next element in each array is for PyArray_ITER_NEXT to be called for each of the inputs. This incrementing is automatically performed by "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_MultiIter_NEXT"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ( "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "obj"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ) macro (which can handle a multiterator "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "obj"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " as either a "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArrayMultiIterObject *"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " or a "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyObject *"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "). The data from input number "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "i"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is available using "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_MultiIter_DATA"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ( "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "obj"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "i"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ). An example of using this feature follows."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "c",
            "content": "mobj = PyArray_MultiIterNew(2, obj1, obj2);\nsize = mobj->size;\nwhile(size--) {\n    ptr1 = PyArray_MultiIter_DATA(mobj, 0);\n    ptr2 = PyArray_MultiIter_DATA(mobj, 1);\n    /* code using contents of ptr1 and ptr2 */\n    PyArray_MultiIter_NEXT(mobj);\n}",
            "name": "code-block",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The function "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_RemoveSmallest"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ( "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "multi"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " ) can be used to take a multi-iterator object and adjust all the iterators so that iteration does not take place over the largest dimension (it makes that dimension of size 1). The code being looped over that makes use of the pointers will very-likely also need the strides data for each of the iterators. This information is stored in multi->iters[i]->strides."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "",
            "content": "single: array iterator",
            "name": "index",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "There are several examples of using the multi-iterator in the NumPy source code as it makes N-dimensional broadcasting-code very simple to write. Browse the source for more examples."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Broadcasting over multiple arrays"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "NumPy comes with 24 builtin data-types. While this covers a large majority of possible use cases, it is conceivable that a user may have a need for an additional data-type. There is some support for adding an additional data-type into the NumPy system. This additional data- type will behave much like a regular data-type except ufuncs must have 1-d loops registered to handle it separately. Also checking for whether or not other data-types can be cast \"safely\" to and from this new type or not will always return \"can cast\" unless you also register which types your new data-type can be cast to and from."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The NumPy source code includes an example of a custom data-type as part of its test suite. The file "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "_rational_tests.c.src"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " in the source code directory  "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "numpy/numpy/core/src/umath/"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " contains an implementation of a data-type that represents a rational number as the ratio of two 32 bit integers."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "",
            "content": "pair: dtype; adding new",
            "name": "index",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "level": 1,
      "target": "user.user-defined-data-types",
      "title": "User-defined data-types"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "To begin to make use of the new data-type, you need to first define a new Python type to hold the scalars of your new data-type. It should be acceptable to inherit from one of the array scalars if your new type has a binary compatible layout. This will allow your new data type to have the methods and attributes of array scalars. New data- types must have a fixed memory size (if you want to define a data-type that needs a flexible representation, like a variable-precision number, then use a pointer to the object as the data-type). The memory layout of the object structure for the new Python type must be PyObject_HEAD followed by the fixed-size memory needed for the data- type. For example, a suitable structure for the new Python type is:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "c",
            "content": "typedef struct {\n   PyObject_HEAD;\n   some_data_type obval;\n   /* the name can be whatever you want */\n} PySomeDataTypeObject;",
            "name": "code-block",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "After you have defined a new Python type object, you must then define a new "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_Descr"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " structure whose typeobject member will contain a pointer to the data-type you've just defined. In addition, the required functions in the \".f\" member must be defined: nonzero, copyswap, copyswapn, setitem, getitem, and cast. The more functions in the \".f\" member you define, however, the more useful the new data-type will be.  It is very important to initialize unused functions to NULL. This can be achieved using "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_InitArrFuncs"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " (f)."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Once a new "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_Descr"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " structure is created and filled with the needed information and useful functions you call "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_RegisterDataType"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " (new_descr). The return value from this call is an integer providing you with a unique type_number that specifies your data-type. This type number should be stored and made available by your module so that other modules can use it to recognize your data-type (the other mechanism for finding a user-defined data-type number is to search based on the name of the type-object associated with the data-type using "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_TypeNumFromName"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " )."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Adding the new data-type"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "You may want to allow builtin (and other user-defined) data-types to be cast automatically to your data-type. In order to make this possible, you must register a casting function with the data-type you want to be able to cast from. This requires writing low-level casting functions for each conversion you want to support and then registering these functions with the data-type descriptor. A low-level casting function has the signature."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "void castfunc( \\",
            "content": "void* from, void* to, npy_intp n, void* fromarr, void* toarr)",
            "name": "c:function",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "Cast "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "n"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " elements "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "from"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " one type "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "to"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " another. The data to     cast from is in a contiguous, correctly-swapped and aligned chunk     of memory pointed to by from. The buffer to cast to is also     contiguous, correctly-swapped and aligned. The fromarr and toarr     arguments should only be used for flexible-element-sized arrays     (string, unicode, void)."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "An example castfunc is:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "c",
            "content": "static void\ndouble_to_float(double *from, float* to, npy_intp n,\n                void* ignore1, void* ignore2) {\n    while (n--) {\n          (*to++) = (double) *(from++);\n    }\n}",
            "name": "code-block",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "This could then be registered to convert doubles to floats using the code:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "c",
            "content": "doub = PyArray_DescrFromType(NPY_DOUBLE);\nPyArray_RegisterCastFunc(doub, NPY_FLOAT,\n     (PyArray_VectorUnaryFunc *)double_to_float);\nPy_DECREF(doub);",
            "name": "code-block",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Registering a casting function"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "By default, all user-defined data-types are not presumed to be safely castable to any builtin data-types. In addition builtin data-types are not presumed to be safely castable to user-defined data-types. This situation limits the ability of user-defined data-types to participate in the coercion system used by ufuncs and other times when automatic coercion takes place in NumPy. This can be changed by registering data-types as safely castable from a particular data-type object. The function "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArray_RegisterCanCast"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " (from_descr, totype_number, scalarkind) should be used to specify that the data-type object from_descr can be cast to the data-type with type number totype_number. If you are not trying to alter scalar coercion rules, then use "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NPY_NOSCALAR"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " for the scalarkind argument."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "If you want to allow your new data-type to also be able to share in the scalar coercion rules, then you need to specify the scalarkind function in the data-type object's \".f\" member to return the kind of scalar the new data-type should be seen as (the value of the scalar is available to that function). Then, you can register data-types that can be cast to separately for each scalar kind that may be returned from your user-defined data-type. If you don't register scalar coercion handling, then all of your user-defined data-types will be seen as "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "NPY_NOSCALAR"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Registering coercion rules"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "You may also want to register low-level ufunc loops for your data-type so that an ndarray of your data-type can have math applied to it seamlessly. Registering a new loop with exactly the same arg_types signature, silently replaces any previously registered loops for that data-type."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Before you can register a 1-d loop for a ufunc, the ufunc must be previously created. Then you call "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyUFunc_RegisterLoopForType"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " (...) with the information needed for the loop. The return value of this function is "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "0"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " if the process was successful and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "-1"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " with an error condition set if it was not successful."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "",
            "content": "pair: dtype; adding new",
            "name": "index",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Registering a ufunc loop"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "One of the lesser-used features that has been lurking in Python since 2.2 is the ability to sub-class types in C. This facility is one of the important reasons for basing NumPy off of the Numeric code-base which was already in C. A sub-type in C allows much more flexibility with regards to memory management. Sub-typing in C is not difficult even if you have only a rudimentary understanding of how to create new types for Python. While it is easiest to sub-type from a single parent type, sub-typing from multiple parent types is also possible. Multiple inheritance in C is generally less useful than it is in Python because a restriction on Python sub-types is that they have a binary compatible memory layout. Perhaps for this reason, it is somewhat easier to sub-type from a single parent type."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "",
            "content": "pair: ndarray; subtyping",
            "name": "index",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "All C-structures corresponding to Python objects must begin with "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyObject_HEAD"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " (or "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyObject_VAR_HEAD"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "). In the same way, any sub-type must have a C-structure that begins with exactly the same memory layout as the parent type (or all of the parent types in the case of multiple-inheritance). The reason for this is that Python may attempt to access a member of the sub-type structure as if it had the parent structure ( "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "i.e."
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " it will cast a given pointer to a pointer to the parent structure and then dereference one of it's members). If the memory layouts are not compatible, then this attempt will cause unpredictable behavior (eventually leading to a memory violation and program crash)."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "One of the elements in "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyObject_HEAD"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is a pointer to a type-object structure. A new Python type is created by creating a new type-object structure and populating it with functions and pointers to describe the desired behavior of the type. Typically, a new C-structure is also created to contain the instance-specific information needed for each object of the type as well. For example, "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "&PyArray_Type<PyArray_Type>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is a pointer to the type-object table for the ndarray while a "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyArrayObject *"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " variable is a pointer to a particular instance of an ndarray (one of the members of the ndarray structure is, in turn, a pointer to the type- object table "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "&PyArray_Type<PyArray_Type>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "). Finally "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyType_Ready"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " (<pointer_to_type_object>) must be called for every new Python type."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Subtyping the ndarray in C"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "To create a sub-type, a similar procedure must be followed except only behaviors that are different require new entries in the type- object structure. All other entries can be NULL and will be filled in by "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "PyType_Ready"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " with appropriate functions from the parent type(s). In particular, to create a sub-type in C follow these steps:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "If needed create a new C-structure to handle each instance of your    type. A typical C-structure would be:"
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  },
                  {
                    "data": {
                      "argument": "c",
                      "content": "typedef _new_struct {\n       PyArrayObject base;\n       /* new things here */\n   } NewArrayObject;",
                      "name": "code-block",
                      "options": []
                    },
                    "type": "BlockDirective"
                  },
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "Notice that the full PyArrayObject is used as the first entry in order    to ensure that the binary layout of instances of the new type is    identical to the PyArrayObject."
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "Fill in a new Python type-object structure with pointers to new    functions that will over-ride the default behavior while leaving any    function that should remain the same unfilled (or NULL). The tp_name    element should be different."
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "Fill in the tp_base member of the new type-object structure with a    pointer to the (main) parent type object. For multiple-inheritance,    also fill in the tp_bases member with a tuple containing all of the    parent objects in the order they should be used to define inheritance.    Remember, all parent-types must have the same C-structure for multiple    inheritance to work properly."
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "Call "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": [
                              "PyType_Ready"
                            ]
                          },
                          "type": "Verbatim"
                        },
                        {
                          "data": {
                            "value": " (<pointer_to_new_type>). If this function    returns a negative number, a failure occurred and the type is not    initialized. Otherwise, the type is ready to be used. It is    generally important to place a reference to the new type into the    module dictionary so it can be accessed from Python."
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              }
            ]
          },
          "type": "EnumeratedList"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "More information on creating sub-types in C can be learned by reading PEP 253 (available at https://www.python.org/dev/peps/pep-0253)."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Creating sub-types"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Some special methods and attributes are used by arrays in order to facilitate the interoperation of sub-types with the base ndarray type."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 2,
      "target": "specific-array-subtyping",
      "title": "Specific features of ndarray sub-typing"
    },
    {
      "children": [
        {
          "data": {
            "argument": "ndarray.__array_finalize__",
            "content": "Several array-creation functions of the ndarray allow\nspecification of a particular sub-type to be created. This allows\nsub-types to be handled seamlessly in many routines. When a\nsub-type is created in such a fashion, however, neither the\n__new_\\_ method nor the __init\\__ method gets called. Instead, the\nsub-type is allocated and the appropriate instance-structure\nmembers are filled in. Finally, the :obj:`~numpy.class.__array_finalize__`\nattribute is looked-up in the object dictionary. If it is present and not\nNone, then it can be either a :c:type:`PyCapsule` containing a pointer to a\n:c:func:`PyArray_FinalizeFunc` or it can be a method taking a single argument\n(which could be None)\n\nIf the :obj:`~numpy.class.__array_finalize__` attribute is a\n:c:type:`PyCapsule`, then the pointer must be a pointer to a function with\nthe signature:\n\n.. code-block:: c\n\n    (int) (PyArrayObject *, PyObject *)\n\nThe first argument is the newly created sub-type. The second argument\n(if not NULL) is the \"parent\" array (if the array was created using\nslicing or some other operation where a clearly-distinguishable parent\nis present). This routine can do anything it wants to. It should\nreturn a -1 on error and 0 otherwise.\n\nIf the :obj:`~numpy.class.__array_finalize__` attribute is not None nor a\n:c:type:`PyCapsule`, then it must be a Python method that takes the parent\narray as an argument (which could be None if there is no parent), and returns\nnothing. Errors in this method will be caught and handled.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "level": 3,
      "target": null,
      "title": "The __array_finalize\\__ method"
    },
    {
      "children": [
        {
          "data": {
            "argument": "ndarray.__array_priority__",
            "content": "This attribute allows simple but flexible determination of which sub-\ntype should be considered \"primary\" when an operation involving two or\nmore sub-types arises. In operations where different sub-types are\nbeing used, the sub-type with the largest :obj:`~numpy.class.__array_priority__`\nattribute will determine the sub-type of the output(s). If two sub-\ntypes have the same :obj:`~numpy.class.__array_priority__` then the sub-type of the\nfirst argument determines the output. The default\n:obj:`~numpy.class.__array_priority__` attribute returns a value of 0.0 for the base\nndarray type and 1.0 for a sub-type. This attribute can also be\ndefined by objects that are not sub-types of the ndarray and can be\nused to determine which :obj:`~numpy.class.__array_wrap__` method should be called for\nthe return output.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "level": 3,
      "target": null,
      "title": "The __array_priority\\__ attribute"
    },
    {
      "children": [
        {
          "data": {
            "argument": "ndarray.__array_wrap__",
            "content": "Any class or type can define this method which should take an ndarray\nargument and return an instance of the type. It can be seen as the\nopposite of the :obj:`~numpy.class.__array__` method. This method is used by the\nufuncs (and other NumPy functions) to allow other objects to pass\nthrough. For Python >2.4, it can also be used to write a decorator\nthat converts a function that works only with ndarrays to one that\nworks with any type with :obj:`~numpy.class.__array__` and :obj:`~numpy.class.__array_wrap__` methods.",
            "name": "attribute",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "",
            "content": "pair: ndarray; subtyping",
            "name": "index",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "level": 3,
      "target": null,
      "title": "The __array_wrap\\__ method"
    }
  ],
  "content": {},
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null
  },
  "item_file": null,
  "item_line": null,
  "item_type": null,
  "ordered_sections": [],
  "references": null,
  "see_also": [],
  "signature": {
    "value": null
  }
}