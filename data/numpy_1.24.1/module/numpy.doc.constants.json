{
  "aliases": [
    "numpy.doc.constants"
  ],
  "arbitrary": [
    {
      "children": [
        {
          "data": {
            "argument": "numpy",
            "content": "",
            "name": "currentmodule",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "NumPy includes several constants:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "Inf",
            "content": "IEEE 754 floating point representation of (positive) infinity.\n\nUse `inf` because `Inf`, `Infinity`, `PINF` and `infty` are aliases for\n`inf`. For more details, see `inf`.\n\n.. rubric:: See Also\n\ninf",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "Infinity",
            "content": "IEEE 754 floating point representation of (positive) infinity.\n\nUse `inf` because `Inf`, `Infinity`, `PINF` and `infty` are aliases for\n`inf`. For more details, see `inf`.\n\n.. rubric:: See Also\n\ninf",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NAN",
            "content": "IEEE 754 floating point representation of Not a Number (NaN).\n\n`NaN` and `NAN` are equivalent definitions of `nan`. Please use\n`nan` instead of `NAN`.\n\n.. rubric:: See Also\n\nnan",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NINF",
            "content": "IEEE 754 floating point representation of negative infinity.\n\n.. rubric:: Returns\n\ny : float\n    A floating point representation of negative infinity.\n\n.. rubric:: See Also\n\nisinf : Shows which elements are positive or negative infinity\n\nisposinf : Shows which elements are positive infinity\n\nisneginf : Shows which elements are negative infinity\n\nisnan : Shows which elements are Not a Number\n\nisfinite : Shows which elements are finite (not one of Not a Number,\npositive infinity and negative infinity)\n\n.. rubric:: Notes\n\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). This means that Not a Number is not equivalent to infinity.\nAlso that positive infinity is not equivalent to negative infinity. But\ninfinity is equivalent to positive infinity.\n\n.. rubric:: Examples\n\n>>> np.NINF\n-inf\n>>> np.log(0)\n-inf",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NZERO",
            "content": "IEEE 754 floating point representation of negative zero.\n\n.. rubric:: Returns\n\ny : float\n    A floating point representation of negative zero.\n\n.. rubric:: See Also\n\nPZERO : Defines positive zero.\n\nisinf : Shows which elements are positive or negative infinity.\n\nisposinf : Shows which elements are positive infinity.\n\nisneginf : Shows which elements are negative infinity.\n\nisnan : Shows which elements are Not a Number.\n\nisfinite : Shows which elements are finite - not one of\n           Not a Number, positive infinity and negative infinity.\n\n.. rubric:: Notes\n\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). Negative zero is considered to be a finite number.\n\n.. rubric:: Examples\n\n>>> np.NZERO\n-0.0\n>>> np.PZERO\n0.0\n\n>>> np.isfinite([np.NZERO])\narray([ True])\n>>> np.isnan([np.NZERO])\narray([False])\n>>> np.isinf([np.NZERO])\narray([False])",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NaN",
            "content": "IEEE 754 floating point representation of Not a Number (NaN).\n\n`NaN` and `NAN` are equivalent definitions of `nan`. Please use\n`nan` instead of `NaN`.\n\n.. rubric:: See Also\n\nnan",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PINF",
            "content": "IEEE 754 floating point representation of (positive) infinity.\n\nUse `inf` because `Inf`, `Infinity`, `PINF` and `infty` are aliases for\n`inf`. For more details, see `inf`.\n\n.. rubric:: See Also\n\ninf",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PZERO",
            "content": "IEEE 754 floating point representation of positive zero.\n\n.. rubric:: Returns\n\ny : float\n    A floating point representation of positive zero.\n\n.. rubric:: See Also\n\nNZERO : Defines negative zero.\n\nisinf : Shows which elements are positive or negative infinity.\n\nisposinf : Shows which elements are positive infinity.\n\nisneginf : Shows which elements are negative infinity.\n\nisnan : Shows which elements are Not a Number.\n\nisfinite : Shows which elements are finite - not one of\n           Not a Number, positive infinity and negative infinity.\n\n.. rubric:: Notes\n\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). Positive zero is considered to be a finite number.\n\n.. rubric:: Examples\n\n>>> np.PZERO\n0.0\n>>> np.NZERO\n-0.0\n\n>>> np.isfinite([np.PZERO])\narray([ True])\n>>> np.isnan([np.PZERO])\narray([False])\n>>> np.isinf([np.PZERO])\narray([False])",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "e",
            "content": "Euler's constant, base of natural logarithms, Napier's constant.\n\n``e = 2.71828182845904523536028747135266249775724709369995...``\n\n.. rubric:: See Also\n\nexp : Exponential function\nlog : Natural logarithm\n\n.. rubric:: References\n\nhttps://en.wikipedia.org/wiki/E_%28mathematical_constant%29",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "euler_gamma",
            "content": "``\u03b3 = 0.5772156649015328606065120900824024310421...``\n\n.. rubric:: References\n\nhttps://en.wikipedia.org/wiki/Euler-Mascheroni_constant",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "inf",
            "content": "IEEE 754 floating point representation of (positive) infinity.\n\n.. rubric:: Returns\n\ny : float\n    A floating point representation of positive infinity.\n\n.. rubric:: See Also\n\nisinf : Shows which elements are positive or negative infinity\n\nisposinf : Shows which elements are positive infinity\n\nisneginf : Shows which elements are negative infinity\n\nisnan : Shows which elements are Not a Number\n\nisfinite : Shows which elements are finite (not one of Not a Number,\npositive infinity and negative infinity)\n\n.. rubric:: Notes\n\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). This means that Not a Number is not equivalent to infinity.\nAlso that positive infinity is not equivalent to negative infinity. But\ninfinity is equivalent to positive infinity.\n\n`Inf`, `Infinity`, `PINF` and `infty` are aliases for `inf`.\n\n.. rubric:: Examples\n\n>>> np.inf\ninf\n>>> np.array([1]) / 0.\narray([ Inf])",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "infty",
            "content": "IEEE 754 floating point representation of (positive) infinity.\n\nUse `inf` because `Inf`, `Infinity`, `PINF` and `infty` are aliases for\n`inf`. For more details, see `inf`.\n\n.. rubric:: See Also\n\ninf",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "nan",
            "content": "IEEE 754 floating point representation of Not a Number (NaN).\n\n.. rubric:: Returns\n\ny : A floating point representation of Not a Number.\n\n.. rubric:: See Also\n\nisnan : Shows which elements are Not a Number.\n\nisfinite : Shows which elements are finite (not one of\nNot a Number, positive infinity and negative infinity)\n\n.. rubric:: Notes\n\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). This means that Not a Number is not equivalent to infinity.\n\n`NaN` and `NAN` are aliases of `nan`.\n\n.. rubric:: Examples\n\n>>> np.nan\nnan\n>>> np.log(-1)\nnan\n>>> np.log([-1, 1, 2])\narray([        NaN,  0.        ,  0.69314718])",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "newaxis",
            "content": "A convenient alias for None, useful for indexing arrays.\n\n.. rubric:: Examples\n\n>>> newaxis is None\nTrue\n>>> x = np.arange(3)\n>>> x\narray([0, 1, 2])\n>>> x[:, newaxis]\narray([[0],\n[1],\n[2]])\n>>> x[:, newaxis, newaxis]\narray([[[0]],\n[[1]],\n[[2]]])\n>>> x[:, newaxis] * x\narray([[0, 0, 0],\n[0, 1, 2],\n[0, 2, 4]])\n\nOuter product, same as ``outer(x, y)``:\n\n>>> y = np.arange(3, 6)\n>>> x[:, newaxis] * y\narray([[ 0,  0,  0],\n[ 3,  4,  5],\n[ 6,  8, 10]])\n\n``x[newaxis, :]`` is equivalent to ``x[newaxis]`` and ``x[None]``:\n\n>>> x[newaxis, :].shape\n(1, 3)\n>>> x[newaxis].shape\n(1, 3)\n>>> x[None].shape\n(1, 3)\n>>> x[:, newaxis].shape\n(3, 1)",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "pi",
            "content": "``pi = 3.1415926535897932384626433...``\n\n.. rubric:: References\n\nhttps://en.wikipedia.org/wiki/Pi",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "level": 0,
      "target": null,
      "title": "Constants"
    }
  ],
  "content": {
    "Attributes": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Extended Summary": {
      "children": [
        {
          "data": {
            "argument": "numpy",
            "content": "",
            "name": "currentmodule",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "NumPy includes several constants:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "argument": "Inf",
            "content": "IEEE 754 floating point representation of (positive) infinity.\n\nUse `inf` because `Inf`, `Infinity`, `PINF` and `infty` are aliases for\n`inf`. For more details, see `inf`.\n\n.. rubric:: See Also\n\ninf",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "Infinity",
            "content": "IEEE 754 floating point representation of (positive) infinity.\n\nUse `inf` because `Inf`, `Infinity`, `PINF` and `infty` are aliases for\n`inf`. For more details, see `inf`.\n\n.. rubric:: See Also\n\ninf",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NAN",
            "content": "IEEE 754 floating point representation of Not a Number (NaN).\n\n`NaN` and `NAN` are equivalent definitions of `nan`. Please use\n`nan` instead of `NAN`.\n\n.. rubric:: See Also\n\nnan",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NINF",
            "content": "IEEE 754 floating point representation of negative infinity.\n\n.. rubric:: Returns\n\ny : float\n    A floating point representation of negative infinity.\n\n.. rubric:: See Also\n\nisinf : Shows which elements are positive or negative infinity\n\nisposinf : Shows which elements are positive infinity\n\nisneginf : Shows which elements are negative infinity\n\nisnan : Shows which elements are Not a Number\n\nisfinite : Shows which elements are finite (not one of Not a Number,\npositive infinity and negative infinity)\n\n.. rubric:: Notes\n\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). This means that Not a Number is not equivalent to infinity.\nAlso that positive infinity is not equivalent to negative infinity. But\ninfinity is equivalent to positive infinity.\n\n.. rubric:: Examples\n\n>>> np.NINF\n-inf\n>>> np.log(0)\n-inf",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NZERO",
            "content": "IEEE 754 floating point representation of negative zero.\n\n.. rubric:: Returns\n\ny : float\n    A floating point representation of negative zero.\n\n.. rubric:: See Also\n\nPZERO : Defines positive zero.\n\nisinf : Shows which elements are positive or negative infinity.\n\nisposinf : Shows which elements are positive infinity.\n\nisneginf : Shows which elements are negative infinity.\n\nisnan : Shows which elements are Not a Number.\n\nisfinite : Shows which elements are finite - not one of\n           Not a Number, positive infinity and negative infinity.\n\n.. rubric:: Notes\n\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). Negative zero is considered to be a finite number.\n\n.. rubric:: Examples\n\n>>> np.NZERO\n-0.0\n>>> np.PZERO\n0.0\n\n>>> np.isfinite([np.NZERO])\narray([ True])\n>>> np.isnan([np.NZERO])\narray([False])\n>>> np.isinf([np.NZERO])\narray([False])",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "NaN",
            "content": "IEEE 754 floating point representation of Not a Number (NaN).\n\n`NaN` and `NAN` are equivalent definitions of `nan`. Please use\n`nan` instead of `NaN`.\n\n.. rubric:: See Also\n\nnan",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PINF",
            "content": "IEEE 754 floating point representation of (positive) infinity.\n\nUse `inf` because `Inf`, `Infinity`, `PINF` and `infty` are aliases for\n`inf`. For more details, see `inf`.\n\n.. rubric:: See Also\n\ninf",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "PZERO",
            "content": "IEEE 754 floating point representation of positive zero.\n\n.. rubric:: Returns\n\ny : float\n    A floating point representation of positive zero.\n\n.. rubric:: See Also\n\nNZERO : Defines negative zero.\n\nisinf : Shows which elements are positive or negative infinity.\n\nisposinf : Shows which elements are positive infinity.\n\nisneginf : Shows which elements are negative infinity.\n\nisnan : Shows which elements are Not a Number.\n\nisfinite : Shows which elements are finite - not one of\n           Not a Number, positive infinity and negative infinity.\n\n.. rubric:: Notes\n\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). Positive zero is considered to be a finite number.\n\n.. rubric:: Examples\n\n>>> np.PZERO\n0.0\n>>> np.NZERO\n-0.0\n\n>>> np.isfinite([np.PZERO])\narray([ True])\n>>> np.isnan([np.PZERO])\narray([False])\n>>> np.isinf([np.PZERO])\narray([False])",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "e",
            "content": "Euler's constant, base of natural logarithms, Napier's constant.\n\n``e = 2.71828182845904523536028747135266249775724709369995...``\n\n.. rubric:: See Also\n\nexp : Exponential function\nlog : Natural logarithm\n\n.. rubric:: References\n\nhttps://en.wikipedia.org/wiki/E_%28mathematical_constant%29",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "euler_gamma",
            "content": "``\u03b3 = 0.5772156649015328606065120900824024310421...``\n\n.. rubric:: References\n\nhttps://en.wikipedia.org/wiki/Euler-Mascheroni_constant",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "inf",
            "content": "IEEE 754 floating point representation of (positive) infinity.\n\n.. rubric:: Returns\n\ny : float\n    A floating point representation of positive infinity.\n\n.. rubric:: See Also\n\nisinf : Shows which elements are positive or negative infinity\n\nisposinf : Shows which elements are positive infinity\n\nisneginf : Shows which elements are negative infinity\n\nisnan : Shows which elements are Not a Number\n\nisfinite : Shows which elements are finite (not one of Not a Number,\npositive infinity and negative infinity)\n\n.. rubric:: Notes\n\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). This means that Not a Number is not equivalent to infinity.\nAlso that positive infinity is not equivalent to negative infinity. But\ninfinity is equivalent to positive infinity.\n\n`Inf`, `Infinity`, `PINF` and `infty` are aliases for `inf`.\n\n.. rubric:: Examples\n\n>>> np.inf\ninf\n>>> np.array([1]) / 0.\narray([ Inf])",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "infty",
            "content": "IEEE 754 floating point representation of (positive) infinity.\n\nUse `inf` because `Inf`, `Infinity`, `PINF` and `infty` are aliases for\n`inf`. For more details, see `inf`.\n\n.. rubric:: See Also\n\ninf",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "nan",
            "content": "IEEE 754 floating point representation of Not a Number (NaN).\n\n.. rubric:: Returns\n\ny : A floating point representation of Not a Number.\n\n.. rubric:: See Also\n\nisnan : Shows which elements are Not a Number.\n\nisfinite : Shows which elements are finite (not one of\nNot a Number, positive infinity and negative infinity)\n\n.. rubric:: Notes\n\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). This means that Not a Number is not equivalent to infinity.\n\n`NaN` and `NAN` are aliases of `nan`.\n\n.. rubric:: Examples\n\n>>> np.nan\nnan\n>>> np.log(-1)\nnan\n>>> np.log([-1, 1, 2])\narray([        NaN,  0.        ,  0.69314718])",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "newaxis",
            "content": "A convenient alias for None, useful for indexing arrays.\n\n.. rubric:: Examples\n\n>>> newaxis is None\nTrue\n>>> x = np.arange(3)\n>>> x\narray([0, 1, 2])\n>>> x[:, newaxis]\narray([[0],\n[1],\n[2]])\n>>> x[:, newaxis, newaxis]\narray([[[0]],\n[[1]],\n[[2]]])\n>>> x[:, newaxis] * x\narray([[0, 0, 0],\n[0, 1, 2],\n[0, 2, 4]])\n\nOuter product, same as ``outer(x, y)``:\n\n>>> y = np.arange(3, 6)\n>>> x[:, newaxis] * y\narray([[ 0,  0,  0],\n[ 3,  4,  5],\n[ 6,  8, 10]])\n\n``x[newaxis, :]`` is equivalent to ``x[newaxis]`` and ``x[None]``:\n\n>>> x[newaxis, :].shape\n(1, 3)\n>>> x[newaxis].shape\n(1, 3)\n>>> x[None].shape\n(1, 3)\n>>> x[:, newaxis].shape\n(3, 1)",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "argument": "pi",
            "content": "``pi = 3.1415926535897932384626433...``\n\n.. rubric:: References\n\nhttps://en.wikipedia.org/wiki/Pi",
            "name": "data",
            "options": []
          },
          "type": "BlockDirective"
        }
      ],
      "level": 0,
      "target": null,
      "title": null
    },
    "Methods": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Notes": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Parameters": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Raises": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Receives": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Returns": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Summary": {
      "children": [],
      "level": 0,
      "target": null,
      "title": "Constants"
    },
    "Warnings": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Warns": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Yields": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    }
  },
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null
  },
  "item_file": "/numpy/doc/constants.py",
  "item_line": 0,
  "item_type": "<class 'module'>",
  "ordered_sections": [
    "Summary",
    "Extended Summary"
  ],
  "references": null,
  "see_also": [],
  "signature": {
    "value": null
  }
}