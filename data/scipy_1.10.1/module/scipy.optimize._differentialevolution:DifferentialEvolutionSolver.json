{
  "aliases": [
    "scipy.optimize._differentialevolution.DifferentialEvolutionSolver"
  ],
  "arbitrary": [],
  "content": {
    "Attributes": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Extended Summary": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Methods": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Notes": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Other Parameters": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Parameters": {
      "children": [
        {
          "children": [
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The objective function to be minimized. Must be in the form "
                    },
                    {
                      "type": "inlineCode",
                      "value": "f(x, *args)"
                    },
                    {
                      "type": "text",
                      "value": ", where "
                    },
                    {
                      "type": "inlineCode",
                      "value": "x"
                    },
                    {
                      "type": "text",
                      "value": " is the argument in the form of a 1-D array and "
                    },
                    {
                      "type": "inlineCode",
                      "value": "args"
                    },
                    {
                      "type": "text",
                      "value": " is a tuple of any additional fixed parameters needed to completely specify the function. The number of parameters, N, is equal to "
                    },
                    {
                      "type": "inlineCode",
                      "value": "len(x)"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "func",
              "type": "Param",
              "type_": "callable"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Bounds for variables. There are two ways to specify the bounds: 1. Instance of "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "Bounds"
                    },
                    {
                      "type": "text",
                      "value": " class. 2. "
                    },
                    {
                      "type": "inlineCode",
                      "value": "(min, max)"
                    },
                    {
                      "type": "text",
                      "value": " pairs for each element in "
                    },
                    {
                      "type": "inlineCode",
                      "value": "x"
                    },
                    {
                      "type": "text",
                      "value": ", defining the finite lower and upper bounds for the optimizing argument of "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "func",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "func"
                    },
                    {
                      "type": "text",
                      "value": ". The total number of bounds is used to determine the number of parameters, N."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "bounds",
              "type": "Param",
              "type_": "sequence or `Bounds`"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Any additional fixed parameters needed to completely specify the objective function."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "args",
              "type": "Param",
              "type_": "tuple, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The differential evolution strategy to use. Should be one of:"
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "children": [
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "'best1bin'"
                                }
                              ],
                              "type": "paragraph"
                            }
                          ],
                          "spread": false,
                          "type": "listItem"
                        },
                        {
                          "children": [
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "'best1exp'"
                                }
                              ],
                              "type": "paragraph"
                            }
                          ],
                          "spread": false,
                          "type": "listItem"
                        },
                        {
                          "children": [
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "'rand1exp'"
                                }
                              ],
                              "type": "paragraph"
                            }
                          ],
                          "spread": false,
                          "type": "listItem"
                        },
                        {
                          "children": [
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "'randtobest1exp'"
                                }
                              ],
                              "type": "paragraph"
                            }
                          ],
                          "spread": false,
                          "type": "listItem"
                        },
                        {
                          "children": [
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "'currenttobest1exp'"
                                }
                              ],
                              "type": "paragraph"
                            }
                          ],
                          "spread": false,
                          "type": "listItem"
                        },
                        {
                          "children": [
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "'best2exp'"
                                }
                              ],
                              "type": "paragraph"
                            }
                          ],
                          "spread": false,
                          "type": "listItem"
                        },
                        {
                          "children": [
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "'rand2exp'"
                                }
                              ],
                              "type": "paragraph"
                            }
                          ],
                          "spread": false,
                          "type": "listItem"
                        },
                        {
                          "children": [
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "'randtobest1bin'"
                                }
                              ],
                              "type": "paragraph"
                            }
                          ],
                          "spread": false,
                          "type": "listItem"
                        },
                        {
                          "children": [
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "'currenttobest1bin'"
                                }
                              ],
                              "type": "paragraph"
                            }
                          ],
                          "spread": false,
                          "type": "listItem"
                        },
                        {
                          "children": [
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "'best2bin'"
                                }
                              ],
                              "type": "paragraph"
                            }
                          ],
                          "spread": false,
                          "type": "listItem"
                        },
                        {
                          "children": [
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "'rand2bin'"
                                }
                              ],
                              "type": "paragraph"
                            }
                          ],
                          "spread": false,
                          "type": "listItem"
                        },
                        {
                          "children": [
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "'rand1bin'"
                                }
                              ],
                              "type": "paragraph"
                            }
                          ],
                          "spread": false,
                          "type": "listItem"
                        }
                      ],
                      "ordered": false,
                      "spread": false,
                      "start": 1,
                      "type": "list"
                    }
                  ],
                  "type": "blockquote"
                },
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The default is 'best1bin'"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "strategy",
              "type": "Param",
              "type_": "str, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The maximum number of generations over which the entire population is evolved. The maximum number of function evaluations (with no polishing) is: "
                    },
                    {
                      "type": "inlineCode",
                      "value": "(maxiter + 1) * popsize * N"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "maxiter",
              "type": "Param",
              "type_": "int, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "A multiplier for setting the total population size. The population has "
                    },
                    {
                      "type": "inlineCode",
                      "value": "popsize * N"
                    },
                    {
                      "type": "text",
                      "value": " individuals. This keyword is overridden if an initial population is supplied via the "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "init",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "init"
                    },
                    {
                      "type": "text",
                      "value": " keyword. When using "
                    },
                    {
                      "type": "inlineCode",
                      "value": "init='sobol'"
                    },
                    {
                      "type": "text",
                      "value": " the population size is calculated as the next power of 2 after "
                    },
                    {
                      "type": "inlineCode",
                      "value": "popsize * N"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "popsize",
              "type": "Param",
              "type_": "int, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Relative tolerance for convergence, the solving stops when "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.std(pop) <= atol + tol * np.abs(np.mean(population_energies))"
                    },
                    {
                      "type": "text",
                      "value": ", where and "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "atol",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "atol"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "tol",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "tol"
                    },
                    {
                      "type": "text",
                      "value": " are the absolute and relative tolerance respectively."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "tol",
              "type": "Param",
              "type_": "float, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The mutation constant. In the literature this is also known as differential weight, being denoted by F. If specified as a float it should be in the range [0, 2]. If specified as a tuple "
                    },
                    {
                      "type": "inlineCode",
                      "value": "(min, max)"
                    },
                    {
                      "type": "text",
                      "value": " dithering is employed. Dithering randomly changes the mutation constant on a generation by generation basis. The mutation constant for that generation is taken from U[min, max). Dithering can help speed convergence significantly. Increasing the mutation constant increases the search radius, but will slow down convergence."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "mutation",
              "type": "Param",
              "type_": "float or tuple(float, float), optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The recombination constant, should be in the range [0, 1]. In the literature this is also known as the crossover probability, being denoted by CR. Increasing this value allows a larger number of mutants to progress into the next generation, but at the risk of population stability."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "recombination",
              "type": "Param",
              "type_": "float, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "If "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "seed",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "seed"
                    },
                    {
                      "type": "text",
                      "value": " is None (or "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "np.random"
                    },
                    {
                      "type": "text",
                      "value": "), the "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "module",
                      "reference": {
                        "kind": "api",
                        "module": "numpy.random.mtrand",
                        "path": "numpy.random.mtrand:RandomState",
                        "type": "RefInfo",
                        "version": "*"
                      },
                      "type": "Link",
                      "value": "numpy.random.RandomState"
                    },
                    {
                      "type": "text",
                      "value": " singleton is used. If "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "seed",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "seed"
                    },
                    {
                      "type": "text",
                      "value": " is an int, a new "
                    },
                    {
                      "type": "inlineCode",
                      "value": "RandomState"
                    },
                    {
                      "type": "text",
                      "value": " instance is used, seeded with "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "seed",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "seed"
                    },
                    {
                      "type": "text",
                      "value": ". If "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "seed",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "seed"
                    },
                    {
                      "type": "text",
                      "value": " is already a "
                    },
                    {
                      "type": "inlineCode",
                      "value": "Generator"
                    },
                    {
                      "type": "text",
                      "value": " or "
                    },
                    {
                      "type": "inlineCode",
                      "value": "RandomState"
                    },
                    {
                      "type": "text",
                      "value": " instance then that instance is used. Specify "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "seed",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "seed"
                    },
                    {
                      "type": "text",
                      "value": " for repeatable minimizations."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "seed",
              "type": "Param",
              "type_": "{None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Prints the evaluated "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "func",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "func"
                    },
                    {
                      "type": "text",
                      "value": " at every iteration."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "disp",
              "type": "Param",
              "type_": "bool, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "A function to follow the progress of the minimization. "
                    },
                    {
                      "type": "inlineCode",
                      "value": "xk"
                    },
                    {
                      "type": "text",
                      "value": " is the current value of "
                    },
                    {
                      "type": "inlineCode",
                      "value": "x0"
                    },
                    {
                      "type": "text",
                      "value": ". "
                    },
                    {
                      "type": "inlineCode",
                      "value": "val"
                    },
                    {
                      "type": "text",
                      "value": " represents the fractional value of the population convergence. When "
                    },
                    {
                      "type": "inlineCode",
                      "value": "val"
                    },
                    {
                      "type": "text",
                      "value": " is greater than one the function halts. If callback returns "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "True"
                    },
                    {
                      "type": "text",
                      "value": ", then the minimization is halted (any polishing is still carried out)."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "callback",
              "type": "Param",
              "type_": "callable, `callback(xk, convergence=val)`, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "If True (default), then "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "module",
                      "reference": {
                        "kind": "api",
                        "module": "scipy.optimize._minimize",
                        "path": "scipy.optimize._minimize:minimize",
                        "type": "RefInfo",
                        "version": "*"
                      },
                      "type": "Link",
                      "value": "scipy.optimize.minimize"
                    },
                    {
                      "type": "text",
                      "value": " with the "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "L-BFGS-B"
                    },
                    {
                      "type": "text",
                      "value": " method is used to polish the best population member at the end, which can improve the minimization slightly. If a constrained problem is being studied then the "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "trust-constr"
                    },
                    {
                      "type": "text",
                      "value": " method is used instead. For large problems with many constraints, polishing can take a long time due to the Jacobian computations."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "polish",
              "type": "Param",
              "type_": "bool, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Set the maximum number of function evaluations. However, it probably makes more sense to set "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "maxiter",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "maxiter"
                    },
                    {
                      "type": "text",
                      "value": " instead."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "maxfun",
              "type": "Param",
              "type_": "int, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Specify which type of population initialization is performed. Should be one of:"
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "children": [
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "'latinhypercube'"
                                }
                              ],
                              "type": "paragraph"
                            }
                          ],
                          "spread": false,
                          "type": "listItem"
                        },
                        {
                          "children": [
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "'sobol'"
                                }
                              ],
                              "type": "paragraph"
                            }
                          ],
                          "spread": false,
                          "type": "listItem"
                        },
                        {
                          "children": [
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "'halton'"
                                }
                              ],
                              "type": "paragraph"
                            }
                          ],
                          "spread": false,
                          "type": "listItem"
                        },
                        {
                          "children": [
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "'random'"
                                }
                              ],
                              "type": "paragraph"
                            }
                          ],
                          "spread": false,
                          "type": "listItem"
                        },
                        {
                          "children": [
                            {
                              "children": [
                                {
                                  "type": "text",
                                  "value": "array specifying the initial population. The array should have       shape "
                                },
                                {
                                  "type": "inlineCode",
                                  "value": "(S, N)"
                                },
                                {
                                  "type": "text",
                                  "value": ", where S is the total population size and       N is the number of parameters.       "
                                },
                                {
                                  "anchor": null,
                                  "exists": true,
                                  "kind": "local",
                                  "reference": {
                                    "kind": "local",
                                    "module": null,
                                    "path": "init",
                                    "type": "RefInfo",
                                    "version": null
                                  },
                                  "type": "Link",
                                  "value": "init"
                                },
                                {
                                  "type": "text",
                                  "value": " is clipped to "
                                },
                                {
                                  "anchor": null,
                                  "exists": true,
                                  "kind": "local",
                                  "reference": {
                                    "kind": "local",
                                    "module": null,
                                    "path": "bounds",
                                    "type": "RefInfo",
                                    "version": null
                                  },
                                  "type": "Link",
                                  "value": "bounds"
                                },
                                {
                                  "type": "text",
                                  "value": " before use."
                                }
                              ],
                              "type": "paragraph"
                            }
                          ],
                          "spread": false,
                          "type": "listItem"
                        }
                      ],
                      "ordered": false,
                      "spread": false,
                      "start": 1,
                      "type": "list"
                    }
                  ],
                  "type": "blockquote"
                },
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The default is 'latinhypercube'. Latin Hypercube sampling tries to maximize coverage of the available parameter space."
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "'sobol' and 'halton' are superior alternatives and maximize even more the parameter space. 'sobol' will enforce an initial population size which is calculated as the next power of 2 after "
                    },
                    {
                      "type": "inlineCode",
                      "value": "popsize * N"
                    },
                    {
                      "type": "text",
                      "value": ". 'halton' has no requirements but is a bit less efficient. See "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "module",
                      "reference": {
                        "kind": "module",
                        "module": "scipy",
                        "path": "scipy.stats.qmc",
                        "type": "RefInfo",
                        "version": "1.10.1"
                      },
                      "type": "Link",
                      "value": "scipy.stats.qmc"
                    },
                    {
                      "type": "text",
                      "value": " for more details."
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "'random' initializes the population randomly - this has the drawback that clustering can occur, preventing the whole of parameter space being covered. Use of an array to specify a population could be used, for example, to create a tight bunch of initial guesses in an location where the solution is known to exist, thereby reducing time for convergence."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "init",
              "type": "Param",
              "type_": "str or array-like, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Absolute tolerance for convergence, the solving stops when "
                    },
                    {
                      "type": "inlineCode",
                      "value": "np.std(pop) <= atol + tol * np.abs(np.mean(population_energies))"
                    },
                    {
                      "type": "text",
                      "value": ", where and "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "atol",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "atol"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "tol",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "tol"
                    },
                    {
                      "type": "text",
                      "value": " are the absolute and relative tolerance respectively."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "atol",
              "type": "Param",
              "type_": "float, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "If "
                    },
                    {
                      "type": "inlineCode",
                      "value": "'immediate'"
                    },
                    {
                      "type": "text",
                      "value": ", the best solution vector is continuously updated within a single generation . This can lead to faster convergence as trial vectors can take advantage of continuous improvements in the best solution. With "
                    },
                    {
                      "type": "inlineCode",
                      "value": "'deferred'"
                    },
                    {
                      "type": "text",
                      "value": ", the best solution vector is updated once per generation. Only "
                    },
                    {
                      "type": "inlineCode",
                      "value": "'deferred'"
                    },
                    {
                      "type": "text",
                      "value": " is compatible with parallelization or vectorization, and the "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "workers",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "workers"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "vectorized",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "vectorized"
                    },
                    {
                      "type": "text",
                      "value": " keywords can over-ride this option."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "updating",
              "type": "Param",
              "type_": "{'immediate', 'deferred'}, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "If "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "workers",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "workers"
                    },
                    {
                      "type": "text",
                      "value": " is an int the population is subdivided into "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "workers",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "workers"
                    },
                    {
                      "type": "text",
                      "value": " sections and evaluated in parallel (uses "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "multiprocessing.Pool <multiprocessing>"
                    },
                    {
                      "type": "text",
                      "value": "). Supply "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "-1"
                    },
                    {
                      "type": "text",
                      "value": " to use all cores available to the Process. Alternatively supply a map-like callable, such as "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "multiprocessing.Pool.map"
                    },
                    {
                      "type": "text",
                      "value": " for evaluating the population in parallel. This evaluation is carried out as "
                    },
                    {
                      "type": "inlineCode",
                      "value": "workers(func, iterable)"
                    },
                    {
                      "type": "text",
                      "value": ". This option will override the "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "updating",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "updating"
                    },
                    {
                      "type": "text",
                      "value": " keyword to "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "updating='deferred'"
                    },
                    {
                      "type": "text",
                      "value": " if "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "workers != 1"
                    },
                    {
                      "type": "text",
                      "value": ". Requires that "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "func",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "func"
                    },
                    {
                      "type": "text",
                      "value": " be pickleable."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "workers",
              "type": "Param",
              "type_": "int or map-like callable, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Constraints on the solver, over and above those applied by the "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "bounds",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "bounds"
                    },
                    {
                      "type": "text",
                      "value": " kwd. Uses the approach by Lampinen."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "constraints",
              "type": "Param",
              "type_": "{NonLinearConstraint, LinearConstraint, Bounds}"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Provides an initial guess to the minimization. Once the population has been initialized this vector replaces the first (best) member. This replacement is done even if "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "init",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "init"
                    },
                    {
                      "type": "text",
                      "value": " is given an initial population. "
                    },
                    {
                      "type": "inlineCode",
                      "value": "x0.shape == (N,)"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "x0",
              "type": "Param",
              "type_": "None or array-like, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "For each decision variable, a boolean value indicating whether the decision variable is constrained to integer values. The array is broadcast to "
                    },
                    {
                      "type": "inlineCode",
                      "value": "(N,)"
                    },
                    {
                      "type": "text",
                      "value": ". If any decision variables are constrained to be integral, they will not be changed during polishing. Only integer values lying between the lower and upper bounds are used. If there are no integer values lying between the bounds then a "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "ValueError"
                    },
                    {
                      "type": "text",
                      "value": " is raised."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "integrality",
              "type": "Param",
              "type_": "1-D array, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "If "
                    },
                    {
                      "type": "inlineCode",
                      "value": "vectorized is True"
                    },
                    {
                      "type": "text",
                      "value": ", "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "func",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "func"
                    },
                    {
                      "type": "text",
                      "value": " is sent an "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "x"
                    },
                    {
                      "type": "text",
                      "value": " array with "
                    },
                    {
                      "type": "inlineCode",
                      "value": "x.shape == (N, S)"
                    },
                    {
                      "type": "text",
                      "value": ", and is expected to return an array of shape "
                    },
                    {
                      "type": "inlineCode",
                      "value": "(S,)"
                    },
                    {
                      "type": "text",
                      "value": ", where "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "S"
                    },
                    {
                      "type": "text",
                      "value": " is the number of solution vectors to be calculated. If constraints are applied, each of the functions used to construct a "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "Constraint"
                    },
                    {
                      "type": "text",
                      "value": " object should accept an "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "x"
                    },
                    {
                      "type": "text",
                      "value": " array with "
                    },
                    {
                      "type": "inlineCode",
                      "value": "x.shape == (N, S)"
                    },
                    {
                      "type": "text",
                      "value": ", and return an array of shape "
                    },
                    {
                      "type": "inlineCode",
                      "value": "(M, S)"
                    },
                    {
                      "type": "text",
                      "value": ", where "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "M"
                    },
                    {
                      "type": "text",
                      "value": " is the number of constraint components. This option is an alternative to the parallelization offered by "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "workers",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "workers"
                    },
                    {
                      "type": "text",
                      "value": ", and may help in optimization speed. This keyword is ignored if "
                    },
                    {
                      "type": "inlineCode",
                      "value": "workers != 1"
                    },
                    {
                      "type": "text",
                      "value": ". This option will override the "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "updating",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "updating"
                    },
                    {
                      "type": "text",
                      "value": " keyword to "
                    },
                    {
                      "type": "inlineCode",
                      "value": "updating='deferred'"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "vectorized",
              "type": "Param",
              "type_": "bool, optional"
            }
          ],
          "type": "Parameters"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Raises": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Receives": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Returns": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Summary": {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "This class implements the differential evolution solver"
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Warnings": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Warns": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Yields": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    }
  },
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null,
    "type": "Section"
  },
  "item_file": "/scipy/optimize/_differentialevolution.py",
  "item_line": 402,
  "item_type": "<class 'type'>",
  "ordered_sections": [
    "Summary",
    "Parameters"
  ],
  "references": null,
  "see_also": [],
  "signature": {
    "type": "Signature",
    "value": null
  },
  "type": "DocBlob"
}