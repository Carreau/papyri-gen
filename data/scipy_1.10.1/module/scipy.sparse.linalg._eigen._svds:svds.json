{
  "aliases": [
    "scipy.sparse.linalg.svds"
  ],
  "arbitrary": [],
  "content": {
    "Attributes": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Extended Summary": {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Compute the largest or smallest "
            },
            {
              "anchor": null,
              "exists": true,
              "kind": "local",
              "reference": {
                "kind": "local",
                "module": null,
                "path": "k",
                "type": "RefInfo",
                "version": null
              },
              "type": "Link",
              "value": "k"
            },
            {
              "type": "text",
              "value": " singular values and corresponding singular vectors of a sparse matrix "
            },
            {
              "anchor": null,
              "exists": true,
              "kind": "local",
              "reference": {
                "kind": "local",
                "module": null,
                "path": "A",
                "type": "RefInfo",
                "version": null
              },
              "type": "Link",
              "value": "A"
            },
            {
              "type": "text",
              "value": ". The order in which the singular values are returned is not guaranteed."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "In the descriptions below, let "
            },
            {
              "type": "inlineCode",
              "value": "M, N = A.shape"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Methods": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Notes": {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "This is a naive implementation using ARPACK or LOBPCG as an eigensolver on the matrix "
            },
            {
              "type": "inlineCode",
              "value": "A.conj().T @ A"
            },
            {
              "type": "text",
              "value": " or "
            },
            {
              "type": "inlineCode",
              "value": "A @ A.conj().T"
            },
            {
              "type": "text",
              "value": ", depending on which one is smaller size, followed by the Rayleigh-Ritz method as postprocessing; see Using the normal matrix, in Rayleigh-Ritz method, (2022, Nov. 19), Wikipedia, https://w.wiki/4zms."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Alternatively, the PROPACK solver can be called. "
            },
            {
              "type": "inlineCode",
              "value": "form=\"array\""
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Choices of the input matrix "
            },
            {
              "type": "inlineCode",
              "value": "A"
            },
            {
              "type": "text",
              "value": " numeric dtype may be limited. Only "
            },
            {
              "type": "inlineCode",
              "value": "solver=\"lobpcg\""
            },
            {
              "type": "text",
              "value": " supports all floating point dtypes real: 'np.single', 'np.double', 'np.longdouble' and complex: 'np.csingle', 'np.cdouble', 'np.clongdouble'. The "
            },
            {
              "type": "inlineCode",
              "value": "solver=\"arpack\""
            },
            {
              "type": "text",
              "value": " supports only 'np.single', 'np.double', and 'np.cdouble'."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Other Parameters": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Parameters": {
      "children": [
        {
          "children": [
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Matrix to decompose of a floating point numeric dtype."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "A",
              "type": "Param",
              "type_": "ndarray, sparse matrix, or LinearOperator"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Number of singular values and singular vectors to compute. Must satisfy "
                    },
                    {
                      "type": "inlineCode",
                      "value": "1 <= k <= kmax"
                    },
                    {
                      "type": "text",
                      "value": ", where "
                    },
                    {
                      "type": "inlineCode",
                      "value": "kmax=min(M, N)"
                    },
                    {
                      "type": "text",
                      "value": " for "
                    },
                    {
                      "type": "inlineCode",
                      "value": "solver='propack'"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "type": "inlineCode",
                      "value": "kmax=min(M, N) - 1"
                    },
                    {
                      "type": "text",
                      "value": " otherwise."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "k",
              "type": "Param",
              "type_": "int, default: 6"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "When "
                    },
                    {
                      "type": "inlineCode",
                      "value": "solver='arpack'"
                    },
                    {
                      "type": "text",
                      "value": ", this is the number of Lanczos vectors generated. See "
                    },
                    {
                      "type": "inlineCode",
                      "value": "'arpack' <sparse.linalg.svds-arpack>"
                    },
                    {
                      "type": "text",
                      "value": " for details. When "
                    },
                    {
                      "type": "inlineCode",
                      "value": "solver='lobpcg'"
                    },
                    {
                      "type": "text",
                      "value": " or "
                    },
                    {
                      "type": "inlineCode",
                      "value": "solver='propack'"
                    },
                    {
                      "type": "text",
                      "value": ", this parameter is ignored."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "ncv",
              "type": "Param",
              "type_": "int, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Tolerance for singular values. Zero (default) means machine precision."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "tol",
              "type": "Param",
              "type_": "float, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Which "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "k",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "k"
                    },
                    {
                      "type": "text",
                      "value": " singular values to find: either the largest magnitude ('LM') or smallest magnitude ('SM') singular values."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "which",
              "type": "Param",
              "type_": "{'LM', 'SM'}"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The starting vector for iteration; see method-specific documentation ("
                    },
                    {
                      "type": "inlineCode",
                      "value": "'arpack' <sparse.linalg.svds-arpack>"
                    },
                    {
                      "type": "text",
                      "value": ", "
                    },
                    {
                      "type": "inlineCode",
                      "value": "'lobpcg' <sparse.linalg.svds-lobpcg>"
                    },
                    {
                      "type": "text",
                      "value": "), or "
                    },
                    {
                      "type": "inlineCode",
                      "value": "'propack' <sparse.linalg.svds-propack>"
                    },
                    {
                      "type": "text",
                      "value": " for details."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "v0",
              "type": "Param",
              "type_": "ndarray, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Maximum number of iterations; see method-specific documentation ("
                    },
                    {
                      "type": "inlineCode",
                      "value": "'arpack' <sparse.linalg.svds-arpack>"
                    },
                    {
                      "type": "text",
                      "value": ", "
                    },
                    {
                      "type": "inlineCode",
                      "value": "'lobpcg' <sparse.linalg.svds-lobpcg>"
                    },
                    {
                      "type": "text",
                      "value": "), or "
                    },
                    {
                      "type": "inlineCode",
                      "value": "'propack' <sparse.linalg.svds-propack>"
                    },
                    {
                      "type": "text",
                      "value": " for details."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "maxiter",
              "type": "Param",
              "type_": "int, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Singular values are always computed and returned; this parameter controls the computation and return of singular vectors."
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "children": [
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": "True"
                            },
                            {
                              "type": "text",
                              "value": ": return singular vectors."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": "False"
                            },
                            {
                              "type": "text",
                              "value": ": do not return singular vectors."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": "\"u\""
                            },
                            {
                              "type": "text",
                              "value": ": if "
                            },
                            {
                              "type": "inlineCode",
                              "value": "M <= N"
                            },
                            {
                              "type": "text",
                              "value": ", compute only the left singular vectors and   return "
                            },
                            {
                              "type": "inlineCode",
                              "value": "None"
                            },
                            {
                              "type": "text",
                              "value": " for the right singular vectors. Otherwise, compute   all singular vectors."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    },
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "type": "inlineCode",
                              "value": "\"vh\""
                            },
                            {
                              "type": "text",
                              "value": ": if "
                            },
                            {
                              "type": "inlineCode",
                              "value": "M > N"
                            },
                            {
                              "type": "text",
                              "value": ", compute only the right singular vectors and   return "
                            },
                            {
                              "type": "inlineCode",
                              "value": "None"
                            },
                            {
                              "type": "text",
                              "value": " for the left singular vectors. Otherwise, compute   all singular vectors."
                            }
                          ],
                          "type": "paragraph"
                        }
                      ],
                      "spread": false,
                      "type": "listItem"
                    }
                  ],
                  "ordered": false,
                  "spread": false,
                  "start": 1,
                  "type": "list"
                },
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "If "
                    },
                    {
                      "type": "inlineCode",
                      "value": "solver='propack'"
                    },
                    {
                      "type": "text",
                      "value": ", the option is respected regardless of the matrix shape."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "return_singular_vectors",
              "type": "Param",
              "type_": "{True, False, \"u\", \"vh\"}"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The solver used. "
                    },
                    {
                      "type": "inlineCode",
                      "value": "'arpack' <sparse.linalg.svds-arpack>"
                    },
                    {
                      "type": "text",
                      "value": ", "
                    },
                    {
                      "type": "inlineCode",
                      "value": "'lobpcg' <sparse.linalg.svds-lobpcg>"
                    },
                    {
                      "type": "text",
                      "value": ", and "
                    },
                    {
                      "type": "inlineCode",
                      "value": "'propack' <sparse.linalg.svds-propack>"
                    },
                    {
                      "type": "text",
                      "value": " are supported. Default: "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "'arpack'"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "solver",
              "type": "Param",
              "type_": "{'arpack', 'propack', 'lobpcg'}, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "children": [
                        {
                          "anchor": null,
                          "exists": true,
                          "kind": "module",
                          "reference": {
                            "kind": "api",
                            "module": "numpy.random.mtrand",
                            "path": "numpy.random.mtrand:RandomState",
                            "type": "RefInfo",
                            "version": "*"
                          },
                          "type": "Link",
                          "value": "numpy.random.RandomState"
                        },
                        {
                          "type": "text",
                          "value": "}, optional"
                        }
                      ],
                      "type": "paragraph"
                    }
                  ],
                  "type": "blockquote"
                },
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Pseudorandom number generator state used to generate resamples."
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "If "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "random_state",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "random_state"
                    },
                    {
                      "type": "text",
                      "value": " is "
                    },
                    {
                      "type": "inlineCode",
                      "value": "None"
                    },
                    {
                      "type": "text",
                      "value": " (or "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "np.random"
                    },
                    {
                      "type": "text",
                      "value": "), the "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "module",
                      "reference": {
                        "kind": "api",
                        "module": "numpy.random.mtrand",
                        "path": "numpy.random.mtrand:RandomState",
                        "type": "RefInfo",
                        "version": "*"
                      },
                      "type": "Link",
                      "value": "numpy.random.RandomState"
                    },
                    {
                      "type": "text",
                      "value": " singleton is used. If "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "random_state",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "random_state"
                    },
                    {
                      "type": "text",
                      "value": " is an int, a new "
                    },
                    {
                      "type": "inlineCode",
                      "value": "RandomState"
                    },
                    {
                      "type": "text",
                      "value": " instance is used, seeded with "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "random_state",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "random_state"
                    },
                    {
                      "type": "text",
                      "value": ". If "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "random_state",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "random_state"
                    },
                    {
                      "type": "text",
                      "value": " is already a "
                    },
                    {
                      "type": "inlineCode",
                      "value": "Generator"
                    },
                    {
                      "type": "text",
                      "value": " or "
                    },
                    {
                      "type": "inlineCode",
                      "value": "RandomState"
                    },
                    {
                      "type": "text",
                      "value": " instance then that instance is used."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "random_state",
              "type": "Param",
              "type_": "{None, int, `numpy.random.Generator`,"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "A dictionary of solver-specific options. No solver-specific options are currently supported; this parameter is reserved for future use."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "options",
              "type": "Param",
              "type_": "dict, optional"
            }
          ],
          "type": "Parameters"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Raises": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Receives": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Returns": {
      "children": [
        {
          "children": [
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Unitary matrix having left singular vectors as columns."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "u",
              "type": "Param",
              "type_": "ndarray, shape=(M, k)"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The singular values."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "s",
              "type": "Param",
              "type_": "ndarray, shape=(k,)"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Unitary matrix having right singular vectors as rows."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "vh",
              "type": "Param",
              "type_": "ndarray, shape=(k, N)"
            }
          ],
          "type": "Parameters"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Summary": {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Partial singular value decomposition of a sparse matrix."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Warnings": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Warns": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Yields": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    }
  },
  "example_section_data": {
    "children": [
      {
        "type": "text",
        "value": "Construct a matrix ``A`` from singular values and vectors."
      },
      {
        "type": "code",
        "value": "import numpy as np\nfrom scipy.stats import ortho_group\nfrom scipy.sparse.linalg import svds\nfrom scipy.sparse import csr_matrix\nrng = np.random.default_rng()"
      },
      {
        "type": "text",
        "value": "Construct a dense matrix ``A`` from singular values and vectors."
      },
      {
        "type": "code",
        "value": "orthogonal = ortho_group.rvs(10, random_state=rng)\ns = [1e-3, 1, 2, 3, 4]  # non-zero singular values\nu = orthogonal[:, :5]         # left singular vectors\nvT = orthogonal[:, 5:].T      # right singular vectors\nA = u @ np.diag(s) @ vT"
      },
      {
        "type": "text",
        "value": "With only four singular values/vectors, the SVD approximates the original\nmatrix."
      },
      {
        "type": "code",
        "value": "u4, s4, vT4 = svds(A, k=4)\nA4 = u4 @ np.diag(s4) @ vT4\nnp.allclose(A4, A, atol=1e-3)"
      },
      {
        "type": "text",
        "value": "With all five non-zero singular values/vectors, we can reproduce\nthe original matrix more accurately."
      },
      {
        "type": "code",
        "value": "u5, s5, vT5 = svds(A, k=5)\nA5 = u5 @ np.diag(s5) @ vT5\nnp.allclose(A5, A)"
      },
      {
        "type": "text",
        "value": "The singular values match the expected singular values."
      },
      {
        "type": "code",
        "value": "np.allclose(s5, s)"
      },
      {
        "type": "text",
        "value": "Since the singular values are not close to each other in this example,\nevery singular vector matches as expected up to a difference in sign."
      },
      {
        "type": "code",
        "value": "(np.allclose(np.abs(u5), np.abs(u)) and\n np.allclose(np.abs(vT5), np.abs(vT)))"
      },
      {
        "type": "text",
        "value": "The singular vectors are also orthogonal."
      },
      {
        "type": "code",
        "value": "(np.allclose(u5.T @ u5, np.eye(5)) and\n np.allclose(vT5 @ vT5.T, np.eye(5)))"
      },
      {
        "type": "text",
        "value": "If there are (nearly) multiple singular values, the corresponding\nindividual singular vectors may be unstable, but the whole invariant\nsubspace containing all such singular vectors is computed accurately\nas can be measured by angles between subspaces via 'subspace_angles'."
      },
      {
        "type": "code",
        "value": "from scipy.linalg import subspace_angles as s_a\nrng = np.random.default_rng()\ns = [1, 1 + 1e-6]  # non-zero singular values\nu, _ = np.linalg.qr(rng.standard_normal((99, 2)))\nv, _ = np.linalg.qr(rng.standard_normal((99, 2)))\nvT = v.T\nA = u @ np.diag(s) @ vT\nA = A.astype(np.float32)\nu2, s2, vT2 = svds(A, k=2)\nnp.allclose(s2, s)"
      },
      {
        "type": "text",
        "value": "The angles between the individual exact and computed singular vectors\nare not so small."
      },
      {
        "type": "code",
        "value": "s_a(u2[:, :1], u[:, :1]) + s_a(u2[:, 1:], u[:, 1:]) > 1e-3"
      },
      {
        "type": "code",
        "value": "(s_a(vT2[:1, :].T, vT[:1, :].T) +\n s_a(vT2[1:, :].T, vT[1:, :].T)) > 1e-3"
      },
      {
        "type": "text",
        "value": "As opposed to the angles between the 2-dimensional invariant subspaces\nthat these vectors span, which are small for rights singular vectors"
      },
      {
        "type": "code",
        "value": "s_a(u2, u).sum() < 1e-6"
      },
      {
        "type": "text",
        "value": "as well as for left singular vectors."
      },
      {
        "type": "code",
        "value": "s_a(vT2.T, vT.T).sum() < 1e-6"
      },
      {
        "type": "text",
        "value": "The next example follows that of 'sklearn.decomposition.TruncatedSVD'."
      },
      {
        "type": "code",
        "value": "rng = np.random.RandomState(0)\nX_dense = rng.random(size=(100, 100))\nX_dense[:, 2 * np.arange(50)] = 0\nX = csr_matrix(X_dense)\n_, singular_values, _ = svds(X, k=5)\nprint(singular_values)"
      },
      {
        "type": "text",
        "value": "The function can be called without the transpose of the input matrix\never explicitly constructed."
      },
      {
        "type": "code",
        "value": "from scipy.linalg import svd\nfrom scipy.sparse import rand\nfrom scipy.sparse.linalg import aslinearoperator\nrng = np.random.RandomState(0)\nG = rand(8, 9, density=0.5, random_state=rng)\nGlo = aslinearoperator(G)\n_, singular_values_svds, _ = svds(Glo, k=5)\n_, singular_values_svd, _ = svd(G.toarray())\nnp.allclose(singular_values_svds, singular_values_svd[-4::-1])"
      },
      {
        "type": "text",
        "value": "The most memory efficient scenario is where neither\nthe original matrix, nor its transpose, is explicitly constructed.\nOur example computes the smallest singular values and vectors\nof 'LinearOperator' constructed from the numpy function 'np.diff' used\ncolumn-wise to be consistent with 'LinearOperator' operating on columns."
      },
      {
        "type": "code",
        "value": "from scipy.sparse.linalg import LinearOperator, aslinearoperator\ndiff0 = lambda a: np.diff(a, axis=0)"
      },
      {
        "type": "text",
        "value": "Let us create the matrix from 'diff0' to be used for validation only."
      },
      {
        "type": "code",
        "value": "n = 5  # The dimension of the space.\nM_from_diff0 = diff0(np.eye(n))\nprint(M_from_diff0.astype(int))"
      },
      {
        "type": "text",
        "value": "The matrix 'M_from_diff0' is bi-diagonal and could be alternatively\ncreated directly by"
      },
      {
        "type": "code",
        "value": "M = - np.eye(n - 1, n, dtype=int)\nnp.fill_diagonal(M[:,1:], 1)\nnp.allclose(M, M_from_diff0)"
      },
      {
        "type": "text",
        "value": "Its transpose"
      },
      {
        "type": "code",
        "value": "print(M.T)"
      },
      {
        "type": "text",
        "value": "can be viewed as the incidence matrix; see\nIncidence matrix, (2022, Nov. 19), Wikipedia, https://w.wiki/5YXU,\nof a linear graph with 5 vertices and 4 edges. The 5x5 normal matrix\n'M.T @ M' thus is"
      },
      {
        "type": "code",
        "value": "print(M.T @ M)"
      },
      {
        "type": "text",
        "value": "the graph Laplacian, while the actually used in 'svds' smaller size\n4x4 normal matrix 'M @ M.T'"
      },
      {
        "type": "code",
        "value": "print(M @ M.T)"
      },
      {
        "type": "text",
        "value": "is the so-called edge-based Laplacian; see\nSymmetric Laplacian via the incidence matrix, in Laplacian matrix,\n(2022, Nov. 19), Wikipedia, https://w.wiki/5YXW."
      },
      {
        "type": "text",
        "value": "The 'LinearOperator' setup needs the options 'rmatvec' and 'rmatmat'\nof multiplication by the matrix transpose 'M.T', but we want to be\nmatrix-free to save memory, so knowing how 'M.T' looks like, we\nmanually construct the following function to be used in 'rmatmat=diff0t'."
      },
      {
        "type": "code",
        "value": "def diff0t(a):\n    if a.ndim == 1:\n        a = a[:,np.newaxis]  # Turn 1D into 2D array\n    d = np.zeros((a.shape[0] + 1, a.shape[1]), dtype=a.dtype)\n    d[0, :] = - a[0, :]\n    d[1:-1, :] = a[0:-1, :] - a[1:, :]\n    d[-1, :] = a[-1, :]\n    return d"
      },
      {
        "type": "text",
        "value": "We check that our function 'diff0t' for the matrix transpose is valid."
      },
      {
        "type": "code",
        "value": "np.allclose(M.T, diff0t(np.eye(n-1)))"
      },
      {
        "type": "text",
        "value": "Now we setup our matrix-free 'LinearOperator' called 'diff0_func_aslo'\nand for validation the matrix-based 'diff0_matrix_aslo'."
      },
      {
        "type": "code",
        "value": "def diff0_func_aslo_def(n):\n    return LinearOperator(matvec=diff0,\n                          matmat=diff0,\n                          rmatvec=diff0t,\n                          rmatmat=diff0t,\n                          shape=(n - 1, n))\ndiff0_func_aslo = diff0_func_aslo_def(n)\ndiff0_matrix_aslo = aslinearoperator(M_from_diff0)"
      },
      {
        "type": "text",
        "value": "And validate both the matrix and its transpose in 'LinearOperator'."
      },
      {
        "type": "code",
        "value": "np.allclose(diff0_func_aslo(np.eye(n)),\n            diff0_matrix_aslo(np.eye(n)))"
      },
      {
        "type": "code",
        "value": "np.allclose(diff0_func_aslo.T(np.eye(n-1)),\n            diff0_matrix_aslo.T(np.eye(n-1)))"
      },
      {
        "type": "text",
        "value": "Having the 'LinearOperator' setup validated, we run the solver."
      },
      {
        "type": "code",
        "value": "n = 100\ndiff0_func_aslo = diff0_func_aslo_def(n)\nu, s, vT = svds(diff0_func_aslo, k=3, which='SM')"
      },
      {
        "type": "text",
        "value": "The singular values squared and the singular vectors are known\nexplicitly; see\nPure Dirichlet boundary conditions, in\nEigenvalues and eigenvectors of the second derivative,\n(2022, Nov. 19), Wikipedia, https://w.wiki/5YX6,\nsince 'diff' corresponds to first\nderivative, and its smaller size n-1 x n-1 normal matrix\n'M @ M.T' represent the discrete second derivative with the Dirichlet\nboundary conditions. We use these analytic expressions for validation."
      },
      {
        "type": "code",
        "value": "se = 2. * np.sin(np.pi * np.arange(1, 4) / (2. * n))\nue = np.sqrt(2 / n) * np.sin(np.pi * np.outer(np.arange(1, n),\n                             np.arange(1, 4)) / n)\nnp.allclose(s, se, atol=1e-3)"
      },
      {
        "type": "code",
        "value": "print(np.allclose(np.abs(u), np.abs(ue), atol=1e-6))"
      }
    ],
    "level": 0,
    "target": null,
    "title": null,
    "type": "Section"
  },
  "item_file": "/scipy/sparse/linalg/_eigen/_svds.py",
  "item_line": 104,
  "item_type": "<class 'function'>",
  "ordered_sections": [
    "Summary",
    "Extended Summary",
    "Parameters",
    "Returns",
    "Notes",
    "Examples"
  ],
  "references": null,
  "see_also": [],
  "signature": {
    "type": "Signature",
    "value": "(A, k=6, ncv=None, tol=0, which='LM', v0=None, maxiter=None, return_singular_vectors=True, solver='arpack', random_state=None, options=None)"
  },
  "type": "DocBlob"
}