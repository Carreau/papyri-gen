{
  "aliases": [
    "scipy.sparse.linalg.lgmres"
  ],
  "arbitrary": [],
  "content": {
    "Attributes": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Extended Summary": {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The LGMRES algorithm   is designed to avoid some problems in the convergence in restarted GMRES, and often converges in fewer iterations."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Methods": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Notes": {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The LGMRES algorithm   is designed to avoid the slowing of convergence in restarted GMRES, due to alternating residual vectors. Typically, it often outperforms GMRES(m) of comparable memory requirements by some measure, or at least is not much worse."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Another advantage in this algorithm is that you can supply it with 'guess' vectors in the "
            },
            {
              "anchor": null,
              "exists": true,
              "kind": "local",
              "reference": {
                "kind": "local",
                "module": null,
                "path": "outer_v",
                "type": "RefInfo",
                "version": null
              },
              "type": "Link",
              "value": "outer_v"
            },
            {
              "type": "text",
              "value": " argument that augment the Krylov subspace. If the solution lies close to the span of these vectors, the algorithm converges faster. This can be useful if several very similar matrices need to be inverted one after another, such as in Newton-Krylov iteration where the Jacobian matrix often changes little in the nonlinear steps."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Other Parameters": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Parameters": {
      "children": [
        {
          "children": [
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The real or complex N-by-N matrix of the linear system. Alternatively, "
                    },
                    {
                      "type": "inlineCode",
                      "value": "A"
                    },
                    {
                      "type": "text",
                      "value": " can be a linear operator which can produce "
                    },
                    {
                      "type": "inlineCode",
                      "value": "Ax"
                    },
                    {
                      "type": "text",
                      "value": " using, e.g., "
                    },
                    {
                      "type": "inlineCode",
                      "value": "scipy.sparse.linalg.LinearOperator"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "A",
              "type": "Param",
              "type_": "{sparse matrix, ndarray, LinearOperator}"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Right hand side of the linear system. Has shape (N,) or (N,1)."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "b",
              "type": "Param",
              "type_": "ndarray"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Starting guess for the solution."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "x0",
              "type": "Param",
              "type_": "ndarray"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Tolerances for convergence, "
                    },
                    {
                      "type": "inlineCode",
                      "value": "norm(residual) <= max(tol*norm(b), atol)"
                    },
                    {
                      "type": "text",
                      "value": ". The default for "
                    },
                    {
                      "type": "inlineCode",
                      "value": "atol"
                    },
                    {
                      "type": "text",
                      "value": " is "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "tol",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "tol"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "children": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "warning "
                        }
                      ],
                      "type": "admonitionTitle"
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "The default value for "
                        },
                        {
                          "domain": null,
                          "role": null,
                          "type": "Directive",
                          "value": "atol"
                        },
                        {
                          "type": "text",
                          "value": " will be changed in a future release. For future compatibility, specify "
                        },
                        {
                          "domain": null,
                          "role": null,
                          "type": "Directive",
                          "value": "atol"
                        },
                        {
                          "type": "text",
                          "value": " explicitly."
                        }
                      ],
                      "type": "paragraph"
                    }
                  ],
                  "kind": "note",
                  "type": "admonition"
                }
              ],
              "param": "tol, atol",
              "type": "Param",
              "type_": "float, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Maximum number of iterations.  Iteration will stop after maxiter steps even if the specified tolerance has not been achieved."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "maxiter",
              "type": "Param",
              "type_": "int, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Preconditioner for A.  The preconditioner should approximate the inverse of A.  Effective preconditioning dramatically improves the rate of convergence, which implies that fewer iterations are needed to reach a given error tolerance."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "M",
              "type": "Param",
              "type_": "{sparse matrix, ndarray, LinearOperator}, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "User-supplied function to call after each iteration.  It is called as callback(xk), where xk is the current solution vector."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "callback",
              "type": "Param",
              "type_": "function, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Number of inner GMRES iterations per each outer iteration."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "inner_m",
              "type": "Param",
              "type_": "int, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Number of vectors to carry between inner GMRES iterations. According to , good values are in the range of 1...3. However, note that if you want to use the additional vectors to accelerate solving multiple similar problems, larger values may be beneficial."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "outer_k",
              "type": "Param",
              "type_": "int, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "List containing tuples "
                    },
                    {
                      "type": "inlineCode",
                      "value": "(v, Av)"
                    },
                    {
                      "type": "text",
                      "value": " of vectors and corresponding matrix-vector products, used to augment the Krylov subspace, and carried between inner GMRES iterations. The element "
                    },
                    {
                      "type": "inlineCode",
                      "value": "Av"
                    },
                    {
                      "type": "text",
                      "value": " can be "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "None"
                    },
                    {
                      "type": "text",
                      "value": " if the matrix-vector product should be re-evaluated. This parameter is modified in-place by "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "module",
                      "reference": {
                        "kind": "module",
                        "module": "scipy",
                        "path": "scipy.sparse.linalg._isolve.lgmres:lgmres",
                        "type": "RefInfo",
                        "version": "1.10.1"
                      },
                      "type": "Link",
                      "value": "lgmres"
                    },
                    {
                      "type": "text",
                      "value": ", and can be used to pass \"guess\" vectors in and out of the algorithm when solving similar problems."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "outer_v",
              "type": "Param",
              "type_": "list of tuples, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Whether LGMRES should store also A@v in addition to vectors "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "v"
                    },
                    {
                      "type": "text",
                      "value": " in the "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "outer_v",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "outer_v"
                    },
                    {
                      "type": "text",
                      "value": " list. Default is True."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "store_outer_Av",
              "type": "Param",
              "type_": "bool, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Whether to put outer_v augmentation vectors before Krylov iterates. In standard LGMRES, prepend_outer_v=False."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "prepend_outer_v",
              "type": "Param",
              "type_": "bool, optional"
            }
          ],
          "type": "Parameters"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Raises": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Receives": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Returns": {
      "children": [
        {
          "children": [
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The converged solution."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "x",
              "type": "Param",
              "type_": "ndarray"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Provides convergence information:"
                    }
                  ],
                  "type": "paragraph"
                },
                {
                  "children": [
                    {
                      "children": [
                        {
                          "children": [],
                          "spread": false,
                          "type": "listItem"
                        }
                      ],
                      "ordered": false,
                      "spread": false,
                      "start": 1,
                      "type": "list"
                    }
                  ],
                  "type": "blockquote"
                }
              ],
              "param": "info",
              "type": "Param",
              "type_": "int"
            }
          ],
          "type": "Parameters"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Summary": {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Solve a matrix equation using the LGMRES algorithm."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Warnings": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Warns": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Yields": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    }
  },
  "example_section_data": {
    "children": [
      {
        "type": "code",
        "value": "import numpy as np\nfrom scipy.sparse import csc_matrix\nfrom scipy.sparse.linalg import lgmres\nA = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)\nb = np.array([2, 4, -1], dtype=float)\nx, exitCode = lgmres(A, b)\nprint(exitCode)            # 0 indicates successful convergence"
      },
      {
        "type": "code",
        "value": "np.allclose(A.dot(x), b)"
      }
    ],
    "level": 0,
    "target": null,
    "title": null,
    "type": "Section"
  },
  "item_file": "/scipy/sparse/linalg/_isolve/lgmres.py",
  "item_line": 15,
  "item_type": "<class 'function'>",
  "ordered_sections": [
    "Summary",
    "Extended Summary",
    "Parameters",
    "Returns",
    "Notes",
    "References",
    "Examples"
  ],
  "references": null,
  "see_also": [],
  "signature": {
    "type": "Signature",
    "value": "(A, b, x0=None, tol=1e-05, maxiter=1000, M=None, callback=None, inner_m=30, outer_k=3, outer_v=None, store_outer_Av=True, prepend_outer_v=False, atol=None)"
  },
  "type": "DocBlob"
}