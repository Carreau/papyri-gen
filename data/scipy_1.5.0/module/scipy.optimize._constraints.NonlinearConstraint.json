{
  "_content": {
    "Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Nonlinear constraint on the variables."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Extended Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The constraint has the general inequality form::"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockVerbatim",
          "data": {
            "lines": {
              "_lines": [
                {
                  "_line": "    lb <= fun(x) <= ub",
                  "_number": 2,
                  "_offset": 4
                },
                {
                  "_line": "",
                  "_number": 3,
                  "_offset": 4
                }
              ]
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Here the vector of independent variables x is passed as ndarray of shape (n,) and "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "fun"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " returns a vector with m components."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "It is possible to use equal bounds to represent an equality constraint or infinite bounds to represent a one-sided constraint."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Parameters": {
      "children": [
        {
          "type": "Param",
          "data": {
            "param": "fun",
            "type_": "callable",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The function defining the constraint. The signature is "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "fun(x)",
                          " ",
                          "->",
                          " ",
                          "array",
                          "_",
                          "like,",
                          " ",
                          "shape",
                          " ",
                          "(m,)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "lb, ub",
            "type_": "array_like",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Lower and upper bounds on the constraint. Each array must have the shape (m,) or be a scalar, in the latter case a bound will be the same for all components of the constraint. Use "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "np.inf"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " with an appropriate sign to specify a one-sided constraint. Set components of "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "lb"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " and "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "ub"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " equal to represent an equality constraint. Note that you can mix constraints of different types: interval, one-sided or equality, by setting different components of "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "lb"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " and "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "ub"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " as  necessary."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "jac",
            "type_": "{callable,  '2-point', '3-point', 'cs'}, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Method of computing the Jacobian matrix (an m-by-n matrix, where element (i, j) is the partial derivative of f[i] with respect to x[j]).  The keywords {'2-point', '3-point', 'cs'} select a finite difference scheme for the numerical estimation. A callable must have the following signature: "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "jac(x)",
                          " ",
                          "->",
                          " ",
                          "{ndarray,",
                          " ",
                          "sparse",
                          " ",
                          "matrix},",
                          " ",
                          "shape",
                          " ",
                          "(m,",
                          " ",
                          "n)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". Default is '2-point'."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "hess",
            "type_": "{callable, '2-point', '3-point', 'cs', HessianUpdateStrategy, None}, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Method for computing the Hessian matrix. The keywords {'2-point', '3-point', 'cs'} select a finite difference scheme for numerical  estimation.  Alternatively, objects implementing "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "HessianUpdateStrategy"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " interface can be used to approximate the Hessian. Currently available implementations are:"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "    - "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "BFGS"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " (default option)     - "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "SR1"
                        ],
                        "domain": null,
                        "role": null
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "A callable must return the Hessian matrix of "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "dot(fun,",
                          " ",
                          "v)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " and must have the following signature: "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "hess(x,",
                          " ",
                          "v)",
                          " ",
                          "->",
                          " ",
                          "{LinearOperator,",
                          " ",
                          "sparse",
                          " ",
                          "matrix,",
                          " ",
                          "array",
                          "_",
                          "like},",
                          " ",
                          "shape",
                          " ",
                          "(n,",
                          " ",
                          "n)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". Here "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "v"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is ndarray with shape (m,) containing Lagrange multipliers."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "keep_feasible",
            "type_": "array_like of bool, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Whether to keep the constraint components feasible throughout iterations. A single value set this property for all components. Default is False. Has no effect for equality constraints."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "finite_diff_rel_step: None or array_like, optional",
            "type_": "",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Relative step size for the finite difference approximation. Default is None, which will select a reasonable value automatically depending on a finite difference scheme."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "finite_diff_jac_sparsity: {None, array_like, sparse matrix}, optional",
            "type_": "",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Defines the sparsity structure of the Jacobian matrix for finite difference estimation, its shape must be (m, n). If the Jacobian has only few non-zero elements in *each* row, providing the sparsity structure will greatly speed up the computations. A zero entry means that a corresponding element in the Jacobian is identically zero. If provided, forces the use of 'lsmr' trust-region solver. If None (default) then dense differencing will be used."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        }
      ],
      "title": null
    },
    "Returns": {
      "children": [],
      "title": null
    },
    "Yields": {
      "children": [],
      "title": null
    },
    "Receives": {
      "children": [],
      "title": null
    },
    "Raises": {
      "children": [],
      "title": null
    },
    "Warns": {
      "children": [],
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "title": null
    },
    "Attributes": {
      "children": [],
      "title": null
    },
    "Methods": {
      "children": [],
      "title": null
    },
    "Notes": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Finite difference schemes {'2-point', '3-point', 'cs'} may be used for approximating either the Jacobian or the Hessian. We, however, do not allow its use for approximating both simultaneously. Hence whenever the Jacobian is estimated via finite-differences, we require the Hessian to be estimated using one of the quasi-Newton strategies."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The scheme 'cs' is potentially the most accurate, but requires the function to correctly handles complex inputs and be analytically continuable to the complex plane. The scheme '3-point' is more accurate than '2-point' but requires twice as many operations."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Warnings": {
      "children": [],
      "title": null
    }
  },
  "refs": [
    "builtins.float",
    "numpy",
    "numpy.ufunc",
    "scipy",
    "scipy.optimize",
    "scipy.optimize._constraints.NonlinearConstraint"
  ],
  "ordered_sections": [
    "Summary",
    "Extended Summary",
    "Parameters",
    "Notes",
    "Examples"
  ],
  "item_file": "/Users/bussonniermatthias/miniconda3/lib/python3.8/site-packages/scipy/optimize/_constraints.py",
  "item_line": 11,
  "item_type": "<class 'type'>",
  "aliases": [
    "scipy.optimize.NonlinearConstraint"
  ],
  "example_section_data": {
    "children": [
      {
        "type": "Paragraph",
        "data": {
          "inline": [
            {
              "type": "Words",
              "data": {
                "value": "Constrain `"
              }
            },
            {
              "type": "Directive",
              "data": {
                "value": [
                  "x[0]",
                  " ",
                  "<",
                  " ",
                  "sin(x[1])",
                  " ",
                  "+",
                  " ",
                  "1.9"
                ],
                "domain": null,
                "role": null
              }
            },
            {
              "type": "Words",
              "data": {
                "value": "`"
              }
            }
          ],
          "inner": []
        }
      },
      {
        "type": "Code",
        "data": {
          "entries": [
            [
              "from",
              null,
              "kn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "scipy",
              "scipy",
              "nn"
            ],
            [
              ".",
              "",
              "nn"
            ],
            [
              "optimize",
              "scipy.optimize",
              "nn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "import",
              null,
              "kn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "NonlinearConstraint",
              "scipy.optimize._constraints.NonlinearConstraint",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "con",
              null,
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "lambda",
              null,
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              ":",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "-",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "numpy",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "sin",
              "numpy.ufunc",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "1",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "nlc",
              "scipy.optimize._constraints.NonlinearConstraint",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "NonlinearConstraint",
              "scipy.optimize._constraints.NonlinearConstraint",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "con",
              null,
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "-",
              "",
              "o"
            ],
            [
              "np",
              "numpy",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "inf",
              "builtins.float",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "1.9",
              "",
              "mf"
            ],
            [
              ")",
              "",
              ""
            ]
          ],
          "out": "",
          "ce_status": "execed"
        }
      }
    ],
    "title": null
  },
  "see_also": [],
  "signature": "NonlinearConstraint(fun, lb, ub, jac='2-point', hess=<scipy.optimize._hessian_update_strategy.BFGS object at 0x13dcf4af0>, keep_feasible=False, finite_diff_rel_step=None, finite_diff_jac_sparsity=None)",
  "references": null,
  "arbitrary": []
}