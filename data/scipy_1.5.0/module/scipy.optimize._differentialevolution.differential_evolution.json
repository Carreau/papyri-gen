{
  "_content": {
    "Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Finds the global minimum of a multivariate function."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Extended Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Differential Evolution is stochastic in nature (does not use gradient methods) to find the minimum, and can search large areas of candidate space, but often requires larger numbers of function evaluations than conventional gradient-based techniques."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "The algorithm is due to Storn and Price [1]_."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Parameters": {
      "children": [
        {
          "type": "Param",
          "data": {
            "param": "func",
            "type_": "callable",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The objective function to be minimized. Must be in the form "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "f(x,",
                          " ",
                          "*",
                          "args)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", where "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "x"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is the argument in the form of a 1-D array and "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "args"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is a  tuple of any additional fixed parameters needed to completely specify the function."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "bounds",
            "type_": "sequence or `Bounds`, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Bounds for variables. There are two ways to specify the bounds: 1. Instance of "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "Bounds"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " class. 2. "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "(min,",
                          " ",
                          "max)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " pairs for each element in "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "x"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", defining the finite lower and upper bounds for the optimizing argument of "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "func"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". It is required to have "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "len(bounds)",
                          " ",
                          "==",
                          " ",
                          "len(x)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "len(bounds)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is used to determine the number of parameters in "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "x"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "args",
            "type_": "tuple, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Any additional fixed parameters needed to completely specify the objective function."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "strategy",
            "type_": "str, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The differential evolution strategy to use. Should be one of:"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "    - 'best1bin'     - 'best1exp'     - 'rand1exp'     - 'randtobest1exp'     - 'currenttobest1exp'     - 'best2exp'     - 'rand2exp'     - 'randtobest1bin'     - 'currenttobest1bin'     - 'best2bin'     - 'rand2bin'     - 'rand1bin'"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The default is 'best1bin'."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "maxiter",
            "type_": "int, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The maximum number of generations over which the entire population is evolved. The maximum number of function evaluations (with no polishing) is: `"
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "(maxiter",
                          " ",
                          "+",
                          " ",
                          "1)",
                          " ",
                          "*",
                          " ",
                          "popsize",
                          " ",
                          "*",
                          " ",
                          "len(x)"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "`"
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "popsize",
            "type_": "int, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "A multiplier for setting the total population size. The population has "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "popsize",
                          " ",
                          "*",
                          " ",
                          "len(x)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " individuals (unless the initial population is supplied via the "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "init"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " keyword)."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "tol",
            "type_": "float, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Relative tolerance for convergence, the solving stops when "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "np.std(pop)",
                          " ",
                          "<=",
                          " ",
                          "atol",
                          " ",
                          "+",
                          " ",
                          "tol",
                          " ",
                          "*",
                          " ",
                          "np.abs(np.mean(population",
                          "_",
                          "energies))"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", where and "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "atol"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " and "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "tol"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " are the absolute and relative tolerance respectively."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "mutation",
            "type_": "float or tuple(float, float), optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The mutation constant. In the literature this is also known as differential weight, being denoted by F. If specified as a float it should be in the range [0, 2]. If specified as a tuple "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "(min,",
                          " ",
                          "max)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " dithering is employed. Dithering randomly changes the mutation constant on a generation by generation basis. The mutation constant for that generation is taken from "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "U[min,",
                          " ",
                          "max)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". Dithering can help speed convergence significantly. Increasing the mutation constant increases the search radius, but will slow down convergence."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "recombination",
            "type_": "float, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The recombination constant, should be in the range [0, 1]. In the literature this is also known as the crossover probability, being denoted by CR. Increasing this value allows a larger number of mutants to progress into the next generation, but at the risk of population stability."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "seed",
            "type_": "{int, `~np.random.RandomState`, `~np.random.Generator`}, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "If "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "seed"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is not specified the "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "~np.random.RandomState"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " singleton is used. If "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "seed"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is an int, a new "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "RandomState"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " instance is used, seeded with seed. If "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "seed"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is already a "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "RandomState"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " or a "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "Generator"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " instance, then that object is used. Specify "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "seed"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " for repeatable minimizations."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "disp",
            "type_": "bool, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Prints the evaluated "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "func"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " at every iteration."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "callback",
            "type_": "callable, `callback(xk, convergence=val)`, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "A function to follow the progress of the minimization. "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "xk"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is the current value of "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "x0"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "val"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " represents the fractional value of the population convergence.  When "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "val"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is greater than one the function halts. If callback returns "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "True"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", then the minimization is halted (any polishing is still carried out)."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "polish",
            "type_": "bool, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "If True (default), then "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "scipy.optimize.minimize"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " with the "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "L-BFGS-B"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " method is used to polish the best population member at the end, which can improve the minimization slightly. If a constrained problem is being studied then the "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "trust-constr"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " method is used instead."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "init",
            "type_": "str or array-like, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Specify which type of population initialization is performed. Should be one of:"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "    - 'latinhypercube'     - 'random'     - array specifying the initial population. The array should have"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "      shape "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "(M,",
                          " ",
                          "len(x))"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", where M is the total population size and       len(x) is the number of parameters.       "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "init"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is clipped to "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "bounds"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " before use."
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The default is 'latinhypercube'. Latin Hypercube sampling tries to maximize coverage of the available parameter space. 'random' initializes the population randomly - this has the drawback that clustering can occur, preventing the whole of parameter space being covered. Use of an array to specify a population subset could be used, for example, to create a tight bunch of initial guesses in an location where the solution is known to exist, thereby reducing time for convergence."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "atol",
            "type_": "float, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Absolute tolerance for convergence, the solving stops when "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "np.std(pop)",
                          " ",
                          "<=",
                          " ",
                          "atol",
                          " ",
                          "+",
                          " ",
                          "tol",
                          " ",
                          "*",
                          " ",
                          "np.abs(np.mean(population",
                          "_",
                          "energies))"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", where and "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "atol"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " and "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "tol"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " are the absolute and relative tolerance respectively."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "updating",
            "type_": "{'immediate', 'deferred'}, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "If "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "'immediate'"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", the best solution vector is continuously updated within a single generation [4]_. This can lead to faster convergence as trial vectors can take advantage of continuous improvements in the best solution. With "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "'deferred'"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", the best solution vector is updated once per generation. Only "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "'deferred'"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is compatible with parallelization, and the "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "workers"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " keyword can over-ride this option."
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "BlockDirective",
                "data": {
                  "lines": {
                    "_lines": [
                      {
                        "_line": ".. versionadded:: 1.2.0",
                        "_number": 8,
                        "_offset": 0
                      }
                    ]
                  },
                  "wh": {
                    "_lines": []
                  },
                  "ind": {
                    "_lines": []
                  },
                  "directive_name": "versionadded",
                  "args0": [
                    " 1.2.0"
                  ],
                  "inner": null
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "workers",
            "type_": "int or map-like callable, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "If "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "workers"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is an int the population is subdivided into "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "workers"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " sections and evaluated in parallel (uses "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "multiprocessing.Pool",
                          " ",
                          "<multiprocessing>"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "). Supply -1 to use all available CPU cores. Alternatively supply a map-like callable, such as "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "multiprocessing.Pool.map"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " for evaluating the population in parallel. This evaluation is carried out as "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "workers(func,",
                          " ",
                          "iterable)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". This option will override the "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "updating"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " keyword to "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "updating='deferred'"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " if "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "workers",
                          " ",
                          "!=",
                          " ",
                          "1"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". Requires that "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "func"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " be pickleable."
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "BlockDirective",
                "data": {
                  "lines": {
                    "_lines": [
                      {
                        "_line": ".. versionadded:: 1.2.0",
                        "_number": 11,
                        "_offset": 0
                      }
                    ]
                  },
                  "wh": {
                    "_lines": []
                  },
                  "ind": {
                    "_lines": []
                  },
                  "directive_name": "versionadded",
                  "args0": [
                    " 1.2.0"
                  ],
                  "inner": null
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "constraints",
            "type_": "{NonLinearConstraint, LinearConstraint, Bounds}",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Constraints on the solver, over and above those applied by the "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "bounds"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " kwd. Uses the approach by Lampinen [5]_."
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "BlockDirective",
                "data": {
                  "lines": {
                    "_lines": [
                      {
                        "_line": ".. versionadded:: 1.4.0",
                        "_number": 3,
                        "_offset": 0
                      }
                    ]
                  },
                  "wh": {
                    "_lines": []
                  },
                  "ind": {
                    "_lines": []
                  },
                  "directive_name": "versionadded",
                  "args0": [
                    " 1.4.0"
                  ],
                  "inner": null
                }
              }
            ]
          }
        }
      ],
      "title": null
    },
    "Returns": {
      "children": [
        {
          "type": "Param",
          "data": {
            "param": "res",
            "type_": "OptimizeResult",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "The optimization result represented as a "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "OptimizeResult"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " object. Important attributes are: "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "x"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " the solution array, "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "success"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " a Boolean flag indicating if the optimizer exited successfully and "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "message"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " which describes the cause of the termination. See "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "OptimizeResult"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " for a description of other attributes. If "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "polish"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " was employed, and a lower minimum was obtained by the polishing, then OptimizeResult also contains the "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "jac"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " attribute. If the eventual solution does not satisfy the applied constraints "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "success"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " will be "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "False"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        }
      ],
      "title": null
    },
    "Yields": {
      "children": [],
      "title": null
    },
    "Receives": {
      "children": [],
      "title": null
    },
    "Raises": {
      "children": [],
      "title": null
    },
    "Warns": {
      "children": [],
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "title": null
    },
    "Attributes": {
      "children": [],
      "title": null
    },
    "Methods": {
      "children": [],
      "title": null
    },
    "Notes": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Differential evolution is a stochastic population based method that is useful for global optimization problems. At each pass through the population the algorithm mutates each candidate solution by mixing with other candidate solutions to create a trial candidate. There are several strategies [2]_ for creating trial candidates, which suit some problems more than others. The 'best1bin' strategy is a good starting point for many systems. In this strategy two members of the population are randomly chosen. Their difference is used to mutate the best member (the 'best' in 'best1bin'), "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "b",
                    "_",
                    "0"
                  ],
                  "domain": null,
                  "role": "math"
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ", so far:"
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "lines": {
              "_lines": [
                {
                  "_line": ".. math::",
                  "_number": 10,
                  "_offset": 0
                }
              ]
            },
            "wh": {
              "_lines": [
                {
                  "_line": "",
                  "_number": 11,
                  "_offset": 0
                }
              ]
            },
            "ind": {
              "_lines": [
                {
                  "_line": "    b' = b_0 + mutation * (population[rand0] - population[rand1])",
                  "_number": 12,
                  "_offset": 0
                },
                {
                  "_line": "",
                  "_number": 13,
                  "_offset": 0
                }
              ]
            },
            "directive_name": "math",
            "args0": [
              ""
            ],
            "inner": {
              "inline": [
                {
                  "type": "Words",
                  "data": {
                    "value": "b' = b_0 + mutation * (population[rand0] - population[rand1]) "
                  }
                }
              ],
              "inner": []
            }
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "A trial vector is then constructed. Starting with a randomly chosen ith parameter the trial is sequentially filled (in modulo) with parameters from "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "b'"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " or the original candidate. The choice of whether to use "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "b'"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " or the original candidate is made with a binomial distribution (the 'bin' in 'best1bin') - a random number in [0, 1) is generated. If this number is less than the "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "recombination"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " constant then the parameter is loaded from "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "b'"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ", otherwise it is loaded from the original candidate. The final parameter is always loaded from "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "b'"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ". Once the trial candidate is built its fitness is assessed. If the trial is better than the original candidate then it takes its place. If it is also better than the best overall candidate it also replaces that. To improve your chances of finding a global minimum use higher "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "popsize"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " values, with higher "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "mutation"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " and (dithering), but lower "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "recombination"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " values. This has the effect of widening the search radius, but slowing convergence. By default the best solution vector is updated continuously within a single iteration ("
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "updating='immediate'"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "). This is a modification [4]_ of the original differential evolution algorithm which can lead to faster convergence as trial vectors can immediately benefit from improved solutions. To use the original Storn and Price behaviour, updating the best solution once per iteration, set "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "updating='deferred'"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": "."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "BlockDirective",
          "data": {
            "lines": {
              "_lines": [
                {
                  "_line": ".. versionadded:: 0.15.0",
                  "_number": 36,
                  "_offset": 0
                }
              ]
            },
            "wh": {
              "_lines": []
            },
            "ind": {
              "_lines": []
            },
            "directive_name": "versionadded",
            "args0": [
              " 0.15.0"
            ],
            "inner": null
          }
        }
      ],
      "title": null
    },
    "Warnings": {
      "children": [],
      "title": null
    }
  },
  "refs": [],
  "ordered_sections": [
    "Summary",
    "Extended Summary",
    "Parameters",
    "Returns",
    "Notes",
    "Examples",
    "References"
  ],
  "item_file": "/Users/bussonniermatthias/miniconda3/lib/python3.8/site-packages/scipy/optimize/_differentialevolution.py",
  "item_line": 22,
  "item_type": "<class 'function'>",
  "aliases": [
    "scipy.optimize.differential_evolution"
  ],
  "example_section_data": {
    "children": [
      {
        "type": "Paragraph",
        "data": {
          "inline": [
            {
              "type": "Words",
              "data": {
                "value": "Let us consider the problem of minimizing the Rosenbrock function. This function is implemented in "
              }
            },
            {
              "type": "Directive",
              "data": {
                "value": [
                  "rosen"
                ],
                "domain": null,
                "role": null
              }
            },
            {
              "type": "Words",
              "data": {
                "value": " in "
              }
            },
            {
              "type": "Directive",
              "data": {
                "value": [
                  "scipy.optimize"
                ],
                "domain": null,
                "role": null
              }
            },
            {
              "type": "Words",
              "data": {
                "value": "."
              }
            }
          ],
          "inner": []
        }
      },
      {
        "type": "Code",
        "data": {
          "entries": [
            [
              "from",
              "",
              "kn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "scipy",
              "",
              "nn"
            ],
            [
              ".",
              "",
              "nn"
            ],
            [
              "optimize",
              "",
              "nn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "import",
              "",
              "kn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "rosen",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "differential_evolution",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "bounds",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              "]",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "result",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "differential_evolution",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "rosen",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "bounds",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "result",
              "",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "x",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "result",
              "",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "fun",
              "",
              ""
            ]
          ],
          "out": "(array([1., 1., 1., 1., 1.]), 1.9216496320061384e-19)",
          "ce_status": "execed"
        }
      },
      {
        "type": "Paragraph",
        "data": {
          "inline": [
            {
              "type": "Words",
              "data": {
                "value": "Now repeat, but with parallelization."
              }
            }
          ],
          "inner": []
        }
      },
      {
        "type": "Code",
        "data": {
          "entries": [
            [
              "bounds",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              "]",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "result",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "differential_evolution",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "rosen",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "bounds",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "updating",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              "\"",
              "",
              "s2"
            ],
            [
              "deferred",
              "",
              "s2"
            ],
            [
              "\"",
              "",
              "s2"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "workers",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "result",
              "",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "x",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "result",
              "",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "fun",
              "",
              ""
            ]
          ],
          "out": "(array([1., 1., 1., 1., 1.]), 1.9216496320061384e-19)",
          "ce_status": "execed"
        }
      },
      {
        "type": "Paragraph",
        "data": {
          "inline": [
            {
              "type": "Words",
              "data": {
                "value": "Let's try and do a constrained minimization"
              }
            }
          ],
          "inner": []
        }
      },
      {
        "type": "Code",
        "data": {
          "entries": [
            [
              "from",
              "",
              "kn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "scipy",
              "",
              "nn"
            ],
            [
              ".",
              "",
              "nn"
            ],
            [
              "optimize",
              "",
              "nn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "import",
              "",
              "kn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "NonlinearConstraint",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "Bounds",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "def",
              "",
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "constr_f",
              "",
              "nf"
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "x",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ":",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "    ",
              "",
              ""
            ],
            [
              "return",
              "",
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "array",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "x",
              "",
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "+",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              "",
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "1",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ]
          ],
          "out": ">>>",
          "ce_status": "execed"
        }
      },
      {
        "type": "Code",
        "data": {
          "entries": [
            [
              "# the sum of x[0] and x[1] must be less than 1.9",
              "",
              "c1"
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "nlc",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "NonlinearConstraint",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "constr_f",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "-",
              "",
              "o"
            ],
            [
              "np",
              "",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "inf",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "1.9",
              "",
              "mf"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "# specify limits using a `Bounds` object.",
              "",
              "c1"
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "bounds",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "Bounds",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "0.0",
              "",
              "mf"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "0.0",
              "",
              "mf"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "2.0",
              "",
              "mf"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2.0",
              "",
              "mf"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "result",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "differential_evolution",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "rosen",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "bounds",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "constraints",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "nlc",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "seed",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              "1",
              "",
              "mi"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "result",
              "",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "x",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "result",
              "",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "fun",
              "",
              ""
            ]
          ],
          "out": "(array([0.96633867, 0.93363577]), 0.0011361355854792312)",
          "ce_status": "execed"
        }
      },
      {
        "type": "Paragraph",
        "data": {
          "inline": [
            {
              "type": "Words",
              "data": {
                "value": "Next find the minimum of the Ackley function (https://en.wikipedia.org/wiki/Test_functions_for_optimization)."
              }
            }
          ],
          "inner": []
        }
      },
      {
        "type": "Code",
        "data": {
          "entries": [
            [
              "from",
              "",
              "kn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "scipy",
              "",
              "nn"
            ],
            [
              ".",
              "",
              "nn"
            ],
            [
              "optimize",
              "",
              "nn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "import",
              "",
              "kn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "differential_evolution",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "import",
              "",
              "kn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "numpy",
              "",
              "nn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "as",
              "",
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "",
              "nn"
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "def",
              "",
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "ackley",
              "",
              "nf"
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "x",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ":",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "    ",
              "",
              ""
            ],
            [
              "arg1",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "-",
              "",
              "o"
            ],
            [
              "0.2",
              "",
              "mf"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "sqrt",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "0.5",
              "",
              "mf"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "x",
              "",
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "+",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              "",
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "1",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "    ",
              "",
              ""
            ],
            [
              "arg2",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "0.5",
              "",
              "mf"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "np",
              "",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "cos",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "2.0",
              "",
              "mf"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "pi",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              "",
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "+",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "cos",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "2.0",
              "",
              "mf"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "pi",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              "",
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "1",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "    ",
              "",
              ""
            ],
            [
              "return",
              "",
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "-",
              "",
              "o"
            ],
            [
              "20.0",
              "",
              "mf"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "exp",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "arg1",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "-",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "exp",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "arg2",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "+",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "20.0",
              "",
              "mf"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "+",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "e",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "bounds",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "-",
              "",
              "o"
            ],
            [
              "5",
              "",
              "mi"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "5",
              "",
              "mi"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "-",
              "",
              "o"
            ],
            [
              "5",
              "",
              "mi"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "5",
              "",
              "mi"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              "]",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "result",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "differential_evolution",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "ackley",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "bounds",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "result",
              "",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "x",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "result",
              "",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "fun",
              "",
              ""
            ]
          ],
          "out": "(array([ 0.,  0.]), 4.4408920985006262e-16)",
          "ce_status": "execed"
        }
      }
    ],
    "title": null
  },
  "see_also": [],
  "signature": "differential_evolution(func, bounds, args=(), strategy='best1bin', maxiter=1000, popsize=15, tol=0.01, mutation=(0.5, 1), recombination=0.7, seed=None, callback=None, disp=False, polish=True, init='latinhypercube', atol=0, updating='immediate', workers=1, constraints=())",
  "references": [
    ".. [1] Storn, R and Price, K, Differential Evolution - a Simple and",
    "       Efficient Heuristic for Global Optimization over Continuous Spaces,",
    "       Journal of Global Optimization, 1997, 11, 341 - 359.",
    ".. [2] http://www1.icsi.berkeley.edu/~storn/code.html",
    ".. [3] http://en.wikipedia.org/wiki/Differential_evolution",
    ".. [4] Wormington, M., Panaccione, C., Matney, K. M., Bowen, D. K., -",
    "       Characterization of structures from X-ray scattering data using",
    "       genetic algorithms, Phil. Trans. R. Soc. Lond. A, 1999, 357,",
    "       2827-2848",
    ".. [5] Lampinen, J., A constraint handling approach for the differential",
    "       evolution algorithm. Proceedings of the 2002 Congress on",
    "       Evolutionary Computation. CEC'02 (Cat. No. 02TH8600). Vol. 2. IEEE,",
    "       2002."
  ],
  "arbitrary": []
}