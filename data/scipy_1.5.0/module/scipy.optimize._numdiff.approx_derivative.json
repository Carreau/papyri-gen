{
  "_content": {
    "Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "Compute finite difference approximation of the derivatives of a vector-valued function."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Extended Summary": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "If a function maps from R^n to R^m, its derivatives form m-by-n matrix called the Jacobian, where an element (i, j) is a partial derivative of f[i] with respect to x[j]."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Parameters": {
      "children": [
        {
          "type": "Param",
          "data": {
            "param": "fun",
            "type_": "callable",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Function of which to estimate the derivatives. The argument x passed to this function is ndarray of shape (n,) (never a scalar even if n=1). It must return 1-D array_like of shape (m,) or a scalar."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "x0",
            "type_": "array_like of shape (n,) or float",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Point at which to estimate the derivatives. Float will be converted to a 1-D array."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "method",
            "type_": "{'3-point', '2-point', 'cs'}, optional",
            "desc": [
              {
                "type": "DefList",
                "data": {
                  "children": [
                    {
                      "lines": {
                        "_lines": [
                          {
                            "_line": "Finite difference method to use:",
                            "_number": 0,
                            "_offset": 0
                          }
                        ]
                      },
                      "wh": {
                        "_lines": []
                      },
                      "ind": {
                        "_lines": [
                          {
                            "_line": "    - '2-point' - use the first order accuracy forward or backward",
                            "_number": 1,
                            "_offset": 4
                          },
                          {
                            "_line": "                  difference.",
                            "_number": 2,
                            "_offset": 4
                          },
                          {
                            "_line": "    - '3-point' - use central difference in interior points and the",
                            "_number": 3,
                            "_offset": 4
                          },
                          {
                            "_line": "                  second order accuracy forward or backward difference",
                            "_number": 4,
                            "_offset": 4
                          },
                          {
                            "_line": "                  near the boundary.",
                            "_number": 5,
                            "_offset": 4
                          },
                          {
                            "_line": "    - 'cs' - use a complex-step finite difference scheme. This assumes",
                            "_number": 6,
                            "_offset": 4
                          },
                          {
                            "_line": "             that the user function is real-valued and can be",
                            "_number": 7,
                            "_offset": 4
                          },
                          {
                            "_line": "             analytically continued to the complex plane. Otherwise,",
                            "_number": 8,
                            "_offset": 4
                          },
                          {
                            "_line": "             produces bogus results.",
                            "_number": 9,
                            "_offset": 4
                          }
                        ]
                      },
                      "dt": {
                        "inline": [
                          {
                            "type": "Words",
                            "data": {
                              "value": "Finite difference method to use:"
                            }
                          }
                        ],
                        "inner": []
                      },
                      "dd": [
                        {
                          "type": "Paragraph",
                          "data": {
                            "inline": [
                              {
                                "type": "Words",
                                "data": {
                                  "value": "- '2-point' - use the first order accuracy forward or backward               difference. - '3-point' - use central difference in interior points and the               second order accuracy forward or backward difference               near the boundary. - 'cs' - use a complex-step finite difference scheme. This assumes          that the user function is real-valued and can be          analytically continued to the complex plane. Otherwise,          produces bogus results."
                                }
                              }
                            ],
                            "inner": []
                          }
                        }
                      ]
                    }
                  ]
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "rel_step",
            "type_": "None or array_like, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Relative step size to use. The absolute step size is computed as "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "h",
                          " ",
                          "=",
                          " ",
                          "rel",
                          "_",
                          "step",
                          " ",
                          "*",
                          " ",
                          "sign(x0)",
                          " ",
                          "*",
                          " ",
                          "max(1,",
                          " ",
                          "abs(x0))"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", possibly adjusted to fit into the bounds. For "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "method='3-point'"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " the sign of "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "h"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is ignored. If None (default) then step is selected automatically, see Notes."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "abs_step",
            "type_": "array_like, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Absolute step size to use, possibly adjusted to fit into the bounds. For "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "method='3-point'"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " the sign of "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "abs",
                          "_",
                          "step"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is ignored. By default relative steps are used, only if "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "abs",
                          "_",
                          "step",
                          " ",
                          "is",
                          " ",
                          "not",
                          " ",
                          "None"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " are absolute steps used."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "f0",
            "type_": "None or array_like, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "If not None it is assumed to be equal to "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "fun(x0)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ", in  this case the "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "fun(x0)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is not called. Default is None."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "bounds",
            "type_": "tuple of array_like, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Lower and upper bounds on independent variables. Defaults to no bounds. Each bound must match the size of "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "x0"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " or be a scalar, in the latter case the bound will be the same for all variables. Use it to limit the range of function evaluation. Bounds checking is not implemented when "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "as",
                          "_",
                          "linear",
                          "_",
                          "operator"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is True."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "sparsity",
            "type_": "{None, array_like, sparse matrix, 2-tuple}, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Defines a sparsity structure of the Jacobian matrix. If the Jacobian matrix is known to have only few non-zero elements in each row, then it's possible to estimate its several columns by a single function evaluation [3]_. To perform such economic computations two ingredients are required:"
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "DefList",
                "data": {
                  "children": [
                    {
                      "lines": {
                        "_lines": [
                          {
                            "_line": "* structure : array_like or sparse matrix of shape (m, n). A zero",
                            "_number": 6,
                            "_offset": 0
                          }
                        ]
                      },
                      "wh": {
                        "_lines": []
                      },
                      "ind": {
                        "_lines": [
                          {
                            "_line": "  element means that a corresponding element of the Jacobian",
                            "_number": 7,
                            "_offset": 2
                          },
                          {
                            "_line": "  identically equals to zero.",
                            "_number": 8,
                            "_offset": 2
                          }
                        ]
                      },
                      "dt": {
                        "inline": [
                          {
                            "type": "Words",
                            "data": {
                              "value": "* structure : array_like or sparse matrix of shape (m, n). A zero"
                            }
                          }
                        ],
                        "inner": []
                      },
                      "dd": [
                        {
                          "type": "Paragraph",
                          "data": {
                            "inline": [
                              {
                                "type": "Words",
                                "data": {
                                  "value": "element means that a corresponding element of the Jacobian identically equals to zero."
                                }
                              }
                            ],
                            "inner": []
                          }
                        }
                      ]
                    },
                    {
                      "lines": {
                        "_lines": [
                          {
                            "_line": "* groups : array_like of shape (n,). A column grouping for a given",
                            "_number": 9,
                            "_offset": 0
                          }
                        ]
                      },
                      "wh": {
                        "_lines": []
                      },
                      "ind": {
                        "_lines": [
                          {
                            "_line": "  sparsity structure, use `group_columns` to obtain it.",
                            "_number": 10,
                            "_offset": 2
                          },
                          {
                            "_line": "",
                            "_number": 11,
                            "_offset": 2
                          }
                        ]
                      },
                      "dt": {
                        "inline": [
                          {
                            "type": "Words",
                            "data": {
                              "value": "* groups : array_like of shape (n,). A column grouping for a given"
                            }
                          }
                        ],
                        "inner": []
                      },
                      "dd": [
                        {
                          "type": "Paragraph",
                          "data": {
                            "inline": [
                              {
                                "type": "Words",
                                "data": {
                                  "value": "sparsity structure, use "
                                }
                              },
                              {
                                "type": "Directive",
                                "data": {
                                  "value": [
                                    "group",
                                    "_",
                                    "columns"
                                  ],
                                  "domain": null,
                                  "role": null
                                }
                              },
                              {
                                "type": "Words",
                                "data": {
                                  "value": " to obtain it. "
                                }
                              }
                            ],
                            "inner": []
                          }
                        }
                      ]
                    }
                  ]
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "A single array or a sparse matrix is interpreted as a sparsity structure, and groups are computed inside the function. A tuple is interpreted as (structure, groups). If None (default), a standard dense differencing will be used."
                      }
                    }
                  ],
                  "inner": []
                }
              },
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Note, that sparse differencing makes sense only for large Jacobian matrices where each row contains few non-zero elements."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "as_linear_operator",
            "type_": "bool, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "When True the function returns an "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "scipy.sparse.linalg.LinearOperator"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". Otherwise it returns a dense array or a sparse matrix depending on "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "sparsity"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". The linear operator provides an efficient way of computing "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "J.dot(p)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " for any vector "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "p"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " of shape (n,), but does not allow direct access to individual elements of the matrix. By default "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "as",
                          "_",
                          "linear",
                          "_",
                          "operator"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is False."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        },
        {
          "type": "Param",
          "data": {
            "param": "args, kwargs",
            "type_": "tuple and dict, optional",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Additional arguments passed to "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "fun"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": ". Both empty by default. The calling signature is "
                      }
                    },
                    {
                      "type": "Verbatim",
                      "data": {
                        "value": [
                          "fun(x,",
                          " ",
                          "*",
                          "args,",
                          " ",
                          "*",
                          "*",
                          "kwargs)"
                        ]
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": "."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        }
      ],
      "title": null
    },
    "Returns": {
      "children": [
        {
          "type": "Param",
          "data": {
            "param": "J",
            "type_": "{ndarray, sparse matrix, LinearOperator}",
            "desc": [
              {
                "type": "Paragraph",
                "data": {
                  "inline": [
                    {
                      "type": "Words",
                      "data": {
                        "value": "Finite difference approximation of the Jacobian matrix. If "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "as",
                          "_",
                          "linear",
                          "_",
                          "operator"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is True returns a LinearOperator with shape (m, n). Otherwise it returns a dense array or sparse matrix depending on how "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "sparsity"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is defined. If "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "sparsity"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is None then a ndarray with shape (m, n) is returned. If "
                      }
                    },
                    {
                      "type": "Directive",
                      "data": {
                        "value": [
                          "sparsity"
                        ],
                        "domain": null,
                        "role": null
                      }
                    },
                    {
                      "type": "Words",
                      "data": {
                        "value": " is not None returns a csr_matrix with shape (m, n). For sparse matrices and linear operators it is always returned as a 2-D structure, for ndarrays, if m=1 it is returned as a 1-D gradient array with shape (n,)."
                      }
                    }
                  ],
                  "inner": []
                }
              }
            ]
          }
        }
      ],
      "title": null
    },
    "Yields": {
      "children": [],
      "title": null
    },
    "Receives": {
      "children": [],
      "title": null
    },
    "Raises": {
      "children": [],
      "title": null
    },
    "Warns": {
      "children": [],
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "title": null
    },
    "Attributes": {
      "children": [],
      "title": null
    },
    "Methods": {
      "children": [],
      "title": null
    },
    "Notes": {
      "children": [
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "If "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "rel",
                    "_",
                    "step"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": " is not provided, it assigned to "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "EPS",
                    "*",
                    "*",
                    "(1/s)"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ", where EPS is machine epsilon for float64 numbers, s=2 for '2-point' method and s=3 for '3-point' method. Such relative step approximately minimizes a sum of truncation and round-off errors, see [1]_. Relative steps are used by default. However, absolute steps are used when "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "abs",
                    "_",
                    "step",
                    " ",
                    "is",
                    " ",
                    "not",
                    " ",
                    "None"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ". If any of the absolute steps produces an indistinguishable difference from the original "
                }
              },
              {
                "type": "Directive",
                "data": {
                  "value": [
                    "x0"
                  ],
                  "domain": null,
                  "role": null
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ", "
                }
              },
              {
                "type": "Verbatim",
                "data": {
                  "value": [
                    "(x0",
                    " ",
                    "+",
                    " ",
                    "abs",
                    "_",
                    "step)",
                    " ",
                    "-",
                    " ",
                    "x0",
                    " ",
                    "==",
                    " ",
                    "0"
                  ]
                }
              },
              {
                "type": "Words",
                "data": {
                  "value": ", then a relative step is substituted for that particular entry."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "A finite difference scheme for '3-point' method is selected automatically. The well-known central difference scheme is used for points sufficiently far from the boundary, and 3-point forward or backward scheme is used for points near the boundary. Both schemes have the second-order accuracy in terms of Taylor expansion. Refer to [2]_ for the formulas of 3-point forward and backward difference schemes."
                }
              }
            ],
            "inner": []
          }
        },
        {
          "type": "Paragraph",
          "data": {
            "inline": [
              {
                "type": "Words",
                "data": {
                  "value": "For dense differencing when m=1 Jacobian is returned with a shape (n,), on the other hand when n=1 Jacobian is returned with a shape (m, 1). Our motivation is the following: a) It handles a case of gradient computation (m=1) in a conventional way. b) It clearly separates these two different cases. b) In all cases np.atleast_2d can be called to get 2-D Jacobian with correct dimensions."
                }
              }
            ],
            "inner": []
          }
        }
      ],
      "title": null
    },
    "Warnings": {
      "children": [],
      "title": null
    }
  },
  "refs": [
    "__main__.f",
    "__main__.g",
    "builtins.float",
    "check_derivative",
    "numpy",
    "numpy.array",
    "numpy.ndarray",
    "numpy.ufunc",
    "scipy",
    "scipy.optimize",
    "scipy.optimize._numdiff.approx_derivative"
  ],
  "ordered_sections": [
    "Summary",
    "Extended Summary",
    "Parameters",
    "Returns",
    "See Also",
    "Notes",
    "References",
    "Examples"
  ],
  "item_file": "/Users/bussonniermatthias/miniconda3/lib/python3.8/site-packages/scipy/optimize/_numdiff.py",
  "item_line": 198,
  "item_type": "<class 'function'>",
  "aliases": [
    "scipy.optimize._differentiable_functions.approx_derivative"
  ],
  "example_section_data": {
    "children": [
      {
        "type": "Code",
        "data": {
          "entries": [
            [
              "import",
              null,
              "kn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "numpy",
              "numpy",
              "nn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "as",
              null,
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "numpy",
              "nn"
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "from",
              null,
              "kn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "scipy",
              "scipy",
              "nn"
            ],
            [
              ".",
              "",
              "nn"
            ],
            [
              "optimize",
              "scipy.optimize",
              "nn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "import",
              null,
              "kn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "approx_derivative",
              "scipy.optimize._numdiff.approx_derivative",
              ""
            ]
          ],
          "out": ">>>",
          "ce_status": "exception_in_exec"
        }
      },
      {
        "type": "Code",
        "data": {
          "entries": [
            [
              "def",
              null,
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "f",
              "__main__.f",
              "nf"
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "c1",
              null,
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "c2",
              null,
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ":",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "    ",
              "",
              ""
            ],
            [
              "return",
              null,
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "numpy",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "array",
              "numpy.array",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "numpy",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "sin",
              "numpy.ufunc",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "c1",
              null,
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "1",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "numpy",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "cos",
              "numpy.ufunc",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "c2",
              null,
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "1",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              "]",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ]
          ],
          "out": "...",
          "ce_status": "execed"
        }
      },
      {
        "type": "Code",
        "data": {
          "entries": [
            [
              "x0",
              "numpy.ndarray",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "numpy",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "array",
              "numpy.array",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "1.0",
              "",
              "mf"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "0.5",
              "",
              "mf"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "numpy",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "pi",
              null,
              ""
            ],
            [
              "]",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "approx_derivative",
              "scipy.optimize._numdiff.approx_derivative",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "f",
              "__main__.f",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x0",
              "numpy.ndarray",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "args",
              null,
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "1",
              "",
              "mi"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ]
          ],
          "out": "array([[ 1.,  0.],\n       [-1.,  0.]])",
          "ce_status": "execed"
        }
      },
      {
        "type": "Paragraph",
        "data": {
          "inline": [
            {
              "type": "Words",
              "data": {
                "value": "Bounds can be used to limit the region of function evaluation. In the example below we compute left and right derivative at point 1.0."
              }
            }
          ],
          "inner": []
        }
      },
      {
        "type": "Code",
        "data": {
          "entries": [
            [
              "def",
              null,
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "g",
              "__main__.g",
              "nf"
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ":",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "    ",
              "",
              ""
            ],
            [
              "return",
              null,
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "if",
              null,
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              ">",
              "",
              "o"
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "1",
              "",
              "mi"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "else",
              null,
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ]
          ],
          "out": "...",
          "ce_status": "execed"
        }
      },
      {
        "type": "Code",
        "data": {
          "entries": [
            [
              "x0",
              "builtins.float",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "1.0",
              "",
              "mf"
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "approx_derivative",
              "scipy.optimize._numdiff.approx_derivative",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "g",
              "__main__.g",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x0",
              "builtins.float",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "bounds",
              null,
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "-",
              "",
              "o"
            ],
            [
              "np",
              "numpy",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "inf",
              null,
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "1.0",
              "",
              "mf"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ]
          ],
          "out": "array([ 1.])",
          "ce_status": "execed"
        }
      },
      {
        "type": "Code",
        "data": {
          "entries": [
            [
              "approx_derivative",
              "scipy.optimize._numdiff.approx_derivative",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "g",
              "__main__.g",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x0",
              "builtins.float",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "bounds",
              null,
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "1.0",
              "",
              "mf"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "numpy",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "inf",
              null,
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ]
          ],
          "out": "array([ 2.])",
          "ce_status": "execed"
        }
      }
    ],
    "title": null
  },
  "see_also": [
    {
      "name": {
        "name": "check_derivative",
        "ref": null,
        "exists": null
      },
      "descriptions": [
        {
          "inline": [
            {
              "type": "Words",
              "data": {
                "value": "Check correctness of a function computing derivatives."
              }
            }
          ],
          "inner": []
        }
      ],
      "type": null
    }
  ],
  "signature": "approx_derivative(fun, x0, method='3-point', rel_step=None, abs_step=None, f0=None, bounds=(-inf, inf), sparsity=None, as_linear_operator=False, args=(), kwargs={})",
  "references": [
    ".. [1] W. H. Press et. al. \"Numerical Recipes. The Art of Scientific",
    "       Computing. 3rd edition\", sec. 5.7.",
    "",
    ".. [2] A. Curtis, M. J. D. Powell, and J. Reid, \"On the estimation of",
    "       sparse Jacobian matrices\", Journal of the Institute of Mathematics",
    "       and its Applications, 13 (1974), pp. 117-120.",
    "",
    ".. [3] B. Fornberg, \"Generation of Finite Difference Formulas on",
    "       Arbitrarily Spaced Grids\", Mathematics of Computation 51, 1988."
  ],
  "arbitrary": []
}