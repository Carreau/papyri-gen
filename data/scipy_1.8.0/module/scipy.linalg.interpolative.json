{
  "aliases": [
    "scipy.signal._lti_conversion.linalg.interpolative"
  ],
  "arbitrary": [
    {
      "children": [
        {
          "data": {
            "argument": "Kenneth L. Ho <klho@stanford.edu>",
            "content": "",
            "name": "moduleauthor",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [],
            "kind": "versionadded",
            "title": "0.13"
          },
          "type": "Admonition"
        },
        {
          "data": {
            "argument": "scipy.linalg.interpolative",
            "content": "",
            "name": "currentmodule",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "An interpolative decomposition (ID) of a matrix "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "A \\in\n\\mathbb{C}^{m \\times n}"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": " of rank "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "k \\leq \\min \\{ m, n \\}"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": " is a factorization"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": "A \\Pi =\n\\begin{bmatrix}\n A \\Pi_{1} & A \\Pi_{2}\n\\end{bmatrix} =\nA \\Pi_{1}\n\\begin{bmatrix}\n I & T\n\\end{bmatrix},"
          },
          "type": "BlockMath"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "where "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "\\Pi = [\\Pi_{1}, \\Pi_{2}]"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": " is a permutation matrix with "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "\\Pi_{1} \\in \\{ 0, 1 \\}^{n \\times k}"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": ", i.e., "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "A \\Pi_{2} =\nA \\Pi_{1} T"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": ". This can equivalently be written as "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "A = BP"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": ", where "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "B = A \\Pi_{1}"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": " and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "P = [I, T] \\Pi^{\\mathsf{T}}"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": " are the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "skeleton"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "interpolation matrices"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": ", respectively."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "If "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "A"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": " does not have exact rank "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "k"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": ", then there exists an approximation in the form of an ID such that "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "A = BP + E"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": ", where "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "\\| E \\| \\sim \\sigma_{k + 1}"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": " is on the order of the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "(k +\n1)"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": "-th largest singular value of "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "A"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": ". Note that "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "\\sigma_{k\n+ 1}"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": " is the best possible error for a rank-"
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "k"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": " approximation and, in fact, is achieved by the singular value decomposition (SVD) "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "A \\approx U S V^{*}"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": ", where "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "U \\in \\mathbb{C}^{m \\times\nk}"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": " and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "V \\in \\mathbb{C}^{n \\times k}"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": " have orthonormal columns and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": "S = \\mathop{\\mathrm{diag}} (\\sigma_{i}) \\in \\mathbb{C}^{k\n\\times k}"
                },
                "type": "Math"
              },
              {
                "data": {
                  "value": " is diagonal with nonnegative entries. The principal advantages of using an ID over an SVD are that:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "it is cheaper to construct;"
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "it preserves the structure of "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": "A"
                          },
                          "type": "Math"
                        },
                        {
                          "data": {
                            "value": "; and"
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "it is more efficient to compute with in light of the identity submatrix of "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": "P"
                          },
                          "type": "Math"
                        },
                        {
                          "data": {
                            "value": "."
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              }
            ]
          },
          "type": "BulletList"
        }
      ],
      "level": 0,
      "target": null,
      "title": "Interpolative matrix decomposition (:mod:`scipy.linalg.interpolative`)"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Main functionality:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    interp_decomp\n    reconstruct_matrix_from_id\n    reconstruct_interp_matrix\n    reconstruct_skel_matrix\n    id_to_svd\n    svd\n    estimate_spectral_norm\n    estimate_spectral_norm_diff\n    estimate_rank"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Support functions:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    seed\n    rand"
          },
          "type": "BlockVerbatim"
        }
      ],
      "level": 1,
      "target": null,
      "title": "Routines"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "This module uses the ID software package  by Martinsson, Rokhlin, Shkolnisky, and Tygert, which is a Fortran library for computing IDs using various algorithms, including the rank-revealing QR approach of  and the more recent randomized methods described in , , and . This module exposes its functionality in a way convenient for Python users. Note that this module does not add any functionality beyond that of organizing a simpler and more consistent interface."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "We advise the user to consult also the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "documentation for the ID package\n<http://tygert.com/id_doc.4.pdf>"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "placeholder": "footnote",
            "value": ".. [1] P.G. Martinsson, V. Rokhlin, Y. Shkolnisky, M. Tygert. \"ID: a\n    software package for low-rank approximation of matrices via interpolative\n    decompositions, version 0.2.\" http://tygert.com/id_doc.4.pdf."
          },
          "type": "Unimplemented"
        },
        {
          "data": {
            "placeholder": "footnote",
            "value": ".. [2] H. Cheng, Z. Gimbutas, P.G. Martinsson, V. Rokhlin. \"On the\n    compression of low rank matrices.\" *SIAM J. Sci. Comput.* 26 (4): 1389--1404,\n    2005. :doi:`10.1137/030602678`."
          },
          "type": "Unimplemented"
        },
        {
          "data": {
            "placeholder": "footnote",
            "value": ".. [3] E. Liberty, F. Woolfe, P.G. Martinsson, V. Rokhlin, M.\n    Tygert. \"Randomized algorithms for the low-rank approximation of matrices.\"\n    *Proc. Natl. Acad. Sci. U.S.A.* 104 (51): 20167--20172, 2007.\n    :doi:`10.1073/pnas.0709640104`."
          },
          "type": "Unimplemented"
        },
        {
          "data": {
            "placeholder": "footnote",
            "value": ".. [4] P.G. Martinsson, V. Rokhlin, M. Tygert. \"A randomized\n    algorithm for the decomposition of matrices.\" *Appl. Comput. Harmon. Anal.* 30\n    (1): 47--68,  2011. :doi:`10.1016/j.acha.2010.02.003`."
          },
          "type": "Unimplemented"
        },
        {
          "data": {
            "placeholder": "footnote",
            "value": ".. [5] F. Woolfe, E. Liberty, V. Rokhlin, M. Tygert. \"A fast\n    randomized algorithm for the approximation of matrices.\" *Appl. Comput.\n    Harmon. Anal.* 25 (3): 335--366, 2008. :doi:`10.1016/j.acha.2007.12.002`."
          },
          "type": "Unimplemented"
        }
      ],
      "level": 1,
      "target": null,
      "title": "References"
    },
    {
      "children": [],
      "level": 1,
      "target": null,
      "title": "Tutorial"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The first step is to import "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "scipy.linalg.interpolative"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " by issuing the command:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> import scipy.linalg.interpolative as sli"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Now let's build a matrix. For this, we consider a Hilbert matrix, which is well know to have low rank:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> from scipy.linalg import hilbert\n>>> n = 1000\n>>> A = hilbert(n)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "We can also do this explicitly via:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> import numpy as np\n>>> n = 1000\n>>> A = np.empty((n, n), order='F')\n>>> for j in range(n):\n>>>     for i in range(m):\n>>>         A[i,j] = 1. / (i + j + 1)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Note the use of the flag "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "order='F'"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " in "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "numpy.empty"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ". This instantiates the matrix in Fortran-contiguous order and is important for avoiding data copying when passing to the backend."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "We then define multiplication routines for the matrix by regarding it as a "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "scipy.sparse.linalg.LinearOperator"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ":"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> from scipy.sparse.linalg import aslinearoperator\n>>> L = aslinearoperator(A)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "This automatically sets up methods describing the action of the matrix and its adjoint on a vector."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Initializing"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "We have several choices of algorithm to compute an ID. These fall largely according to two dichotomies:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "how the matrix is represented, i.e., via its entries or via its action on a    vector; and"
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "whether to approximate it to a fixed relative precision or to a fixed rank."
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              }
            ]
          },
          "type": "EnumeratedList"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "We step through each choice in turn below."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "In all cases, the ID is represented by three parameters:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "a rank "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": [
                              "k"
                            ]
                          },
                          "type": "Verbatim"
                        },
                        {
                          "data": {
                            "value": ";"
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "an index array "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": [
                              "idx"
                            ]
                          },
                          "type": "Verbatim"
                        },
                        {
                          "data": {
                            "value": "; and"
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              },
              {
                "children": [
                  {
                    "data": {
                      "children": [
                        {
                          "data": {
                            "value": "interpolation coefficients "
                          },
                          "type": "Words"
                        },
                        {
                          "data": {
                            "value": [
                              "proj"
                            ]
                          },
                          "type": "Verbatim"
                        },
                        {
                          "data": {
                            "value": "."
                          },
                          "type": "Words"
                        }
                      ]
                    },
                    "type": "Paragraph"
                  }
                ]
              }
            ]
          },
          "type": "EnumeratedList"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The ID is specified by the relation "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "np.dot(A[:,idx[:k]], proj) == A[:,idx[k:]]"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Computing an ID"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "We first consider a matrix given in terms of its entries."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "To compute an ID to a fixed precision, type:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> k, idx, proj = sli.interp_decomp(A, eps)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "where "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "eps < 1"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is the desired precision."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "To compute an ID to a fixed rank, use:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> idx, proj = sli.interp_decomp(A, k)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "where "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "k >= 1"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is the desired rank."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Both algorithms use random sampling and are usually faster than the corresponding older, deterministic algorithms, which can be accessed via the commands:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> k, idx, proj = sli.interp_decomp(A, eps, rand=False)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "and:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> idx, proj = sli.interp_decomp(A, k, rand=False)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "respectively."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 3,
      "target": null,
      "title": "From matrix entries"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Now consider a matrix given in terms of its action on a vector as a "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "scipy.sparse.linalg.LinearOperator"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "To compute an ID to a fixed precision, type:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> k, idx, proj = sli.interp_decomp(L, eps)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "To compute an ID to a fixed rank, use:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> idx, proj = sli.interp_decomp(L, k)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "These algorithms are randomized."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 3,
      "target": null,
      "title": "From matrix action"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The ID routines above do not output the skeleton and interpolation matrices explicitly but instead return the relevant information in a more compact (and sometimes more useful) form. To build these matrices, write:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> B = sli.reconstruct_skel_matrix(A, k, idx)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "for the skeleton matrix and:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> P = sli.reconstruct_interp_matrix(idx, proj)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "for the interpolation matrix. The ID approximation can then be computed as:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> C = np.dot(B, P)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "This can also be constructed directly using:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> C = sli.reconstruct_matrix_from_id(B, idx, proj)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "without having to first compute "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "P"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Alternatively, this can be done explicitly as well using:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> B = A[:,idx[:k]]\n>>> P = np.hstack([np.eye(k), proj])[:,np.argsort(idx)]\n>>> C = np.dot(B, P)"
          },
          "type": "BlockVerbatim"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Reconstructing an ID"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "An ID can be converted to an SVD via the command:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> U, S, V = sli.id_to_svd(B, idx, proj)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The SVD approximation is then:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> C = np.dot(U, np.dot(np.diag(S), np.dot(V.conj().T)))"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The SVD can also be computed \"fresh\" by combining both the ID and conversion steps into one command. Following the various ID algorithms above, there are correspondingly various SVD algorithms that one can employ."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Computing an SVD"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "We consider first SVD algorithms for a matrix given in terms of its entries."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "To compute an SVD to a fixed precision, type:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> U, S, V = sli.svd(A, eps)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "To compute an SVD to a fixed rank, use:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> U, S, V = sli.svd(A, k)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Both algorithms use random sampling; for the determinstic versions, issue the keyword "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "rand=False"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " as above."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 3,
      "target": null,
      "title": "From matrix entries"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Now consider a matrix given in terms of its action on a vector."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "To compute an SVD to a fixed precision, type:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> U, S, V = sli.svd(L, eps)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "To compute an SVD to a fixed rank, use:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> U, S, V = sli.svd(L, k)"
          },
          "type": "BlockVerbatim"
        }
      ],
      "level": 3,
      "target": null,
      "title": "From matrix action"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Several utility routines are also available."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "To estimate the spectral norm of a matrix, use:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> snorm = sli.estimate_spectral_norm(A)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "This algorithm is based on the randomized power method and thus requires only matrix-vector products. The number of iterations to take can be set using the keyword "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "its"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " (default: "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "its=20"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "). The matrix is interpreted as a "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "scipy.sparse.linalg.LinearOperator"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", but it is also valid to supply it as a "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "numpy.ndarray"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", in which case it is trivially converted using "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "scipy.sparse.linalg.aslinearoperator"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The same algorithm can also estimate the spectral norm of the difference of two matrices "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "A1"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "A2"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " as follows:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> diff = sli.estimate_spectral_norm_diff(A1, A2)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "This is often useful for checking the accuracy of a matrix approximation."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Some routines in "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "scipy.linalg.interpolative"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " require estimating the rank of a matrix as well. This can be done with either:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> k = sli.estimate_rank(A, eps)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "or:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> k = sli.estimate_rank(L, eps)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "depending on the representation. The parameter "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "eps"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " controls the definition of the numerical rank."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Finally, the random number generation required for all randomized routines can be controlled via "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "scipy.linalg.interpolative.seed"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ". To reset the seed values to their original values, use:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> sli.seed('default')"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "To specify the seed values, use:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> sli.seed(s)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "where "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "s"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " must be an integer or array of 55 floats. If an integer, the array of floats is obtained by using "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "numpy.random.rand"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " with the given integer seed."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "To simply generate some random numbers, type:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> sli.rand(n)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "where "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "n"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is the number of random numbers to generate."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Utility routines"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The above functions all automatically detect the appropriate interface and work with both real and complex data types, passing input arguments to the proper backend routine."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 2,
      "target": null,
      "title": "Remarks"
    }
  ],
  "content": {
    "Attributes": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Extended Summary": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Methods": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Notes": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Parameters": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Raises": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Receives": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Returns": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Summary": {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "To remove in the future \u2013\u2013 scipy.linalg.interpolative"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": null
    },
    "Warnings": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Warns": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    },
    "Yields": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null
    }
  },
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null
  },
  "item_file": "/scipy/linalg/interpolative.py",
  "item_line": 0,
  "item_type": "<class 'module'>",
  "ordered_sections": [
    "Summary",
    "Extended Summary"
  ],
  "references": null,
  "see_also": [],
  "signature": {
    "value": null
  }
}