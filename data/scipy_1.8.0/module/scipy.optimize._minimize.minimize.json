{
  "_content": {
    "Attributes": {
      "children": [],
      "title": null
    },
    "Extended Summary": {
      "children": [],
      "title": null
    },
    "Methods": {
      "children": [],
      "title": null
    },
    "Notes": {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "This section describes the available solvers that can be selected by the 'method' parameter. The default method is "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "BFGS"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": "."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "content": {
                    "value": "Unconstrained minimization"
                  }
                },
                "type": "Strong"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Method "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "CG <optimize.minimize-cg>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " uses a nonlinear conjugate gradient algorithm by Polak and Ribiere, a variant of the Fletcher-Reeves method described in  pp.120-122. Only the first derivatives are used."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Method "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "BFGS <optimize.minimize-bfgs>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " uses the quasi-Newton method of Broyden, Fletcher, Goldfarb, and Shanno (BFGS)  pp. 136. It uses the first derivatives only. BFGS has proven good performance even for non-smooth optimizations. This method also returns an approximation of the Hessian inverse, stored as "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "hess_inv"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " in the OptimizeResult object."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Method "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "Newton-CG <optimize.minimize-newtoncg>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " uses a Newton-CG algorithm  pp. 168 (also known as the truncated Newton method). It uses a CG method to the compute the search direction. See also "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "TNC"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " method for a box-constrained minimization with a similar algorithm. Suitable for large-scale problems."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Method "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "dogleg <optimize.minimize-dogleg>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " uses the dog-leg trust-region algorithm  for unconstrained minimization. This algorithm requires the gradient and Hessian; furthermore the Hessian is required to be positive definite."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Method "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "trust-ncg <optimize.minimize-trustncg>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " uses the Newton conjugate gradient trust-region algorithm  for unconstrained minimization. This algorithm requires the gradient and either the Hessian or a function that computes the product of the Hessian with a given vector. Suitable for large-scale problems."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Method "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "trust-krylov <optimize.minimize-trustkrylov>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " uses the Newton GLTR trust-region algorithm ,  for unconstrained minimization. This algorithm requires the gradient and either the Hessian or a function that computes the product of the Hessian with a given vector. Suitable for large-scale problems. On indefinite problems it requires usually less iterations than the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "trust-ncg"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " method and is recommended for medium and large-scale problems."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Method "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "trust-exact <optimize.minimize-trustexact>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is a trust-region method for unconstrained minimization in which quadratic subproblems are solved almost exactly . This algorithm requires the gradient and the Hessian (which is "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "not"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " required to be positive definite). It is, in many situations, the Newton method to converge in fewer iterations and the most recommended for small and medium-size problems."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "content": {
                    "value": "Bound-Constrained minimization"
                  }
                },
                "type": "Strong"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Method "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "Nelder-Mead <optimize.minimize-neldermead>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " uses the Simplex algorithm , . This algorithm is robust in many applications. However, if numerical computation of derivative can be trusted, other algorithms using the first and/or second derivatives information might be preferred for their better performance in general."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Method "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "L-BFGS-B <optimize.minimize-lbfgsb>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " uses the L-BFGS-B algorithm ,  for bound constrained minimization."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Method "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "Powell <optimize.minimize-powell>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is a modification of Powell's method ,  which is a conjugate direction method. It performs sequential one-dimensional minimizations along each vector of the directions set ("
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "direc"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " field in "
                },
                "type": "Words"
              },
              {
                "data": {
                  "exists": true,
                  "kind": "local",
                  "reference": {
                    "kind": "local",
                    "module": null,
                    "path": "options",
                    "version": null
                  },
                  "value": "options"
                },
                "type": "Link"
              },
              {
                "data": {
                  "value": " and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "info"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": "), which is updated at each iteration of the main minimization loop. The function need not be differentiable, and no derivatives are taken. If bounds are not provided, then an unbounded line search will be used. If bounds are provided and the initial guess is within the bounds, then every function evaluation throughout the minimization procedure will be within the bounds. If bounds are provided, the initial guess is outside the bounds, and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "direc"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " is full rank (default has full rank), then some function evaluations during the first iteration may be outside the bounds, but every function evaluation after the first iteration will be within the bounds. If "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "direc"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " is not full rank, then some parameters may not be optimized and the solution is not guaranteed to be within the bounds."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Method "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "TNC <optimize.minimize-tnc>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " uses a truncated Newton algorithm ,  to minimize a function with variables subject to bounds. This algorithm uses gradient information; it is also called Newton Conjugate-Gradient. It differs from the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": {
                    "value": "Newton-CG"
                  }
                },
                "type": "Emph"
              },
              {
                "data": {
                  "value": " method described above as it wraps a C implementation and allows each variable to be given upper and lower bounds."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "content": {
                    "value": "Constrained Minimization"
                  }
                },
                "type": "Strong"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Method "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "COBYLA <optimize.minimize-cobyla>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " uses the Constrained Optimization BY Linear Approximation (COBYLA) method , , . The algorithm is based on linear approximations to the objective function and each constraint. The method wraps a FORTRAN implementation of the algorithm. The constraints functions 'fun' may return either a single number or an array or list of numbers."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Method "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "SLSQP <optimize.minimize-slsqp>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " uses Sequential Least SQuares Programming to minimize a function of several variables with any combination of bounds, equality and inequality constraints. The method wraps the SLSQP Optimization subroutine originally implemented by Dieter Kraft . Note that the wrapper handles infinite values in bounds by converting them into large floating values."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Method "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "trust-constr <optimize.minimize-trustconstr>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " is a trust-region algorithm for constrained optimization. It swiches between two implementations depending on the problem definition. It is the most versatile constrained minimization algorithm implemented in SciPy and the most appropriate for large-scale problems. For equality constrained problems it is an implementation of Byrd-Omojokun Trust-Region SQP method described in  and in , p. 549. When inequality constraints are imposed as well, it swiches to the trust-region interior point method described in . This interior point algorithm, in turn, solves inequality constraints by introducing slack variables and solving a sequence of equality-constrained barrier problems for progressively smaller values of the barrier parameter. The previously described equality constrained SQP method is used to solve the subproblems with increasing levels of accuracy as the iterate gets closer to a solution."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "content": {
                    "value": "Finite-Difference Options"
                  }
                },
                "type": "Strong"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "For Method "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "trust-constr <optimize.minimize-trustconstr>"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " the gradient and the Hessian may be approximated using three finite-difference schemes: {'2-point', '3-point', 'cs'}. The scheme 'cs' is, potentially, the most accurate but it requires the function to correctly handle complex inputs and to be differentiable in the complex plane. The scheme '3-point' is more accurate than '2-point' but requires twice as many operations. If the gradient is estimated via finite-differences the Hessian must be estimated using one of the quasi-Newton strategies."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "content": {
                    "value": "Method specific options for the"
                  }
                },
                "type": "Strong"
              },
              {
                "data": {
                  "value": " "
                },
                "type": "Words"
              },
              {
                "data": {
                  "exists": true,
                  "kind": "local",
                  "reference": {
                    "kind": "local",
                    "module": null,
                    "path": "hess",
                    "version": null
                  },
                  "value": "hess"
                },
                "type": "Link"
              },
              {
                "data": {
                  "value": " "
                },
                "type": "Words"
              },
              {
                "data": {
                  "content": {
                    "value": "keyword"
                  }
                },
                "type": "Strong"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "+--------------+------+----------+-------------------------+-----+ | method/Hess  | None | callable | '2-point/'3-point'/'cs' | HUS | +==============+======+==========+=========================+=====+ | Newton-CG    | x    | (n, n)   | x                       | x   | |              |      | LO       |                         |     | +--------------+------+----------+-------------------------+-----+ | dogleg       |      | (n, n)   |                         |     | +--------------+------+----------+-------------------------+-----+ | trust-ncg    |      | (n, n)   | x                       | x   | +--------------+------+----------+-------------------------+-----+ | trust-krylov |      | (n, n)   | x                       | x   | +--------------+------+----------+-------------------------+-----+ | trust-exact  |      | (n, n)   |                         |     | +--------------+------+----------+-------------------------+-----+ | trust-constr | x    | (n, n)   |  x                      | x   | |              |      | LO       |                         |     | |              |      | sp       |                         |     | +--------------+------+----------+-------------------------+-----+"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "where LO=LinearOperator, sp=Sparse matrix, HUS=HessianUpdateStrategy"
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "content": {
                    "value": "Custom minimizers"
                  }
                },
                "type": "Strong"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "It may be useful to pass a custom minimization method, for example when using a frontend to this method such as "
                },
                "type": "Words"
              },
              {
                "data": {
                  "exists": true,
                  "kind": "module",
                  "reference": {
                    "kind": "api",
                    "module": "scipy",
                    "path": "scipy.optimize._basinhopping.basinhopping",
                    "version": "*"
                  },
                  "value": "scipy.optimize.basinhopping"
                },
                "type": "Link"
              },
              {
                "data": {
                  "value": " or a different library.  You can simply pass a callable as the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "method"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " parameter."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "The callable is called as "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "method(fun, x0, args, **kwargs, **options)"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " where "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "kwargs"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": " corresponds to any other parameters passed to "
                },
                "type": "Words"
              },
              {
                "data": {
                  "exists": true,
                  "kind": "module",
                  "reference": {
                    "kind": "module",
                    "module": "scipy",
                    "path": "scipy.optimize._minimize.minimize",
                    "version": "1.8.0"
                  },
                  "value": "minimize"
                },
                "type": "Link"
              },
              {
                "data": {
                  "value": " (such as "
                },
                "type": "Words"
              },
              {
                "data": {
                  "exists": true,
                  "kind": "local",
                  "reference": {
                    "kind": "local",
                    "module": null,
                    "path": "callback",
                    "version": null
                  },
                  "value": "callback"
                },
                "type": "Link"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "exists": true,
                  "kind": "local",
                  "reference": {
                    "kind": "local",
                    "module": null,
                    "path": "hess",
                    "version": null
                  },
                  "value": "hess"
                },
                "type": "Link"
              },
              {
                "data": {
                  "value": ", etc.), except the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "exists": true,
                  "kind": "local",
                  "reference": {
                    "kind": "local",
                    "module": null,
                    "path": "options",
                    "version": null
                  },
                  "value": "options"
                },
                "type": "Link"
              },
              {
                "data": {
                  "value": " dict, which has its contents also passed as "
                },
                "type": "Words"
              },
              {
                "data": {
                  "exists": true,
                  "kind": "local",
                  "reference": {
                    "kind": "local",
                    "module": null,
                    "path": "method",
                    "version": null
                  },
                  "value": "method"
                },
                "type": "Link"
              },
              {
                "data": {
                  "value": " parameters pair by pair.  Also, if "
                },
                "type": "Words"
              },
              {
                "data": {
                  "exists": true,
                  "kind": "local",
                  "reference": {
                    "kind": "local",
                    "module": null,
                    "path": "jac",
                    "version": null
                  },
                  "value": "jac"
                },
                "type": "Link"
              },
              {
                "data": {
                  "value": " has been passed as a bool type, "
                },
                "type": "Words"
              },
              {
                "data": {
                  "exists": true,
                  "kind": "local",
                  "reference": {
                    "kind": "local",
                    "module": null,
                    "path": "jac",
                    "version": null
                  },
                  "value": "jac"
                },
                "type": "Link"
              },
              {
                "data": {
                  "value": " and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "exists": true,
                  "kind": "local",
                  "reference": {
                    "kind": "local",
                    "module": null,
                    "path": "fun",
                    "version": null
                  },
                  "value": "fun"
                },
                "type": "Link"
              },
              {
                "data": {
                  "value": " are mangled so that "
                },
                "type": "Words"
              },
              {
                "data": {
                  "exists": true,
                  "kind": "local",
                  "reference": {
                    "kind": "local",
                    "module": null,
                    "path": "fun",
                    "version": null
                  },
                  "value": "fun"
                },
                "type": "Link"
              },
              {
                "data": {
                  "value": " returns just the function values and "
                },
                "type": "Words"
              },
              {
                "data": {
                  "exists": true,
                  "kind": "local",
                  "reference": {
                    "kind": "local",
                    "module": null,
                    "path": "jac",
                    "version": null
                  },
                  "value": "jac"
                },
                "type": "Link"
              },
              {
                "data": {
                  "value": " is converted to a function returning the Jacobian.  The method shall return an "
                },
                "type": "Words"
              },
              {
                "data": {
                  "exists": true,
                  "kind": "module",
                  "reference": {
                    "kind": "module",
                    "module": "scipy",
                    "path": "scipy.optimize._optimize.OptimizeResult",
                    "version": "1.8.0"
                  },
                  "value": "OptimizeResult"
                },
                "type": "Link"
              },
              {
                "data": {
                  "value": " object."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "The provided "
                },
                "type": "Words"
              },
              {
                "data": {
                  "exists": true,
                  "kind": "local",
                  "reference": {
                    "kind": "local",
                    "module": null,
                    "path": "method",
                    "version": null
                  },
                  "value": "method"
                },
                "type": "Link"
              },
              {
                "data": {
                  "value": " callable must be able to accept (and possibly ignore) arbitrary parameters; the set of parameters accepted by "
                },
                "type": "Words"
              },
              {
                "data": {
                  "exists": true,
                  "kind": "module",
                  "reference": {
                    "kind": "module",
                    "module": "scipy",
                    "path": "scipy.optimize._minimize.minimize",
                    "version": "1.8.0"
                  },
                  "value": "minimize"
                },
                "type": "Link"
              },
              {
                "data": {
                  "value": " may expand in future versions and then these parameters will be passed to the method.  You can find an example in the scipy.optimize tutorial."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "inline": [
                  {
                    "data": {
                      "value": "0.11.0 "
                    },
                    "type": "Words"
                  }
                ],
                "inner": []
              }
            ],
            "kind": "versionadded",
            "title": "TODO"
          },
          "type": "Admonition"
        }
      ],
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "title": null
    },
    "Parameters": {
      "children": [
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "The objective function to be minimized."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "value": [
                    "``fun(x, *args) -> float``"
                  ]
                },
                "type": "BlockQuote"
              },
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "where "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "x"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " is an 1-D array with shape (n,) and "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "args"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " is a tuple of the fixed parameters needed to completely specify the function."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "fun",
            "type_": "callable"
          },
          "type": "Param"
        },
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Initial guess. Array of real elements of size (n,), where "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "n"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " is the number of independent variables."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "x0",
            "type_": "ndarray, shape (n,)"
          },
          "type": "Param"
        },
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Extra arguments passed to the objective function and its derivatives ("
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "fun",
                          "version": null
                        },
                        "value": "fun"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": ", "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "jac",
                          "version": null
                        },
                        "value": "jac"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " and "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "hess",
                          "version": null
                        },
                        "value": "hess"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " functions)."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "args",
            "type_": "tuple, optional"
          },
          "type": "Param"
        },
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Type of solver.  Should be one of"
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "value": [
                    "- 'Nelder-Mead' :ref:`(see here) <optimize.minimize-neldermead>`",
                    "- 'Powell'      :ref:`(see here) <optimize.minimize-powell>`",
                    "- 'CG'          :ref:`(see here) <optimize.minimize-cg>`",
                    "- 'BFGS'        :ref:`(see here) <optimize.minimize-bfgs>`",
                    "- 'Newton-CG'   :ref:`(see here) <optimize.minimize-newtoncg>`",
                    "- 'L-BFGS-B'    :ref:`(see here) <optimize.minimize-lbfgsb>`",
                    "- 'TNC'         :ref:`(see here) <optimize.minimize-tnc>`",
                    "- 'COBYLA'      :ref:`(see here) <optimize.minimize-cobyla>`",
                    "- 'SLSQP'       :ref:`(see here) <optimize.minimize-slsqp>`",
                    "- 'trust-constr':ref:`(see here) <optimize.minimize-trustconstr>`",
                    "- 'dogleg'      :ref:`(see here) <optimize.minimize-dogleg>`",
                    "- 'trust-ncg'   :ref:`(see here) <optimize.minimize-trustncg>`",
                    "- 'trust-exact' :ref:`(see here) <optimize.minimize-trustexact>`",
                    "- 'trust-krylov' :ref:`(see here) <optimize.minimize-trustkrylov>`",
                    "- custom - a callable object (added in version 0.14.0),",
                    "  see below for description."
                  ]
                },
                "type": "BlockQuote"
              },
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "If not given, chosen to be one of "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "BFGS"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ", "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "L-BFGS-B"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ", "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "SLSQP"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ", depending on whether or not the problem has constraints or bounds."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "method",
            "type_": "str or callable, optional"
          },
          "type": "Param"
        },
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Method for computing the gradient vector. Only for CG, BFGS, Newton-CG, L-BFGS-B, TNC, SLSQP, dogleg, trust-ncg, trust-krylov, trust-exact and trust-constr. If it is a callable, it should be a function that returns the gradient vector:"
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "value": [
                    "``jac(x, *args) -> array_like, shape (n,)``"
                  ]
                },
                "type": "BlockQuote"
              },
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "where "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "x"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " is an array with shape (n,) and "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "args"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " is a tuple with the fixed parameters. If "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "jac",
                          "version": null
                        },
                        "value": "jac"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " is a Boolean and is True, "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "fun",
                          "version": null
                        },
                        "value": "fun"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " is assumed to return a tuple "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "(f, g)"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " containing the objective function and the gradient. Methods 'Newton-CG', 'trust-ncg', 'dogleg', 'trust-exact', and 'trust-krylov' require that either a callable be supplied, or that "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "fun",
                          "version": null
                        },
                        "value": "fun"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " return the objective and gradient. If None or False, the gradient will be estimated using 2-point finite difference estimation with an absolute step size. Alternatively, the keywords  {'2-point', '3-point', 'cs'} can be used to select a finite difference scheme for numerical estimation of the gradient with a relative step size. These finite difference schemes obey any specified "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "bounds",
                          "version": null
                        },
                        "value": "bounds"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": "."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "jac",
            "type_": "{callable,  '2-point', '3-point', 'cs', bool}, optional"
          },
          "type": "Param"
        },
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Method for computing the Hessian matrix. Only for Newton-CG, dogleg, trust-ncg, trust-krylov, trust-exact and trust-constr. If it is callable, it should return the Hessian matrix:"
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "value": [
                    "``hess(x, *args) -> {LinearOperator, spmatrix, array}, (n, n)``"
                  ]
                },
                "type": "BlockQuote"
              },
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "where "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "x"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " is a (n,) ndarray and "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "args"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " is a tuple with the fixed parameters. The keywords {'2-point', '3-point', 'cs'} can also be used to select a finite difference scheme for numerical estimation of the hessian. Alternatively, objects implementing the "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "module",
                        "reference": {
                          "kind": "module",
                          "module": "scipy",
                          "path": "scipy.optimize._hessian_update_strategy.HessianUpdateStrategy",
                          "version": "1.8.0"
                        },
                        "value": "HessianUpdateStrategy"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " interface can be used to approximate the Hessian. Available quasi-Newton methods implementing this interface are:"
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "value": [
                    "- `BFGS`;",
                    "- `SR1`."
                  ]
                },
                "type": "BlockQuote"
              },
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Not all of the options are available for each of the methods; for availability refer to the notes."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "hess",
            "type_": "{callable, '2-point', '3-point', 'cs', HessianUpdateStrategy}, optional"
          },
          "type": "Param"
        },
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Hessian of objective function times an arbitrary vector p. Only for Newton-CG, trust-ncg, trust-krylov, trust-constr. Only one of "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "hessp",
                          "version": null
                        },
                        "value": "hessp"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " or "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "hess",
                          "version": null
                        },
                        "value": "hess"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " needs to be given. If "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "hess",
                          "version": null
                        },
                        "value": "hess"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " is provided, then "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "hessp",
                          "version": null
                        },
                        "value": "hessp"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " will be ignored. "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "hessp",
                          "version": null
                        },
                        "value": "hessp"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " must compute the Hessian times an arbitrary vector:"
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "value": [
                    "``hessp(x, p, *args) ->  ndarray shape (n,)``"
                  ]
                },
                "type": "BlockQuote"
              },
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "where "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "x"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " is a (n,) ndarray, "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "p"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " is an arbitrary vector with dimension (n,) and "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "args"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " is a tuple with the fixed parameters."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "hessp",
            "type_": "callable, optional"
          },
          "type": "Param"
        },
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Bounds on variables for Nelder-Mead, L-BFGS-B, TNC, SLSQP, Powell, and trust-constr methods. There are two ways to specify the bounds:"
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "value": [
                    "1. Instance of `Bounds` class.",
                    "2. Sequence of ``(min, max)`` pairs for each element in `x`. None",
                    "   is used to specify no bound."
                  ]
                },
                "type": "BlockQuote"
              }
            ],
            "param": "bounds",
            "type_": "sequence or `Bounds`, optional"
          },
          "type": "Param"
        },
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Constraints definition. Only for COBYLA, SLSQP and trust-constr."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Constraints for 'trust-constr' are defined as a single object or a list of objects specifying constraints to the optimization problem. Available constraints are:"
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "value": [
                    "- `LinearConstraint`",
                    "- `NonlinearConstraint`"
                  ]
                },
                "type": "BlockQuote"
              },
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Constraints for COBYLA, SLSQP are defined as a list of dictionaries. Each dictionary with fields:"
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "value": [
                    "type : str",
                    "    Constraint type: 'eq' for equality, 'ineq' for inequality.",
                    "fun : callable",
                    "    The function defining the constraint.",
                    "jac : callable, optional",
                    "    The Jacobian of `fun` (only for SLSQP).",
                    "args : sequence, optional",
                    "    Extra arguments to be passed to the function and Jacobian."
                  ]
                },
                "type": "BlockQuote"
              },
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Equality constraint means that the constraint function result is to be zero whereas inequality means that it is to be non-negative. Note that COBYLA only supports inequality constraints."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "constraints",
            "type_": "{Constraint, dict} or List of {Constraint, dict}, optional"
          },
          "type": "Param"
        },
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Tolerance for termination. When "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "tol",
                          "version": null
                        },
                        "value": "tol"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " is specified, the selected minimization algorithm sets some relevant solver-specific tolerance(s) equal to "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "tol",
                          "version": null
                        },
                        "value": "tol"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": ". For detailed control, use solver-specific options."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "tol",
            "type_": "float, optional"
          },
          "type": "Param"
        },
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "A dictionary of solver options. All methods accept the following generic options:"
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "value": [
                    "maxiter : int",
                    "    Maximum number of iterations to perform. Depending on the",
                    "    method each iteration may use several function evaluations.",
                    "disp : bool",
                    "    Set to True to print convergence messages."
                  ]
                },
                "type": "BlockQuote"
              },
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "For method-specific options, see "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "show_options()"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": "."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "options",
            "type_": "dict, optional"
          },
          "type": "Param"
        },
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Called after each iteration. For 'trust-constr' it is a callable with the signature:"
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "value": [
                    "``callback(xk, OptimizeResult state) -> bool``"
                  ]
                },
                "type": "BlockQuote"
              },
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "where "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "xk"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " is the current parameter vector. and "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "state"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " is an "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "module",
                        "reference": {
                          "kind": "module",
                          "module": "scipy",
                          "path": "scipy.optimize._optimize.OptimizeResult",
                          "version": "1.8.0"
                        },
                        "value": "OptimizeResult"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " object, with the same fields as the ones from the return. If callback returns True the algorithm execution is terminated. For all the other methods, the signature is:"
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "value": [
                    "``callback(xk)``"
                  ]
                },
                "type": "BlockQuote"
              },
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "where "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "xk"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " is the current parameter vector."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "callback",
            "type_": "callable, optional"
          },
          "type": "Param"
        }
      ],
      "title": null
    },
    "Raises": {
      "children": [],
      "title": null
    },
    "Receives": {
      "children": [],
      "title": null
    },
    "Returns": {
      "children": [
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "The optimization result represented as a "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "OptimizeResult"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " object. Important attributes are: "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "x"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " the solution array, "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "success"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " a Boolean flag indicating if the optimizer exited successfully and "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "message"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " which describes the cause of the termination. See "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "module",
                        "reference": {
                          "kind": "module",
                          "module": "scipy",
                          "path": "scipy.optimize._optimize.OptimizeResult",
                          "version": "1.8.0"
                        },
                        "value": "OptimizeResult"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " for a description of other attributes."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "res",
            "type_": "OptimizeResult"
          },
          "type": "Param"
        }
      ],
      "title": null
    },
    "Summary": {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Minimization of scalar function of one or more variables."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        }
      ],
      "title": null
    },
    "Warnings": {
      "children": [],
      "title": null
    },
    "Warns": {
      "children": [],
      "title": null
    },
    "Yields": {
      "children": [],
      "title": null
    }
  },
  "aliases": [
    "scipy.signal._filter_design.optimize.minimize"
  ],
  "arbitrary": [],
  "example_section_data": {
    "children": [
      {
        "data": {
          "inline": [
            {
              "data": {
                "value": "Let us consider the problem of minimizing the Rosenbrock function. This function (and its respective derivatives) is implemented in "
              },
              "type": "Words"
            },
            {
              "data": {
                "exists": true,
                "kind": "module",
                "reference": {
                  "kind": "module",
                  "module": "scipy",
                  "path": "scipy.optimize._optimize.rosen",
                  "version": "1.8.0"
                },
                "value": "rosen"
              },
              "type": "Link"
            },
            {
              "data": {
                "value": " (resp. "
              },
              "type": "Words"
            },
            {
              "data": {
                "exists": true,
                "kind": "module",
                "reference": {
                  "kind": "module",
                  "module": "scipy",
                  "path": "scipy.optimize._optimize.rosen_der",
                  "version": "1.8.0"
                },
                "value": "rosen_der"
              },
              "type": "Link"
            },
            {
              "data": {
                "value": ", "
              },
              "type": "Words"
            },
            {
              "data": {
                "exists": true,
                "kind": "module",
                "reference": {
                  "kind": "module",
                  "module": "scipy",
                  "path": "scipy.optimize._optimize.rosen_hess",
                  "version": "1.8.0"
                },
                "value": "rosen_hess"
              },
              "type": "Link"
            },
            {
              "data": {
                "value": ") in the "
              },
              "type": "Words"
            },
            {
              "data": {
                "exists": true,
                "kind": "module",
                "reference": {
                  "kind": "module",
                  "module": "scipy",
                  "path": "scipy.optimize",
                  "version": "1.8.0"
                },
                "value": "scipy.optimize"
              },
              "type": "Link"
            },
            {
              "data": {
                "value": "."
              },
              "type": "Words"
            }
          ],
          "inner": []
        },
        "type": "Paragraph"
      },
      {
        "data": {
          "ce_status": "execed",
          "entries": [
            [
              "from",
              null,
              "kn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "scipy",
              "scipy",
              "nn"
            ],
            [
              ".",
              "",
              "nn"
            ],
            [
              "optimize",
              "scipy.optimize",
              "nn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "import",
              null,
              "kn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "minimize",
              "scipy.optimize._minimize.minimize",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "rosen",
              "scipy.optimize._optimize.rosen",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "rosen_der",
              "scipy.optimize._optimize.rosen_der",
              ""
            ]
          ],
          "out": ""
        },
        "type": "Code"
      },
      {
        "data": {
          "inline": [
            {
              "data": {
                "value": "A simple application of the "
              },
              "type": "Words"
            },
            {
              "data": {
                "value": {
                  "value": "Nelder-Mead"
                }
              },
              "type": "Emph"
            },
            {
              "data": {
                "value": " method is:"
              },
              "type": "Words"
            }
          ],
          "inner": []
        },
        "type": "Paragraph"
      },
      {
        "data": {
          "ce_status": "execed",
          "entries": [
            [
              "x0",
              "builtins.list",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "1.3",
              "",
              "mf"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "0.7",
              "",
              "mf"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "0.8",
              "",
              "mf"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "1.9",
              "",
              "mf"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "1.2",
              "",
              "mf"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "res",
              "scipy.optimize._optimize.OptimizeResult",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "minimize",
              "scipy.optimize._minimize.minimize",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "rosen",
              "scipy.optimize._optimize.rosen",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x0",
              "builtins.list",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "method",
              null,
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              "Nelder-Mead",
              "",
              "s1"
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "tol",
              null,
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              "1e-6",
              "",
              "mf"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "res",
              "scipy.optimize._optimize.OptimizeResult",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "x",
              null,
              ""
            ]
          ],
          "out": "array([ 1.,  1.,  1.,  1.,  1.])"
        },
        "type": "Code"
      },
      {
        "data": {
          "inline": [
            {
              "data": {
                "value": "Now using the "
              },
              "type": "Words"
            },
            {
              "data": {
                "value": {
                  "value": "BFGS"
                }
              },
              "type": "Emph"
            },
            {
              "data": {
                "value": " algorithm, using the first derivative and a few options:"
              },
              "type": "Words"
            }
          ],
          "inner": []
        },
        "type": "Paragraph"
      },
      {
        "data": {
          "ce_status": "execed",
          "entries": [
            [
              "res",
              "scipy.optimize._optimize.OptimizeResult",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "minimize",
              "scipy.optimize._minimize.minimize",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "rosen",
              "scipy.optimize._optimize.rosen",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x0",
              "builtins.list",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "method",
              null,
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              "BFGS",
              null,
              "s1"
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "jac",
              null,
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              "rosen_der",
              "scipy.optimize._optimize.rosen_der",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "               ",
              "",
              ""
            ],
            [
              "options",
              null,
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              "{",
              "",
              ""
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              "gtol",
              null,
              "s1"
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              ":",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "1e-6",
              "",
              "mf"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              "disp",
              null,
              "s1"
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              ":",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "True",
              null,
              "kc"
            ],
            [
              "}",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ]
          ],
          "out": "Optimization terminated successfully.\n         Current function value: 0.000000\n         Iterations: 26\n         Function evaluations: 31\n         Gradient evaluations: 31"
        },
        "type": "Code"
      },
      {
        "data": {
          "ce_status": "execed",
          "entries": [
            [
              "res",
              "scipy.optimize._optimize.OptimizeResult",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "x",
              null,
              ""
            ]
          ],
          "out": "array([ 1.,  1.,  1.,  1.,  1.])"
        },
        "type": "Code"
      },
      {
        "data": {
          "ce_status": "execed",
          "entries": [
            [
              "print",
              "builtins.print",
              "nb"
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "res",
              "scipy.optimize._optimize.OptimizeResult",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "message",
              null,
              ""
            ],
            [
              ")",
              "",
              ""
            ]
          ],
          "out": "Optimization terminated successfully."
        },
        "type": "Code"
      },
      {
        "data": {
          "ce_status": "execed",
          "entries": [
            [
              "res",
              "scipy.optimize._optimize.OptimizeResult",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "hess_inv",
              null,
              ""
            ]
          ],
          "out": "array([[ 0.00749589,  0.01255155,  0.02396251,  0.04750988,  0.09495377],  # may vary\n       [ 0.01255155,  0.02510441,  0.04794055,  0.09502834,  0.18996269],\n       [ 0.02396251,  0.04794055,  0.09631614,  0.19092151,  0.38165151],\n       [ 0.04750988,  0.09502834,  0.19092151,  0.38341252,  0.7664427 ],\n       [ 0.09495377,  0.18996269,  0.38165151,  0.7664427,   1.53713523]])"
        },
        "type": "Code"
      },
      {
        "data": {
          "inline": [
            {
              "data": {
                "value": "Next, consider a minimization problem with several constraints (namely Example 16.4 from ). The objective function is:"
              },
              "type": "Words"
            }
          ],
          "inner": []
        },
        "type": "Paragraph"
      },
      {
        "data": {
          "ce_status": "execed",
          "entries": [
            [
              "fun",
              null,
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "lambda",
              null,
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              ":",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "-",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "1",
              "",
              "mi"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "+",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "1",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "-",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2.5",
              "",
              "mf"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              "2",
              "",
              "mi"
            ]
          ],
          "out": ""
        },
        "type": "Code"
      },
      {
        "data": {
          "inline": [
            {
              "data": {
                "value": "There are three constraints defined as:"
              },
              "type": "Words"
            }
          ],
          "inner": []
        },
        "type": "Paragraph"
      },
      {
        "data": {
          "ce_status": "execed",
          "entries": [
            [
              "cons",
              "builtins.tuple",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "{",
              "",
              ""
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              "type",
              null,
              "s1"
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              ":",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              "ineq",
              null,
              "s1"
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              "fun",
              null,
              "s1"
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              ":",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "lambda",
              null,
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              ":",
              "",
              ""
            ],
            [
              "  ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "-",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "1",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "+",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              "}",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "        ",
              "",
              ""
            ],
            [
              "{",
              "",
              ""
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              "type",
              null,
              "s1"
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              ":",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              "ineq",
              null,
              "s1"
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              "fun",
              null,
              "s1"
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              ":",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "lambda",
              null,
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              ":",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "-",
              "",
              "o"
            ],
            [
              "x",
              null,
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "-",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "1",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "+",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "6",
              "",
              "mi"
            ],
            [
              "}",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "        ",
              "",
              ""
            ],
            [
              "{",
              "",
              ""
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              "type",
              null,
              "s1"
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              ":",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              "ineq",
              null,
              "s1"
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              "fun",
              null,
              "s1"
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              ":",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "lambda",
              null,
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              ":",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "-",
              "",
              "o"
            ],
            [
              "x",
              null,
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "+",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "1",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "+",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              "}",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ]
          ],
          "out": ""
        },
        "type": "Code"
      },
      {
        "data": {
          "inline": [
            {
              "data": {
                "value": "And variables must be positive, hence the following bounds:"
              },
              "type": "Words"
            }
          ],
          "inner": []
        },
        "type": "Paragraph"
      },
      {
        "data": {
          "ce_status": "execed",
          "entries": [
            [
              "bnds",
              "builtins.tuple",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "None",
              null,
              "kc"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "None",
              null,
              "kc"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ]
          ],
          "out": ""
        },
        "type": "Code"
      },
      {
        "data": {
          "inline": [
            {
              "data": {
                "value": "The optimization problem is solved using the SLSQP method as:"
              },
              "type": "Words"
            }
          ],
          "inner": []
        },
        "type": "Paragraph"
      },
      {
        "data": {
          "ce_status": "execed",
          "entries": [
            [
              "res",
              "scipy.optimize._optimize.OptimizeResult",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "minimize",
              "scipy.optimize._minimize.minimize",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "fun",
              null,
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "method",
              null,
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              "SLSQP",
              null,
              "s1"
            ],
            [
              "'",
              "",
              "s1"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "bounds",
              null,
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              "bnds",
              "builtins.tuple",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "               ",
              "",
              ""
            ],
            [
              "constraints",
              null,
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              "cons",
              "builtins.tuple",
              ""
            ],
            [
              ")",
              "",
              ""
            ]
          ],
          "out": ""
        },
        "type": "Code"
      },
      {
        "data": {
          "inline": [
            {
              "data": {
                "value": "It should converge to the theoretical solution (1.4 ,1.7)."
              },
              "type": "Words"
            }
          ],
          "inner": []
        },
        "type": "Paragraph"
      }
    ],
    "title": null
  },
  "item_file": "/scipy/optimize/_minimize.py",
  "item_line": 45,
  "item_type": "<class 'function'>",
  "ordered_sections": [
    "Summary",
    "Parameters",
    "Returns",
    "See Also",
    "Notes",
    "References",
    "Examples"
  ],
  "references": null,
  "refs": [
    "builtins.list",
    "builtins.print",
    "builtins.tuple",
    "minimize_scalar",
    "scipy",
    "scipy.optimize",
    "scipy.optimize._minimize.minimize",
    "scipy.optimize._optimize.OptimizeResult",
    "scipy.optimize._optimize.rosen",
    "scipy.optimize._optimize.rosen_der",
    "show_options"
  ],
  "see_also": [
    {
      "descriptions": [
        {
          "inline": [
            {
              "data": {
                "value": "Interface to minimization algorithms for scalar univariate functions"
              },
              "type": "Words"
            }
          ],
          "inner": []
        }
      ],
      "name": {
        "exists": true,
        "name": "minimize_scalar",
        "ref": "scipy.optimize._minimize.minimize_scalar"
      },
      "type": null
    },
    {
      "descriptions": [
        {
          "inline": [
            {
              "data": {
                "value": "Additional options accepted by the solvers"
              },
              "type": "Words"
            }
          ],
          "inner": []
        }
      ],
      "name": {
        "exists": true,
        "name": "show_options",
        "ref": "scipy.optimize._optimize.show_options"
      },
      "type": null
    }
  ],
  "signature": {
    "value": "minimize(fun, x0, args=(), method=None, jac=None, hess=None, hessp=None, bounds=None, constraints=(), tol=None, callback=None, options=None)"
  }
}