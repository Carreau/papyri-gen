{
  "_content": {
    "Attributes": {
      "children": [],
      "title": null
    },
    "Extended Summary": {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "If a function maps from R^n to R^m, its derivatives form m-by-n matrix called the Jacobian, where an element (i, j) is a partial derivative of f[i] with respect to x[j]."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        }
      ],
      "title": null
    },
    "Methods": {
      "children": [],
      "title": null
    },
    "Notes": {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "If "
                },
                "type": "Words"
              },
              {
                "data": {
                  "exists": true,
                  "kind": "local",
                  "reference": {
                    "kind": "local",
                    "module": null,
                    "path": "rel_step",
                    "version": null
                  },
                  "value": "rel_step"
                },
                "type": "Link"
              },
              {
                "data": {
                  "value": " is not provided, it assigned as "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "EPS**(1/s)"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", where EPS is determined from the smallest floating point dtype of "
                },
                "type": "Words"
              },
              {
                "data": {
                  "exists": true,
                  "kind": "local",
                  "reference": {
                    "kind": "local",
                    "module": null,
                    "path": "x0",
                    "version": null
                  },
                  "value": "x0"
                },
                "type": "Link"
              },
              {
                "data": {
                  "value": " or "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "fun(x0)"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "np.finfo(x0.dtype).eps"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", s=2 for '2-point' method and s=3 for '3-point' method. Such relative step approximately minimizes a sum of truncation and round-off errors, see . Relative steps are used by default. However, absolute steps are used when "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "abs_step is not None"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ". If any of the absolute or relative steps produces an indistinguishable difference from the original "
                },
                "type": "Words"
              },
              {
                "data": {
                  "exists": true,
                  "kind": "local",
                  "reference": {
                    "kind": "local",
                    "module": null,
                    "path": "x0",
                    "version": null
                  },
                  "value": "x0"
                },
                "type": "Link"
              },
              {
                "data": {
                  "value": ", "
                },
                "type": "Words"
              },
              {
                "data": {
                  "value": [
                    "(x0 + dx) - x0 == 0"
                  ]
                },
                "type": "Verbatim"
              },
              {
                "data": {
                  "value": ", then a automatic step size is substituted for that particular entry."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "A finite difference scheme for '3-point' method is selected automatically. The well-known central difference scheme is used for points sufficiently far from the boundary, and 3-point forward or backward scheme is used for points near the boundary. Both schemes have the second-order accuracy in terms of Taylor expansion. Refer to  for the formulas of 3-point forward and backward difference schemes."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "For dense differencing when m=1 Jacobian is returned with a shape (n,), on the other hand when n=1 Jacobian is returned with a shape (m, 1). Our motivation is the following: a) It handles a case of gradient computation (m=1) in a conventional way. b) It clearly separates these two different cases. b) In all cases np.atleast_2d can be called to get 2-D Jacobian with correct dimensions."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        }
      ],
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "title": null
    },
    "Parameters": {
      "children": [
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Function of which to estimate the derivatives. The argument x passed to this function is ndarray of shape (n,) (never a scalar even if n=1). It must return 1-D array_like of shape (m,) or a scalar."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "fun",
            "type_": "callable"
          },
          "type": "Param"
        },
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Point at which to estimate the derivatives. Float will be converted to a 1-D array."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "x0",
            "type_": "array_like of shape (n,) or float"
          },
          "type": "Param"
        },
        {
          "data": {
            "desc": [
              {
                "data": {
                  "children": [
                    {
                      "dd": [
                        {
                          "data": {
                            "children": [
                              {
                                "value": [
                                  {
                                    "data": {
                                      "children": [
                                        {
                                          "dd": [
                                            {
                                              "data": {
                                                "inline": [
                                                  {
                                                    "data": {
                                                      "value": "difference."
                                                    },
                                                    "type": "Words"
                                                  }
                                                ],
                                                "inner": []
                                              },
                                              "type": "Paragraph"
                                            }
                                          ],
                                          "dt": {
                                            "inline": [
                                              {
                                                "data": {
                                                  "value": "'2-point' - use the first order accuracy forward or backward"
                                                },
                                                "type": "Words"
                                              }
                                            ],
                                            "inner": []
                                          }
                                        }
                                      ]
                                    },
                                    "type": "DefList"
                                  }
                                ]
                              },
                              {
                                "value": [
                                  {
                                    "data": {
                                      "children": [
                                        {
                                          "dd": [
                                            {
                                              "data": {
                                                "inline": [
                                                  {
                                                    "data": {
                                                      "value": "second order accuracy forward or backward difference                   near the boundary."
                                                    },
                                                    "type": "Words"
                                                  }
                                                ],
                                                "inner": []
                                              },
                                              "type": "Paragraph"
                                            }
                                          ],
                                          "dt": {
                                            "inline": [
                                              {
                                                "data": {
                                                  "value": "'3-point' - use central difference in interior points and the"
                                                },
                                                "type": "Words"
                                              }
                                            ],
                                            "inner": []
                                          }
                                        }
                                      ]
                                    },
                                    "type": "DefList"
                                  }
                                ]
                              },
                              {
                                "value": [
                                  {
                                    "data": {
                                      "children": [
                                        {
                                          "dd": [
                                            {
                                              "data": {
                                                "inline": [
                                                  {
                                                    "data": {
                                                      "value": "that the user function is real-valued and can be              analytically continued to the complex plane. Otherwise,              produces bogus results."
                                                    },
                                                    "type": "Words"
                                                  }
                                                ],
                                                "inner": []
                                              },
                                              "type": "Paragraph"
                                            }
                                          ],
                                          "dt": {
                                            "inline": [
                                              {
                                                "data": {
                                                  "value": "'cs' - use a complex-step finite difference scheme. This assumes"
                                                },
                                                "type": "Words"
                                              }
                                            ],
                                            "inner": []
                                          }
                                        }
                                      ]
                                    },
                                    "type": "DefList"
                                  }
                                ]
                              }
                            ]
                          },
                          "type": "BulletList"
                        }
                      ],
                      "dt": {
                        "inline": [
                          {
                            "data": {
                              "value": "Finite difference method to use:"
                            },
                            "type": "Words"
                          }
                        ],
                        "inner": []
                      }
                    }
                  ]
                },
                "type": "DefList"
              }
            ],
            "param": "method",
            "type_": "{'3-point', '2-point', 'cs'}, optional"
          },
          "type": "Param"
        },
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Relative step size to use. If None (default) the absolute step size is computed as "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "h = rel_step * sign(x0) * max(1, abs(x0))"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ", with "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "rel_step",
                          "version": null
                        },
                        "value": "rel_step"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " being selected automatically, see Notes. Otherwise "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "h = rel_step * sign(x0) * abs(x0)"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ". For "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "method='3-point'"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " the sign of "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": null,
                        "value": "h"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": " is ignored. The calculated step size is possibly adjusted to fit into the bounds."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "rel_step",
            "type_": "None or array_like, optional"
          },
          "type": "Param"
        },
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Absolute step size to use, possibly adjusted to fit into the bounds. For "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "method='3-point'"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " the sign of "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "abs_step",
                          "version": null
                        },
                        "value": "abs_step"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " is ignored. By default relative steps are used, only if "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "abs_step is not None"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " are absolute steps used."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "abs_step",
            "type_": "array_like, optional"
          },
          "type": "Param"
        },
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "If not None it is assumed to be equal to "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "fun(x0)"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": ", in this case the "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "fun(x0)"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " is not called. Default is None."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "f0",
            "type_": "None or array_like, optional"
          },
          "type": "Param"
        },
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Lower and upper bounds on independent variables. Defaults to no bounds. Each bound must match the size of "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "x0",
                          "version": null
                        },
                        "value": "x0"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " or be a scalar, in the latter case the bound will be the same for all variables. Use it to limit the range of function evaluation. Bounds checking is not implemented when "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "as_linear_operator",
                          "version": null
                        },
                        "value": "as_linear_operator"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " is True."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "bounds",
            "type_": "tuple of array_like, optional"
          },
          "type": "Param"
        },
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Defines a sparsity structure of the Jacobian matrix. If the Jacobian matrix is known to have only few non-zero elements in each row, then it's possible to estimate its several columns by a single function evaluation . To perform such economic computations two ingredients are required:"
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "sparsity",
            "type_": "{None, array_like, sparse matrix, 2-tuple}, optional"
          },
          "type": "Param"
        },
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "When True the function returns an "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "module",
                        "reference": {
                          "kind": "api",
                          "module": "scipy",
                          "path": "scipy.sparse.linalg._interface.LinearOperator",
                          "version": "*"
                        },
                        "value": "scipy.sparse.linalg.LinearOperator"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": ". Otherwise it returns a dense array or a sparse matrix depending on "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "sparsity",
                          "version": null
                        },
                        "value": "sparsity"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": ". The linear operator provides an efficient way of computing "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "J.dot(p)"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " for any vector "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "p"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": " of shape (n,), but does not allow direct access to individual elements of the matrix. By default "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "as_linear_operator",
                          "version": null
                        },
                        "value": "as_linear_operator"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " is False."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "as_linear_operator",
            "type_": "bool, optional"
          },
          "type": "Param"
        },
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Additional arguments passed to "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "fun",
                          "version": null
                        },
                        "value": "fun"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": ". Both empty by default. The calling signature is "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "value": [
                          "fun(x, *args, **kwargs)"
                        ]
                      },
                      "type": "Verbatim"
                    },
                    {
                      "data": {
                        "value": "."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "args, kwargs",
            "type_": "tuple and dict, optional"
          },
          "type": "Param"
        }
      ],
      "title": null
    },
    "Raises": {
      "children": [],
      "title": null
    },
    "Receives": {
      "children": [],
      "title": null
    },
    "Returns": {
      "children": [
        {
          "data": {
            "desc": [
              {
                "data": {
                  "inline": [
                    {
                      "data": {
                        "value": "Finite difference approximation of the Jacobian matrix. If "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "as_linear_operator",
                          "version": null
                        },
                        "value": "as_linear_operator"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " is True returns a LinearOperator with shape (m, n). Otherwise it returns a dense array or sparse matrix depending on how "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "sparsity",
                          "version": null
                        },
                        "value": "sparsity"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " is defined. If "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "sparsity",
                          "version": null
                        },
                        "value": "sparsity"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " is None then a ndarray with shape (m, n) is returned. If "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "exists": true,
                        "kind": "local",
                        "reference": {
                          "kind": "local",
                          "module": null,
                          "path": "sparsity",
                          "version": null
                        },
                        "value": "sparsity"
                      },
                      "type": "Link"
                    },
                    {
                      "data": {
                        "value": " is not None returns a csr_matrix with shape (m, n). For sparse matrices and linear operators it is always returned as a 2-D structure, for ndarrays, if m=1 it is returned as a 1-D gradient array with shape (n,)."
                      },
                      "type": "Words"
                    }
                  ],
                  "inner": []
                },
                "type": "Paragraph"
              }
            ],
            "param": "J",
            "type_": "{ndarray, sparse matrix, LinearOperator}"
          },
          "type": "Param"
        }
      ],
      "title": null
    },
    "Summary": {
      "children": [
        {
          "data": {
            "inline": [
              {
                "data": {
                  "value": "Compute finite difference approximation of the derivatives of a vector-valued function."
                },
                "type": "Words"
              }
            ],
            "inner": []
          },
          "type": "Paragraph"
        }
      ],
      "title": null
    },
    "Warnings": {
      "children": [],
      "title": null
    },
    "Warns": {
      "children": [],
      "title": null
    },
    "Yields": {
      "children": [],
      "title": null
    }
  },
  "aliases": [
    "scipy.signal._filter_design.optimize._differentiable_functions.approx_derivative"
  ],
  "arbitrary": [],
  "example_section_data": {
    "children": [
      {
        "data": {
          "ce_status": "exception_in_exec",
          "entries": [
            [
              "import",
              null,
              "kn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "numpy",
              "numpy",
              "nn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "as",
              null,
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "numpy",
              "nn"
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "from",
              null,
              "kn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "scipy",
              "scipy",
              "nn"
            ],
            [
              ".",
              "",
              "nn"
            ],
            [
              "optimize",
              "scipy.optimize",
              "nn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "import",
              null,
              "kn"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "approx_derivative",
              "scipy.optimize._numdiff.approx_derivative",
              ""
            ]
          ],
          "out": ">>>"
        },
        "type": "Code"
      },
      {
        "data": {
          "ce_status": "execed",
          "entries": [
            [
              "def",
              null,
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "f",
              "__main__.f",
              "nf"
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "c1",
              null,
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "c2",
              null,
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ":",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "    ",
              "",
              ""
            ],
            [
              "return",
              null,
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "numpy",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "array",
              "numpy.array",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "numpy",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "sin",
              "numpy.ufunc",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "c1",
              null,
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "1",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "                     ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "0",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "numpy",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "cos",
              "numpy.ufunc",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "c2",
              null,
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "1",
              "",
              "mi"
            ],
            [
              "]",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              "]",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ]
          ],
          "out": "..."
        },
        "type": "Code"
      },
      {
        "data": {
          "ce_status": "execed",
          "entries": [
            [
              "x0",
              "numpy.ndarray",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "numpy",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "array",
              "numpy.array",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "[",
              "",
              ""
            ],
            [
              "1.0",
              "",
              "mf"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "0.5",
              "",
              "mf"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "numpy",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "pi",
              null,
              ""
            ],
            [
              "]",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "approx_derivative",
              "scipy.optimize._numdiff.approx_derivative",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "f",
              "__main__.f",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x0",
              "numpy.ndarray",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "args",
              null,
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "1",
              "",
              "mi"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ]
          ],
          "out": "array([[ 1.,  0.],\n       [-1.,  0.]])"
        },
        "type": "Code"
      },
      {
        "data": {
          "inline": [
            {
              "data": {
                "value": "Bounds can be used to limit the region of function evaluation. In the example below we compute left and right derivative at point 1.0."
              },
              "type": "Words"
            }
          ],
          "inner": []
        },
        "type": "Paragraph"
      },
      {
        "data": {
          "ce_status": "execed",
          "entries": [
            [
              "def",
              null,
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "g",
              "__main__.g",
              "nf"
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ":",
              "",
              ""
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "    ",
              "",
              ""
            ],
            [
              "return",
              null,
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              "*",
              "",
              "o"
            ],
            [
              "2",
              "",
              "mi"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "if",
              null,
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              ">",
              "",
              "o"
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "1",
              "",
              "mi"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "else",
              null,
              "k"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x",
              null,
              ""
            ]
          ],
          "out": "..."
        },
        "type": "Code"
      },
      {
        "data": {
          "ce_status": "execed",
          "entries": [
            [
              "x0",
              "builtins.float",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "1.0",
              "",
              "mf"
            ],
            [
              "\n",
              "",
              ""
            ],
            [
              "approx_derivative",
              "scipy.optimize._numdiff.approx_derivative",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "g",
              "__main__.g",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x0",
              "builtins.float",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "bounds",
              null,
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "-",
              "",
              "o"
            ],
            [
              "np",
              "numpy",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "inf",
              null,
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "1.0",
              "",
              "mf"
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ]
          ],
          "out": "array([ 1.])"
        },
        "type": "Code"
      },
      {
        "data": {
          "ce_status": "execed",
          "entries": [
            [
              "approx_derivative",
              "scipy.optimize._numdiff.approx_derivative",
              ""
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "g",
              "__main__.g",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "x0",
              "builtins.float",
              ""
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "bounds",
              null,
              ""
            ],
            [
              "=",
              "",
              "o"
            ],
            [
              "(",
              "",
              ""
            ],
            [
              "1.0",
              "",
              "mf"
            ],
            [
              ",",
              "",
              ""
            ],
            [
              " ",
              "",
              ""
            ],
            [
              "np",
              "numpy",
              ""
            ],
            [
              ".",
              "",
              "o"
            ],
            [
              "inf",
              null,
              ""
            ],
            [
              ")",
              "",
              ""
            ],
            [
              ")",
              "",
              ""
            ]
          ],
          "out": "array([ 2.])"
        },
        "type": "Code"
      }
    ],
    "title": null
  },
  "item_file": "/scipy/optimize/_numdiff.py",
  "item_line": 275,
  "item_type": "<class 'function'>",
  "ordered_sections": [
    "Summary",
    "Extended Summary",
    "Parameters",
    "Returns",
    "See Also",
    "Notes",
    "References",
    "Examples"
  ],
  "references": null,
  "refs": [
    "__main__.f",
    "__main__.g",
    "builtins.float",
    "check_derivative",
    "numpy",
    "numpy.array",
    "numpy.ndarray",
    "numpy.ufunc",
    "scipy",
    "scipy.optimize",
    "scipy.optimize._numdiff.approx_derivative"
  ],
  "see_also": [
    {
      "descriptions": [
        {
          "inline": [
            {
              "data": {
                "value": "Check correctness of a function computing derivatives."
              },
              "type": "Words"
            }
          ],
          "inner": []
        }
      ],
      "name": {
        "exists": true,
        "name": "check_derivative",
        "ref": "scipy.optimize._numdiff.check_derivative"
      },
      "type": null
    }
  ],
  "signature": {
    "value": "approx_derivative(fun, x0, method='3-point', rel_step=None, abs_step=None, f0=None, bounds=(-inf, inf), sparsity=None, as_linear_operator=False, args=(), kwargs={})"
  }
}