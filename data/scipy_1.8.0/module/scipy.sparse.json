{
  "_content": {
    "Attributes": {
      "children": [],
      "title": null
    },
    "Extended Summary": {
      "children": [],
      "title": null
    },
    "Methods": {
      "children": [],
      "title": null
    },
    "Notes": {
      "children": [],
      "title": null
    },
    "Other Parameters": {
      "children": [],
      "title": null
    },
    "Parameters": {
      "children": [],
      "title": null
    },
    "Raises": {
      "children": [],
      "title": null
    },
    "Receives": {
      "children": [],
      "title": null
    },
    "Returns": {
      "children": [],
      "title": null
    },
    "Summary": {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "To remove in the future \u2013\u2013 scipy.sparse"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "title": null
    },
    "Warnings": {
      "children": [],
      "title": null
    },
    "Warns": {
      "children": [],
      "title": null
    },
    "Yields": {
      "children": [],
      "title": null
    }
  },
  "aliases": [
    "scipy.signal._filter_design.optimize._differentiable_functions.sps"
  ],
  "arbitrary": [
    {
      "children": [
        {
          "data": {
            "argument": "scipy.sparse",
            "content": "",
            "name": "currentmodule",
            "options": []
          },
          "type": "BlockDirective"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "SciPy 2-D sparse array package for numeric data."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "This package is switching to an array interface, compatible with NumPy arrays, from the older matrix interface.  We recommend that you use the array objects ("
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": null,
                        "value": "bsr_array"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": ", "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": null,
                        "value": "coo_array"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": ", etc.) for all new work."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "When using the array interface, please note that:"
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "children": [
                    {
                      "children": [
                        {
                          "data": {
                            "children": [
                              {
                                "data": {
                                  "value": [
                                    "x * y"
                                  ]
                                },
                                "type": "Verbatim"
                              },
                              {
                                "data": {
                                  "value": " no longer performs matrix multiplication, but   element-wise multiplication (just like with NumPy arrays).  To   make code work with both arrays and matrices, use "
                                },
                                "type": "Words"
                              },
                              {
                                "data": {
                                  "value": [
                                    "x @ y"
                                  ]
                                },
                                "type": "Verbatim"
                              },
                              {
                                "data": {
                                  "value": " for   matrix multiplication."
                                },
                                "type": "Words"
                              }
                            ]
                          },
                          "type": "Paragraph"
                        }
                      ]
                    },
                    {
                      "children": [
                        {
                          "data": {
                            "children": [
                              {
                                "data": {
                                  "value": "Operations such as "
                                },
                                "type": "Words"
                              },
                              {
                                "data": {
                                  "domain": null,
                                  "role": null,
                                  "value": "sum"
                                },
                                "type": "Directive"
                              },
                              {
                                "data": {
                                  "value": ", that used to produce dense matrices, now   produce arrays, whose multiplication behavior differs similarly."
                                },
                                "type": "Words"
                              }
                            ]
                          },
                          "type": "Paragraph"
                        }
                      ]
                    },
                    {
                      "children": [
                        {
                          "data": {
                            "children": [
                              {
                                "data": {
                                  "value": "Sparse arrays currently must be two-dimensional.  This also means   that all "
                                },
                                "type": "Words"
                              },
                              {
                                "data": {
                                  "value": {
                                    "value": "slicing"
                                  }
                                },
                                "type": "Emph"
                              },
                              {
                                "data": {
                                  "value": " operations on these objects must produce   two-dimensional results, or they will result in an error. This   will be addressed in a future version."
                                },
                                "type": "Words"
                              }
                            ]
                          },
                          "type": "Paragraph"
                        }
                      ]
                    }
                  ]
                },
                "type": "BulletList"
              },
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "The construction utilities ("
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": null,
                        "value": "eye"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": ", "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": null,
                        "value": "kron"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": ", "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": null,
                        "value": "random"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": ", "
                      },
                      "type": "Words"
                    },
                    {
                      "data": {
                        "domain": null,
                        "role": null,
                        "value": "diags"
                      },
                      "type": "Directive"
                    },
                    {
                      "data": {
                        "value": ", etc.) have not yet been ported, but their results can be wrapped into arrays::    "
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "value": "A = csr_array(eye(3))"
                },
                "type": "BlockVerbatim"
              }
            ],
            "kind": "note",
            "title": ""
          },
          "type": "Admonition"
        }
      ],
      "title": "Sparse matrices (:mod:`scipy.sparse`)"
    },
    {
      "children": [],
      "title": "Contents"
    },
    {
      "children": [
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    bsr_array - Block Sparse Row array\n    coo_array - A sparse array in COOrdinate format\n    csc_array - Compressed Sparse Column array\n    csr_array - Compressed Sparse Row array\n    dia_array - Sparse array with DIAgonal storage\n    dok_array - Dictionary Of Keys based sparse array\n    lil_array - Row-based list of lists sparse array"
          },
          "type": "BlockVerbatim"
        }
      ],
      "title": "Sparse array classes"
    },
    {
      "children": [
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    bsr_matrix - Block Sparse Row matrix\n    coo_matrix - A sparse matrix in COOrdinate format\n    csc_matrix - Compressed Sparse Column matrix\n    csr_matrix - Compressed Sparse Row matrix\n    dia_matrix - Sparse matrix with DIAgonal storage\n    dok_matrix - Dictionary Of Keys based sparse matrix\n    lil_matrix - Row-based list of lists sparse matrix\n    spmatrix - Sparse matrix base class"
          },
          "type": "BlockVerbatim"
        }
      ],
      "title": "Sparse matrix classes"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Building sparse matrices:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    eye - Sparse MxN matrix whose k-th diagonal is all ones\n    identity - Identity matrix in sparse format\n    kron - kronecker product of two sparse matrices\n    kronsum - kronecker sum of sparse matrices\n    diags - Return a sparse matrix from diagonals\n    spdiags - Return a sparse matrix from diagonals\n    block_diag - Build a block diagonal sparse matrix\n    tril - Lower triangular portion of a matrix in sparse format\n    triu - Upper triangular portion of a matrix in sparse format\n    bmat - Build a sparse matrix from sparse sub-blocks\n    hstack - Stack sparse matrices horizontally (column wise)\n    vstack - Stack sparse matrices vertically (row wise)\n    rand - Random values in a given shape\n    random - Random values in a given shape"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Save and load sparse matrices:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    save_npz - Save a sparse matrix to a file using ``.npz`` format.\n    load_npz - Load a sparse matrix from a file using ``.npz`` format."
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Sparse matrix tools:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    find"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Identifying sparse matrices:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    issparse\n    isspmatrix\n    isspmatrix_csc\n    isspmatrix_csr\n    isspmatrix_bsr\n    isspmatrix_lil\n    isspmatrix_dok\n    isspmatrix_coo\n    isspmatrix_dia"
          },
          "type": "BlockVerbatim"
        }
      ],
      "title": "Functions"
    },
    {
      "children": [
        {
          "data": {
            "value": ".. autosummary:: \n    csgraph - Compressed sparse graph routines\n    linalg - sparse linear algebra routines"
          },
          "type": "BlockVerbatim"
        }
      ],
      "title": "Submodules"
    },
    {
      "children": [
        {
          "data": {
            "value": ".. autosummary:: \n    :toctree:generated/\n    SparseEfficiencyWarning\n    SparseWarning"
          },
          "type": "BlockVerbatim"
        }
      ],
      "title": "Exceptions"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "There are seven available sparse matrix types:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": [
              "1. csc_matrix: Compressed Sparse Column format",
              "2. csr_matrix: Compressed Sparse Row format",
              "3. bsr_matrix: Block Sparse Row format",
              "4. lil_matrix: List of Lists format",
              "5. dok_matrix: Dictionary of Keys format",
              "6. coo_matrix: COOrdinate format (aka IJV, triplet format)",
              "7. dia_matrix: DIAgonal format"
            ]
          },
          "type": "BlockQuote"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "To construct a matrix efficiently, use either dok_matrix or lil_matrix. The lil_matrix class supports basic slicing and fancy indexing with a similar syntax to NumPy arrays. As illustrated below, the COO format may also be used to efficiently construct matrices. Despite their similarity to NumPy arrays, it is "
                },
                "type": "Words"
              },
              {
                "data": {
                  "content": {
                    "value": "strongly discouraged"
                  }
                },
                "type": "Strong"
              },
              {
                "data": {
                  "value": " to use NumPy functions directly on these matrices because NumPy may not properly convert them for computations, leading to unexpected (and incorrect) results. If you do want to apply a NumPy function to these matrices, first check if SciPy has its own implementation for the given sparse matrix class, or "
                },
                "type": "Words"
              },
              {
                "data": {
                  "content": {
                    "value": "convert the\nsparse matrix to a NumPy array"
                  }
                },
                "type": "Strong"
              },
              {
                "data": {
                  "value": " (e.g., using the "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "toarray()"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " method of the class) first before applying the method."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "To perform manipulations such as multiplication or inversion, first convert the matrix to either CSC or CSR format. The lil_matrix format is row-based, so conversion to CSR is efficient, whereas conversion to CSC is less so."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "All conversions among the CSR, CSC, and COO formats are efficient, linear-time operations."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "title": "Usage information"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "To do a vector product between a sparse matrix and a vector simply use the matrix "
                },
                "type": "Words"
              },
              {
                "data": {
                  "domain": null,
                  "role": null,
                  "value": "dot"
                },
                "type": "Directive"
              },
              {
                "data": {
                  "value": " method, as described in its docstring:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> import numpy as np\n>>> from scipy.sparse import csr_matrix\n>>> A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])\n>>> v = np.array([1, 0, -1])\n>>> A.dot(v)\narray([ 1, -3, -1], dtype=int64)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "therefore using it will result on unexpected results or errors. The corresponding dense array should be obtained first instead:"
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              },
              {
                "data": {
                  "value": ">>> np.dot(A.toarray(), v)\narray([ 1, -3, -1], dtype=int64)"
                },
                "type": "BlockVerbatim"
              },
              {
                "data": {
                  "children": [
                    {
                      "data": {
                        "value": "but then all the performance advantages would be lost."
                      },
                      "type": "Words"
                    }
                  ]
                },
                "type": "Paragraph"
              }
            ],
            "kind": "warning",
            "title": "As of NumPy 1.7, `np.dot` is not aware of sparse matrices,"
          },
          "type": "Admonition"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "The CSR format is specially suitable for fast matrix vector products."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "title": "Matrix vector product"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Construct a 1000x1000 lil_matrix and add some values to it:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> from scipy.sparse import lil_matrix\n>>> from scipy.sparse.linalg import spsolve\n>>> from numpy.linalg import solve, norm\n>>> from numpy.random import rand"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "value": ">>> A = lil_matrix((1000, 1000))\n>>> A[0, :100] = rand(100)\n>>> A[1, 100:200] = A[0, :100]\n>>> A.setdiag(rand(1000))"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Now convert it to CSR format and solve A x = b for x:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> A = A.tocsr()\n>>> b = rand(1000)\n>>> x = spsolve(A, b)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Convert it to a dense matrix and solve, and check that the result is the same:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> x_ = solve(A.toarray(), b)"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Now we can compute norm of the error with:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> err = norm(x-x_)\n>>> err < 1e-10\nTrue"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "It should be small :)"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "title": "Example 1"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Construct a matrix in COO format:"
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> from scipy import sparse\n>>> from numpy import array\n>>> I = array([0,3,1,0])\n>>> J = array([0,3,1,2])\n>>> V = array([4,5,7,9])\n>>> A = sparse.coo_matrix((V,(I,J)),shape=(4,4))"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Notice that the indices do not need to be sorted."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "Duplicate (i,j) entries are summed when converting to CSR or CSC."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        },
        {
          "data": {
            "value": ">>> I = array([0,0,1,3,1,0,0])\n>>> J = array([0,2,1,3,1,0,0])\n>>> V = array([1,1,1,1,1,1,1])\n>>> B = sparse.coo_matrix((V,(I,J)),shape=(4,4)).tocsr()"
          },
          "type": "BlockVerbatim"
        },
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "This is useful for constructing finite-element stiffness and mass matrices."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "title": "Example 2"
    },
    {
      "children": [
        {
          "data": {
            "children": [
              {
                "data": {
                  "value": "CSR column indices are not necessarily sorted. Likewise for CSC row indices. Use the .sorted_indices() and .sort_indices() methods when sorted indices are required (e.g., when passing data to other libraries)."
                },
                "type": "Words"
              }
            ]
          },
          "type": "Paragraph"
        }
      ],
      "title": "Further details"
    }
  ],
  "example_section_data": {
    "children": [],
    "title": null
  },
  "item_file": "/scipy/sparse/__init__.py",
  "item_line": 0,
  "item_type": "<class 'module'>",
  "ordered_sections": [
    "Summary",
    "Extended Summary"
  ],
  "references": null,
  "refs": [],
  "see_also": [],
  "signature": {
    "value": null
  }
}