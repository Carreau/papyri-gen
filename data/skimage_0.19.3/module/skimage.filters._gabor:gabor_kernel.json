{
  "aliases": [
    "skimage.filters.gabor_kernel"
  ],
  "arbitrary": [],
  "content": {
    "Attributes": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Extended Summary": {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Gabor kernel is a Gaussian kernel modulated by a complex harmonic function. Harmonic function consists of an imaginary sine function and a real cosine function. Spatial frequency is inversely proportional to the wavelength of the harmonic and to the standard deviation of a Gaussian kernel. The bandwidth is also inversely proportional to the standard deviation."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Methods": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Notes": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Other Parameters": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Parameters": {
      "children": [
        {
          "children": [
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Spatial frequency of the harmonic function. Specified in pixels."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "frequency",
              "type": "Param",
              "type_": "float"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Orientation in radians. If 0, the harmonic is in the x-direction."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "theta",
              "type": "Param",
              "type_": "float, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The bandwidth captured by the filter. For fixed bandwidth, "
                    },
                    {
                      "type": "inlineCode",
                      "value": "sigma_x"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "type": "inlineCode",
                      "value": "sigma_y"
                    },
                    {
                      "type": "text",
                      "value": " will decrease with increasing frequency. This value is ignored if "
                    },
                    {
                      "type": "inlineCode",
                      "value": "sigma_x"
                    },
                    {
                      "type": "text",
                      "value": " and "
                    },
                    {
                      "type": "inlineCode",
                      "value": "sigma_y"
                    },
                    {
                      "type": "text",
                      "value": " are set by the user."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "bandwidth",
              "type": "Param",
              "type_": "float, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Standard deviation in x- and y-directions. These directions apply to the kernel "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "before"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " rotation. If "
                    },
                    {
                      "domain": null,
                      "role": null,
                      "type": "Directive",
                      "value": "theta = pi/2"
                    },
                    {
                      "type": "text",
                      "value": ", then the kernel is rotated 90 degrees so that "
                    },
                    {
                      "type": "inlineCode",
                      "value": "sigma_x"
                    },
                    {
                      "type": "text",
                      "value": " controls the "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "vertical"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " direction."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "sigma_x, sigma_y",
              "type": "Param",
              "type_": "float, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The linear size of the kernel is n_stds (3 by default) standard deviations"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "n_stds",
              "type": "Param",
              "type_": "scalar, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Phase offset of harmonic function in radians."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "offset",
              "type": "Param",
              "type_": "float, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Specifies if the filter is single or double precision complex."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "dtype",
              "type": "Param",
              "type_": "{np.complex64, np.complex128}"
            }
          ],
          "type": "Parameters"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Raises": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Receives": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Returns": {
      "children": [
        {
          "children": [
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Complex filter kernel."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "g",
              "type": "Param",
              "type_": "complex array"
            }
          ],
          "type": "Parameters"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Summary": {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Return complex 2D Gabor filter kernel."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Warnings": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Warns": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Yields": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    }
  },
  "example_section_data": {
    "children": [
      {
        "type": "code",
        "value": "from skimage.filters import gabor_kernel\nfrom skimage import io\nfrom matplotlib import pyplot as plt  # doctest: +SKIP"
      },
      {
        "type": "code",
        "value": "gk = gabor_kernel(frequency=0.2)\nplt.figure()        # doctest: +SKIP\nio.imshow(gk.real)  # doctest: +SKIP\nio.show()           # doctest: +SKIP"
      },
      {
        "type": "code",
        "value": "# more ripples (equivalent to increasing the size of the\n# Gaussian spread)\ngk = gabor_kernel(frequency=0.2, bandwidth=0.1)\nplt.figure()        # doctest: +SKIP\nio.imshow(gk.real)  # doctest: +SKIP\nio.show()           # doctest: +SKIP"
      }
    ],
    "level": 0,
    "target": null,
    "title": null,
    "type": "Section"
  },
  "item_file": "/skimage/filters/_gabor.py",
  "item_line": 18,
  "item_type": "<class 'function'>",
  "ordered_sections": [
    "Summary",
    "Extended Summary",
    "Parameters",
    "Returns",
    "References",
    "Examples"
  ],
  "references": null,
  "see_also": [],
  "signature": {
    "type": "Signature",
    "value": "(frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=None, n_stds=3, offset=0, dtype=<class 'numpy.complex128'>)"
  },
  "type": "DocBlob"
}