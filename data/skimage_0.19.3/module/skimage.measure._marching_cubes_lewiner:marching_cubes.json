{
  "aliases": [
    "skimage.measure.marching_cubes"
  ],
  "arbitrary": [],
  "content": {
    "Attributes": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Extended Summary": {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "In contrast with Lorensen et al. approach , Lewiner et al. algorithm is faster, resolves ambiguities, and guarantees topologically correct results. Therefore, this algorithm generally a better choice."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Methods": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Notes": {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "The algorithm  is an improved version of Chernyaev's Marching Cubes 33 algorithm. It is an efficient algorithm that relies on heavy use of lookup tables to handle the many different cases, keeping the algorithm relatively easy. This implementation is written in Cython, ported from Lewiner's C++ implementation."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "To quantify the area of an isosurface generated by this algorithm, pass verts and faces to "
            },
            {
              "anchor": null,
              "exists": true,
              "kind": "module",
              "reference": {
                "kind": "api",
                "module": "skimage",
                "path": "skimage.measure._marching_cubes_classic:mesh_surface_area",
                "type": "RefInfo",
                "version": "*"
              },
              "type": "Link",
              "value": "skimage.measure.mesh_surface_area"
            },
            {
              "type": "text",
              "value": "."
            }
          ],
          "type": "paragraph"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Regarding visualization of algorithm output, to contour a volume named "
            },
            {
              "domain": null,
              "role": null,
              "type": "Directive",
              "value": "myvolume"
            },
            {
              "type": "text",
              "value": " about the level 0.0, using the "
            },
            {
              "type": "inlineCode",
              "value": "mayavi"
            },
            {
              "type": "text",
              "value": " package    "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>>\n>> from mayavi import mlab\n>> verts, faces, _, _ = marching_cubes(myvolume, 0.0)\n>> mlab.triangular_mesh([vert[0] for vert in verts],\n                        [vert[1] for vert in verts],\n                        [vert[2] for vert in verts],\n                        faces)\n>> mlab.show()"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "Similarly using the "
            },
            {
              "type": "inlineCode",
              "value": "visvis"
            },
            {
              "type": "text",
              "value": " package    "
            }
          ],
          "type": "paragraph"
        },
        {
          "type": "code",
          "value": ">>>\n>> import visvis as vv\n>> verts, faces, normals, values = marching_cubes(myvolume, 0.0)\n>> vv.mesh(np.fliplr(verts), faces, normals, values)\n>> vv.use().Run()"
        },
        {
          "children": [
            {
              "type": "text",
              "value": "To reduce the number of triangles in the mesh for better performance, see this "
            },
            {
              "children": [
                {
                  "type": "text",
                  "value": "example"
                }
              ],
              "title": "",
              "type": "link",
              "url": "https://docs.enthought.com/mayavi/mayavi/auto/example_julia_set_decimation.html#example-julia-set-decimation"
            },
            {
              "type": "text",
              "value": " using the "
            },
            {
              "type": "inlineCode",
              "value": "mayavi"
            },
            {
              "type": "text",
              "value": " package."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Other Parameters": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Parameters": {
      "children": [
        {
          "children": [
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Input data volume to find isosurfaces. Will internally be converted to float32 if necessary."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "volume",
              "type": "Param",
              "type_": "(M, N, P) array"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Contour value to search for isosurfaces in "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "volume",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "volume"
                    },
                    {
                      "type": "text",
                      "value": ". If not given or None, the average of the min and max of vol is used."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "level",
              "type": "Param",
              "type_": "float, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Voxel spacing in spatial dimensions corresponding to numpy array indexing dimensions (M, N, P) as in "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "volume",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "volume"
                    },
                    {
                      "type": "text",
                      "value": "."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "spacing",
              "type": "Param",
              "type_": "length-3 tuple of floats, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Controls if the mesh was generated from an isosurface with gradient descent toward objects of interest (the default), or the opposite, considering the "
                    },
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "left-hand"
                        }
                      ],
                      "type": "emphasis"
                    },
                    {
                      "type": "text",
                      "value": " rule. The two options are: * descent : Object was greater than exterior * ascent : Exterior was greater than object"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "gradient_direction",
              "type": "Param",
              "type_": "string, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Step size in voxels. Default 1. Larger steps yield faster but coarser results. The result will always be topologically correct though."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "step_size",
              "type": "Param",
              "type_": "int, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Whether to allow degenerate (i.e. zero-area) triangles in the end-result. Default True. If False, degenerate triangles are removed, at the cost of making the algorithm slower."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "allow_degenerate",
              "type": "Param",
              "type_": "bool, optional"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "One of 'lewiner', 'lorensen' or '_lorensen'. Specify which of Lewiner et al. or Lorensen et al. method will be used. The '_lorensen' flag correspond to an old implementation that will be deprecated in version 0.19."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "method: str, optional",
              "type": "Param",
              "type_": ""
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Boolean array. The marching cube algorithm will be computed only on True elements. This will save computational time when interfaces are located within certain region of the volume M, N, P-e.g. the top half of the cube-and also allow to compute finite surfaces-i.e. open surfaces that do not end at the border of the cube."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "mask",
              "type": "Param",
              "type_": "(M, N, P) array, optional"
            }
          ],
          "type": "Parameters"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Raises": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Receives": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Returns": {
      "children": [
        {
          "children": [
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Spatial coordinates for V unique mesh vertices. Coordinate order matches input "
                    },
                    {
                      "anchor": null,
                      "exists": true,
                      "kind": "local",
                      "reference": {
                        "kind": "local",
                        "module": null,
                        "path": "volume",
                        "type": "RefInfo",
                        "version": null
                      },
                      "type": "Link",
                      "value": "volume"
                    },
                    {
                      "type": "text",
                      "value": " (M, N, P). If "
                    },
                    {
                      "type": "inlineCode",
                      "value": "allow_degenerate"
                    },
                    {
                      "type": "text",
                      "value": " is set to True, then the presence of degenerate triangles in the mesh can make this array have duplicate vertices."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "verts",
              "type": "Param",
              "type_": "(V, 3) array"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Define triangular faces via referencing vertex indices from "
                    },
                    {
                      "type": "inlineCode",
                      "value": "verts"
                    },
                    {
                      "type": "text",
                      "value": ". This algorithm specifically outputs triangles, so each face has exactly three indices."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "faces",
              "type": "Param",
              "type_": "(F, 3) array"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "The normal direction at each vertex, as calculated from the data."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "normals",
              "type": "Param",
              "type_": "(V, 3) array"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "Gives a measure for the maximum value of the data in the local region near each vertex. This can be used by visualization tools to apply a colormap to the mesh."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "values",
              "type": "Param",
              "type_": "(V, ) array"
            }
          ],
          "type": "Parameters"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Summary": {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Marching cubes algorithm to find surfaces in 3d volumetric data."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Warnings": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Warns": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Yields": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    }
  },
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null,
    "type": "Section"
  },
  "item_file": "/skimage/measure/_marching_cubes_lewiner.py",
  "item_line": 10,
  "item_type": "<class 'function'>",
  "ordered_sections": [
    "Summary",
    "Extended Summary",
    "Parameters",
    "Returns",
    "See Also",
    "Notes",
    "References"
  ],
  "references": null,
  "see_also": [
    {
      "descriptions": [],
      "name": {
        "anchor": null,
        "exists": true,
        "kind": "module",
        "reference": {
          "kind": "module",
          "module": "skimage",
          "path": "skimage.measure._marching_cubes_classic:mesh_surface_area",
          "type": "RefInfo",
          "version": "0.19.3"
        },
        "type": "Link",
        "value": "skimage.measure.mesh_surface_area"
      },
      "type": null
    },
    {
      "descriptions": [],
      "name": {
        "anchor": null,
        "exists": true,
        "kind": "module",
        "reference": {
          "kind": "module",
          "module": "skimage",
          "path": "skimage.measure._find_contours:find_contours",
          "type": "RefInfo",
          "version": "0.19.3"
        },
        "type": "Link",
        "value": "skimage.measure.find_contours"
      },
      "type": null
    }
  ],
  "signature": {
    "type": "Signature",
    "value": "(volume, level=None, *, spacing=(1.0, 1.0, 1.0), gradient_direction='descent', step_size=1, allow_degenerate=True, method='lewiner', mask=None)"
  },
  "type": "DocBlob"
}