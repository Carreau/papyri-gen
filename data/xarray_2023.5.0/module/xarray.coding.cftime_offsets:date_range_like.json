{
  "aliases": [
    "xarray.date_range_like"
  ],
  "arbitrary": [],
  "content": {
    "Attributes": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Extended Summary": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Methods": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Notes": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Other Parameters": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Parameters": {
      "children": [
        {
          "children": [
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "1D datetime array"
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "source",
              "type": "Param",
              "type_": "DataArray, CFTimeIndex, or pd.DatetimeIndex"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "New calendar name."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "calendar",
              "type": "Param",
              "type_": "str"
            },
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "If True, the output uses "
                    },
                    {
                      "type": "inlineCode",
                      "value": "cftime.datetime"
                    },
                    {
                      "type": "text",
                      "value": " objects. If None (default), "
                    },
                    {
                      "type": "inlineCode",
                      "value": "numpy.datetime64"
                    },
                    {
                      "type": "text",
                      "value": " values are used if possible. If False, "
                    },
                    {
                      "type": "inlineCode",
                      "value": "numpy.datetime64"
                    },
                    {
                      "type": "text",
                      "value": " values are used or an error is raised."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "use_cftime",
              "type": "Param",
              "type_": "bool, optional"
            }
          ],
          "type": "Parameters"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Raises": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Receives": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Returns": {
      "children": [
        {
          "children": [
            {
              "desc": [
                {
                  "children": [
                    {
                      "type": "text",
                      "value": "1D datetime coordinate with the same start, end and frequency as the source, but in the new calendar. The start date is assumed to exist in the target calendar. If the end date doesn't exist, the code tries 1 and 2 calendar days before. There is a special case when the source time series is daily or coarser and the end of the input range is on the last day of the month. Then the output range will also end on the last day of the month in the new calendar."
                    }
                  ],
                  "type": "paragraph"
                }
              ],
              "param": "",
              "type": "Param",
              "type_": "DataArray"
            }
          ],
          "type": "Parameters"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Summary": {
      "children": [
        {
          "children": [
            {
              "type": "text",
              "value": "Generate a datetime array with the same frequency, start and end as another one, but in a different calendar."
            }
          ],
          "type": "paragraph"
        }
      ],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Warnings": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Warns": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    },
    "Yields": {
      "children": [],
      "level": 0,
      "target": null,
      "title": null,
      "type": "Section"
    }
  },
  "example_section_data": {
    "children": [],
    "level": 0,
    "target": null,
    "title": null,
    "type": "Section"
  },
  "item_file": "/xarray/coding/cftime_offsets.py",
  "item_line": 1243,
  "item_type": "<class 'function'>",
  "ordered_sections": [
    "Summary",
    "Parameters",
    "Returns"
  ],
  "references": null,
  "see_also": [],
  "signature": {
    "type": "Signature",
    "value": "(source, calendar, use_cftime=None)"
  },
  "type": "DocBlob"
}